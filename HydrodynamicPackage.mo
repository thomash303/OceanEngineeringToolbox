package OET
  extends Modelica.Icons.Package;

  package Example
    extends Modelica.Icons.Package;

    model multibodyWEC
      extends Modelica.Icons.Package;
      // World component (no gravity, Z-axis pointing downwards)
      inner Modelica.Mechanics.MultiBody.World world(gravityType = Modelica.Mechanics.MultiBody.Types.GravityTypes.NoGravity, n = {0, 0, -1}) "World coordinate system without gravity" annotation(
        Placement(transformation(origin = {-40, -20}, extent = {{-10, -10}, {10, 10}})));
      // Prismatic joint constraining motion in heave
      // Force and torque element (adapt wave output to a force and apply to the body)
      // Define hydrodynamic body
      inner Hydro.FilePath filePath annotation(
        Placement(transformation(origin = {134, -18}, extent = {{-10, -10}, {10, 10}})));
      inner Wave.Environment environment(n_omega = 100) annotation(
        Placement(transformation(origin = {52, 22}, extent = {{-10, -10}, {10, 10}})));
  Hydro.HydrodynamicBody hydrodynamicBody(BodyIndex = 2)  annotation(
        Placement(transformation(origin = {10, -12}, extent = {{-10, -10}, {10, 10}})));
  Hydro.HydrodynamicBody hydrodynamicBody1(BodyIndex = 1)  annotation(
        Placement(transformation(origin = {70, -16}, extent = {{-10, -10}, {10, 10}})));
  PTO.LinearPTO linearPTO annotation(
        Placement(transformation(origin = {38, -40}, extent = {{-10, -10}, {10, 10}})));
  Mooring.LinearMooring linearMooring  annotation(
        Placement(transformation(origin = {-24, -46}, extent = {{-10, -10}, {10, 10}})));
  Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic1(n = {0, 0, 1})  annotation(
        Placement(transformation(origin = {42, 2}, extent = {{-10, -10}, {10, 10}})));
    equation
// Connections
      connect(hydrodynamicBody.frame_b, linearPTO.frame_a) annotation(
        Line(points = {{20, -12}, {28, -12}, {28, -40}}, color = {95, 95, 95}));
      connect(hydrodynamicBody1.frame_a, linearPTO.frame_b) annotation(
        Line(points = {{60, -16}, {60, -30}, {48, -30}, {48, -40}}, color = {95, 95, 95}));
      connect(linearMooring.frame_a, hydrodynamicBody.frame_a) annotation(
        Line(points = {{-34, -46}, {0, -46}, {0, -12}}, color = {95, 95, 95}));
      connect(prismatic1.frame_b, hydrodynamicBody1.frame_a) annotation(
        Line(points = {{52, 2}, {60, 2}, {60, -16}}, color = {95, 95, 95}));
      connect(prismatic1.frame_a, hydrodynamicBody.frame_b) annotation(
        Line(points = {{32, 2}, {20, 2}, {20, -12}}, color = {95, 95, 95}));
      annotation(
        Icon(graphics = {Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Ellipse(extent = {{-20, 20}, {20, -20}}, lineColor = {0, 0, 0}, fillColor = {0, 0, 0}, fillPattern = FillPattern.Solid)}),
        Documentation(info = "<html>
        <p><b>1D Single-Body Wave Energy Converter (WEC) Model</b></p>
        <p>This model represents a simplified 1D single-body wave energy converter system, 
        focusing on the vertical motion of the body in response to wave excitation forces.</p>
        
        <p><b>Model Description</b></p>
        <p>The WEC consists of a hydrodynamic body constrained to move vertically using a prismatic joint. 
        The body is subjected to wave excitation forces generated by Regular (Linear) and Irregular (PM, Bretschneider, JONSWAP) wave profiles.</p>
        
        <p><b>Key Components</b></p>
        <ul>
          <li><code>world</code>: Defines the world coordinate system without gravity</li>
          <li><code>bodyHD6D</code>: Represents the hydrodynamic body of the WEC</li>
          <li><code>prismatic</code>: Allows vertical motion of the body</li>
          <li><code>Regular and Irregular Wave Profiles</code>: Generates regular and irregular wave excitation forces</li>
          <li><code>forceAndTorque</code>: Applies the excitation force to the body</li>
        </ul>
        
        <p><b>Assumptions and Simplifications</b></p>
        <ul>
          <li>The model considers only vertical motion (1D) of the WEC</li>
          <li>Gravity is not included in the world model</li>
          <li>The excitation force is applied as an external input based on the Pierson-Moskowitz or Regular wave profile</li>
        </ul>
        
        <p><b>Notes</b></p>
        <ul>
          <li>This model serves as a basic framework for WEC simulations and can be extended for more complex analyses</li>
          <li>Additional forces like radiation damping or PTO forces can be added to enhance the model's realism</li>
          <li>Ensure that the BodyHD6D component is properly configured for accurate results</li>
          <li>The wave parameters may need to be adjusted to represent specific sea states</li>
        </ul>
      </html>"),
        Diagram(coordinateSystem(extent = {{-80, 0}, {150, -40}})),
        experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
    end multibodyWEC;
    
    model multibodyCoupledWEC
      extends Modelica.Icons.Package;
      // World component (no gravity, Z-axis pointing downwards)
      inner Modelica.Mechanics.MultiBody.World world(gravityType = Modelica.Mechanics.MultiBody.Types.GravityTypes.NoGravity, n = {0, 0, -1}) "World coordinate system without gravity" annotation(
        Placement(transformation(origin = {-40, -20}, extent = {{-10, -10}, {10, 10}})));
      // Prismatic joint constraining motion in heave
      // Force and torque element (adapt wave output to a force and apply to the body)
      // Define hydrodynamic body
      inner Hydro.FilePath filePath annotation(
        Placement(transformation(origin = {134, -18}, extent = {{-10, -10}, {10, 10}})));
      inner Wave.Environment environment(n_omega = 100) annotation(
        Placement(transformation(origin = {102, -12}, extent = {{-10, -10}, {10, 10}})));
    Hydro.HydrodynamicBodyB2B spar(BodyIndex = 2)  annotation(
        Placement(transformation(origin = {10, -12}, extent = {{-10, -10}, {10, 10}})));
    Hydro.HydrodynamicBodyB2B float(BodyIndex = 1)  annotation(
        Placement(transformation(origin = {70, -16}, extent = {{-10, -10}, {10, 10}})));
    PTO.LinearPTO linearPTO annotation(
        Placement(transformation(origin = {38, -44}, extent = {{-10, -10}, {10, 10}})));
    Mooring.LinearMooring linearMooring  annotation(
        Placement(transformation(origin = {-24, -46}, extent = {{-10, -10}, {10, 10}})));
    Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic(n = {0, 0, 1})  annotation(
        Placement(transformation(origin = {-16, 2}, extent = {{-10, -10}, {10, 10}})));
    Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic1(n = {0, 0, 1})  annotation(
        Placement(transformation(origin = {42, 2}, extent = {{-10, -10}, {10, 10}})));
  inner Hydro.CouplingB2B couplingB2B annotation(
        Placement(transformation(origin = {92, -40}, extent = {{-10, -10}, {10, 10}})));
    equation
// Connections
      connect(spar.frame_b, linearPTO.frame_a) annotation(
        Line(points = {{20, -12}, {20, -14}, {28, -14}, {28, -44}}, color = {95, 95, 95}));
      connect(float.frame_a, linearPTO.frame_b) annotation(
        Line(points = {{60, -16}, {60, -30}, {48, -30}, {48, -44}}, color = {95, 95, 95}));
      connect(linearMooring.frame_a, spar.frame_a) annotation(
        Line(points = {{-34, -46}, {0, -46}, {0, -12}}, color = {95, 95, 95}));
    connect(prismatic.frame_b, spar.frame_a) annotation(
        Line(points = {{-6, 2}, {0, 2}, {0, -12}}, color = {95, 95, 95}));
    connect(prismatic.frame_a, world.frame_b) annotation(
        Line(points = {{-26, 2}, {-30, 2}, {-30, -20}}, color = {95, 95, 95}));
    connect(prismatic1.frame_b, float.frame_a) annotation(
        Line(points = {{52, 2}, {60, 2}, {60, -16}}, color = {95, 95, 95}));
    connect(prismatic1.frame_a, spar.frame_b) annotation(
        Line(points = {{32, 2}, {20, 2}, {20, -12}}, color = {95, 95, 95}));
      annotation(
        Icon(graphics = {Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Ellipse(extent = {{-20, 20}, {20, -20}}, lineColor = {0, 0, 0}, fillColor = {0, 0, 0}, fillPattern = FillPattern.Solid)}),
        Documentation(info = "<html>
        <p><b>1D Single-Body Wave Energy Converter (WEC) Model</b></p>
        <p>This model represents a simplified 1D single-body wave energy converter system, 
        focusing on the vertical motion of the body in response to wave excitation forces.</p>
        
        <p><b>Model Description</b></p>
        <p>The WEC consists of a hydrodynamic body constrained to move vertically using a prismatic joint. 
        The body is subjected to wave excitation forces generated by Regular (Linear) and Irregular (PM, Bretschneider, JONSWAP) wave profiles.</p>
        
        <p><b>Key Components</b></p>
        <ul>
          <li><code>world</code>: Defines the world coordinate system without gravity</li>
          <li><code>bodyHD6D</code>: Represents the hydrodynamic body of the WEC</li>
          <li><code>prismatic</code>: Allows vertical motion of the body</li>
          <li><code>Regular and Irregular Wave Profiles</code>: Generates regular and irregular wave excitation forces</li>
          <li><code>forceAndTorque</code>: Applies the excitation force to the body</li>
        </ul>
        
        <p><b>Assumptions and Simplifications</b></p>
        <ul>
          <li>The model considers only vertical motion (1D) of the WEC</li>
          <li>Gravity is not included in the world model</li>
          <li>The excitation force is applied as an external input based on the Pierson-Moskowitz or Regular wave profile</li>
        </ul>
        
        <p><b>Notes</b></p>
        <ul>
          <li>This model serves as a basic framework for WEC simulations and can be extended for more complex analyses</li>
          <li>Additional forces like radiation damping or PTO forces can be added to enhance the model's realism</li>
          <li>Ensure that the BodyHD6D component is properly configured for accurate results</li>
          <li>The wave parameters may need to be adjusted to represent specific sea states</li>
        </ul>
      </html>"),
        Diagram(coordinateSystem(extent = {{-80, 0}, {150, -40}})),
        experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
    end multibodyCoupledWEC;
    annotation(
      Icon(graphics = {Polygon(points = {{-40, 40}, {40, 0}, {-40, -40}, {-40, 40}}, lineColor = {0, 0, 0}, fillColor = // Red color for the polygon
      {0, 0, 0}, fillPattern = // Red fill
      FillPattern.Solid)}),
      Documentation(info = "<html>
        <p><b>Wave Energy Converter (WEC) Examples</b></p>
        <p>This package contains example models for Wave Energy Converter (WEC) systems. 
        It provides a set of ready-to-use models that demonstrate various aspects of WEC modeling and simulation.</p>
        
        <p><b>Package Contents</b></p>
        <ul>
          <li><b>SingleBodyWEC1D</b>: A 1D model of a single-body wave energy converter. The hydrodynamic data from the Toroidal Float of the US DoE RM-3</li>
        </ul>
        
        <p><b>Usage</b></p>
        <p>The models in this package can be used as starting points for more complex WEC simulations 
        or as educational tools to understand the basic principles of WEC modeling.</p>
        
        <p><b>See Also</b></p>
        <p>For more detailed information on individual models, please refer to their respective documentation.</p>
      </html>"));
  end Example;

  package Models
    partial model physicalConstants "Defining pi and the acceleration due to gravity"
    protected
      // Physical constants
      constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
      constant Modelica.Units.SI.Acceleration g = Modelica.Constants.g_n "Acceleration due to gravity [m/s^2]";
    end physicalConstants;

    partial model forceTorque "Declaring force and torque elements, inheriting forceTorque connector"
      extends OET.Connector.forceTorque_con;
      Real f[6] = cat(1, f_element, t_element);
      // should alter to make nDoF
    protected
      Modelica.Units.SI.Force f_element[3];
      Modelica.Units.SI.Torque t_element[3];
    end forceTorque;

    model positionSensorInput
      // Inheritance
      extends Hydrodynamic.Connector.absolutePosition_con;
    protected
      Real displacement[6] "Combined displacement vector [m, rad]";
    equation
// Combine linear and angular displacements into a single vector
      displacement = cat(1, u_abs, theta_abs);
    end positionSensorInput;

    model velocitySensorInput
      extends Hydrodynamic.Connector.absoluteVelocity_con;
    protected
      Real velocity[6] "Combined velocity vector [m/s, rad/s]";
    equation
// Combine linear and angular velocities into a single vector
      velocity = cat(1, v_abs, omega_abs);
    end velocitySensorInput;

    model accelerationSensorInput
      extends Hydrodynamic.Connector.absoluteAcceleration_con;
    protected
      Real acceleration[6] "Combined velocity vector [m/s, rad/s]";
    equation
// Combine linear and angular accelerations into a single vector
      velocity = cat(1, a_abs, alpha_abs);
    end accelerationSensorInput;

    model sensorInput
      extends Hydrodynamic.Connector.absolutePosition_con;
      extends Hydrodynamic.Connector.absoluteVelocity_con;
      extends Hydrodynamic.Connector.absoluteAcceleration_con;
    end sensorInput;

    model absolutePositionSensor
      // Inheritance
      extends Hydrodynamic.Connectors.Sensor.absolutePositionSensor_con;
      extends Hydrodynamic.Connectors.Sensor.positionOutput_con;
    equation
// Combine linear and angular displacements into a single vector
      displacement = cat(1, u_abs, theta_abs);
    end absolutePositionSensor;
  end Models;

  package Units
    type SpectrumEnergyDensity = Real(final quantity = "SpectrumEnergyDensity", final unit = "m^2 s/rad");
  end Units;

  package Internal
  package absoluteSensor
      package Models
        partial model absolutePositionSensor
          // Define connector to read translational and rotational positions
          extends OET.Internal.absoluteSensor.Connectors.absolutePositionSensor_con;
        protected
          Real displacement[6] "Combined displacement vector [m, rad]";
        equation
// Combine linear and angular displacements into a single vector
          displacement = cat(1, u_abs, theta_abs);
        end absolutePositionSensor;

        partial model absoluteVelocitySensor
          // Inheritance
          extends OET.Internal.absoluteSensor.Connectors.absoluteVelocitySensor_con;
        protected
          Real velocity[6] "Combined velocity vector [m/s, rad/s]";
        equation
// Combine linear and angular displacements into a single vector
          velocity = cat(1, v_abs, omega_abs);
        end absoluteVelocitySensor;

        model absoluteAccelerationSensor
          // Inheritance
          extends OET.Internal.absoluteSensor.Connectors.absoluteAccelerationSensor_con;
          extends OET.Internal.absoluteSensor.Connectors.accelerationOutput_con;
        equation
// Combine linear and angular displacements into a single vector
          acceleration = cat(1, a_abs, alpha_abs);
        end absoluteAccelerationSensor;

        model absoluteSensors
          extends OET.Internal.absoluteSensor.Models.absolutePositionSensor;
          extends OET.Internal.absoluteSensor.Models.absoluteVelocitySensor;
          extends OET.Internal.absoluteSensor.Models.absoluteAccelerationSensor;
        end absoluteSensors;

        partial model absolutePositionSensor_portB
          // Define connector to read translational and rotational positions
          extends Internal.absoluteSensor.Connectors.absolutePositionSensor_con;
          Modelica.Blocks.Interfaces.RealInput u_abs[3] "Linear displacement vector [m]" annotation(
            Placement(transformation(origin = {100, -115}, extent = {{-15, -15}, {15, 15}}, rotation = 90), iconTransformation(origin = {100, -115}, extent = {{-15, -15}, {15, 15}}, rotation = 90)));
          Modelica.Blocks.Interfaces.RealInput theta_abs[3] "Angular displacement vector [rad]" annotation(
            Placement(transformation(origin = {60, -115}, extent = {{-15, -15}, {15, 15}}, rotation = 90), iconTransformation(origin = {60, -115}, extent = {{-15, -15}, {15, 15}}, rotation = 90)));
        protected
          Real displacement[6] "Combined displacement vector [m, rad]";
        equation
// Combine linear and angular displacements into a single vector
          displacement = cat(1, absoluteDisplacement.u_abs, absoluteDisplacement.theta_abs);
        end absolutePositionSensor_portB;
      end Models;

      package Connectors
        connector absolutePositionSensor_con
          Modelica.Blocks.Interfaces.RealInput u_abs[3] "Linear displacement vector [m]" annotation(
            Placement(visible = true, transformation(origin = {100, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {100, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
          Modelica.Blocks.Interfaces.RealInput theta_abs[3] "Angular displacement vector [rad]" annotation(
            Placement(transformation(origin = {60, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {60, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
          annotation(
            Documentation(info = "<html>
        <p><strong>absolutePosition_con Connector</strong></p>
        <p>This connector is used to specify the absolute position and orientation of a component in a 3-dimensional space. It provides input ports for defining linear and angular displacements.</p>
        <p><strong>Ports:</strong></p>
        <ul>
          <li><strong>u_abs:</strong> A 3-dimensional vector representing linear displacement in meters. This vector describes the position of the component in space relative to a reference point.</li>
          <li><strong>theta_abs:</strong> A 3-dimensional vector representing angular displacement in radians. This vector describes the orientation of the component around each axis.</li>
        </ul>
        <p><strong>Usage:</strong></p>
        <p>Utilize this connector in models where precise positioning and orientation of components are required, such as in robotic arms, mechanical linkages, or spatial transformations.</p>
        </html>"));
        end absolutePositionSensor_con;

        connector positionOutput_con
          Modelica.Blocks.Interfaces.RealOutput displacement[6] "Total displacement vector [m, rad]" annotation(
            Placement(transformation(origin = {110, 50}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {110, 50}, extent = {{-10, -10}, {10, 10}})));
        end positionOutput_con;

        connector positionInput_con
          Modelica.Blocks.Interfaces.RealInput displacement[6] "Total displacement vector [m, rad]" annotation(
            Placement(transformation(origin = {-120, 50}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-120, 50}, extent = {{-20, -20}, {20, 20}})));
        end positionInput_con;

        connector absoluteVelocitySensor_con
          Modelica.Blocks.Interfaces.RealInput v_abs[3] "Linear velocity vector [m/s]" annotation(
            Placement(transformation(origin = {20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
          Modelica.Blocks.Interfaces.RealInput omega_abs[3] "Angular velocity vector [rad/s]" annotation(
            Placement(transformation(origin = {-20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {-20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
          annotation(
            Documentation(info = "<html>
        <p><strong>absolutePosition_con Connector</strong></p>
        <p>This connector is used to specify the absolute position and orientation of a component in a 3-dimensional space. It provides input ports for defining linear and angular displacements.</p>
        <p><strong>Ports:</strong></p>
        <ul>
          <li><strong>u_abs:</strong> A 3-dimensional vector representing linear displacement in meters. This vector describes the position of the component in space relative to a reference point.</li>
          <li><strong>theta_abs:</strong> A 3-dimensional vector representing angular displacement in radians. This vector describes the orientation of the component around each axis.</li>
        </ul>
        <p><strong>Usage:</strong></p>
        <p>Utilize this connector in models where precise positioning and orientation of components are required, such as in robotic arms, mechanical linkages, or spatial transformations.</p>
        </html>"));
        end absoluteVelocitySensor_con;

        connector velocityOutput_con
          Modelica.Blocks.Interfaces.RealOutput velocity[6] "Total velocity vector [m/s, rad/s]" annotation(
            Placement(transformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}})));
        end velocityOutput_con;

        connector velocityInput_con
          Modelica.Blocks.Interfaces.RealInput velocity[6] "Total velocity vector [m/s, rad/s]" annotation(
            Placement(transformation(origin = {-120, 0}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-120, 0}, extent = {{-20, -20}, {20, 20}})));
        end velocityInput_con;

        connector absoluteAccelerationSensor_con
          Modelica.Blocks.Interfaces.RealInput a_abs[3] "Linear acceleration vector [m/s^2]" annotation(
            Placement(transformation(origin = {-60, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {-60, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
          Modelica.Blocks.Interfaces.RealInput alpha_abs[3] "Angular velocity vector [rad/s^2]" annotation(
            Placement(transformation(origin = {-100, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {-100, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
          annotation(
            Documentation(info = "<html>
        <p><strong>absolutePosition_con Connector</strong></p>
        <p>This connector is used to specify the absolute position and orientation of a component in a 3-dimensional space. It provides input ports for defining linear and angular displacements.</p>
        <p><strong>Ports:</strong></p>
        <ul>
          <li><strong>u_abs:</strong> A 3-dimensional vector representing linear displacement in meters. This vector describes the position of the component in space relative to a reference point.</li>
          <li><strong>theta_abs:</strong> A 3-dimensional vector representing angular displacement in radians. This vector describes the orientation of the component around each axis.</li>
        </ul>
        <p><strong>Usage:</strong></p>
        <p>Utilize this connector in models where precise positioning and orientation of components are required, such as in robotic arms, mechanical linkages, or spatial transformations.</p>
        </html>"));
        end absoluteAccelerationSensor_con;

        connector accelerationOutput_con
          Modelica.Blocks.Interfaces.RealOutput acceleration[6] "Total acceleration vector [m/s^2, rad/s^2]" annotation(
            Placement(transformation(origin = {110, -50}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {110, -50}, extent = {{-10, -10}, {10, 10}})));
        end accelerationOutput_con;

        connector accelerationInput_con
          Modelica.Blocks.Interfaces.RealInput acceleration[6] "Total acceleration vector [m/s^2, rad/s^2]" annotation(
            Placement(transformation(origin = {-120, -50}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-120, -50}, extent = {{-20, -20}, {20, 20}})));
        end accelerationInput_con;
      end Connectors;

      package Connector
        connector translationalPosition
          Modelica.Blocks.Interfaces.RealInput u_abs[3] "Linear displacement vector [m]";
          annotation(
            Placement(visible = true, transformation(origin = {100, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {100, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
          annotation(
            defaultComponentName = "TranslationalPosition",
            Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100, -100}, {100, 100}}, initialScale = 0.16), graphics = {Rectangle(extent = {{-10, 10}, {10, -10}}, lineColor = {95, 95, 95}, lineThickness = 0.5), Rectangle(extent = {{-30, 100}, {30, -100}}, fillColor = {192, 192, 192}, fillPattern = FillPattern.Solid)}),
            Diagram(coordinateSystem(preserveAspectRatio = true, extent = {{-100, -100}, {100, 100}}, initialScale = 0.16), graphics = {Text(extent = {{-140, -50}, {140, -90}}, textString = "%name"), Rectangle(extent = {{-12, 40}, {12, -40}}, fillColor = {192, 192, 192}, fillPattern = FillPattern.Solid)}));
        end translationalPosition;
      end Connector;
    end absoluteSensor;

    package Force
      partial model forceTorqueOneFrame "Declaring force and torque elements, inheriting forceTorque connector for one frame"
        // Inherit frame_b
        extends Modelica.Mechanics.MultiBody.Interfaces.PartialOneFrame_b;
        Real F[6] = cat(1, f_element, t_element);
        // should alter to make nDoF
      protected
        Modelica.Units.SI.Force f_element[3];
        Modelica.Units.SI.Torque t_element[3];
      equation
        frame_b.f = F[1:3];
        frame_b.t = F[4:6];
      end forceTorqueOneFrame;

      partial model forceTorqueTwoFrame "Declaring force and torque elements, inheriting forceTorque connector for one frame"
        // Inherit frame_a and frame_b
        extends Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames;
        Real F[6] = cat(1, f_element, t_element);
        // should alter to make nDoF
      protected
        Modelica.Units.SI.Force f_element[3];
        Modelica.Units.SI.Torque t_element[3];
      equation
        frame_a.f = -F[1:3];
        frame_a.t = -F[4:6];
        frame_b.f = F[1:3];
        frame_b.t = F[4:6];
      end forceTorqueTwoFrame;
    end Force;
  end Internal;

  package DataImport
    record filePath
      parameter String fileName "File path to file storing the hydrodynamic data" annotation(
        Dialog(group = "Filepath"));
      parameter Integer bodyIndex = 1 "Index of body corresponding to that of BEM" annotation(
        Dialog(group = "Filepath"));
      // this will need to be moved, not all bodies inheriting filename need body index
    end filePath;

    partial model massData
      extends DataImport.multibodyData;
    protected
      parameter Modelica.Units.SI.Mass M_full[1, nbodies] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.bodies.m", 1, nbodies) "Total mass of the body (including ballast) for all bodies";
      parameter Modelica.Units.SI.Mass Ainf_full[nDoF, nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.coefficients.radiation.Ainf", nDoF, nDoF) "Added mass at maximum (cut-off) frequency for all bodies";
      parameter Modelica.Units.SI.Mass M = M_full[1, bodyIndex] "Total mass of the body (including ballast)";
      parameter Modelica.Units.SI.Mass Ainf[bodyDoF, nDoF] = Ainf_full[bodyDoF*(bodyIndex - 1) + 1:bodyDoF*bodyIndex, :] "Added mass at maximum (cut-off) frequency";
    end massData;

    partial model hydrostaticData
      extends DataImport.multibodyData;
    protected
      parameter Modelica.Units.SI.TranslationalSpringConstant Khs_full[bodyDoF, nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.coefficients.Khs", bodyDoF, nDoF) "Hydrostatic stiffness for all bodies";
      parameter Modelica.Units.SI.TranslationalSpringConstant Khs[bodyDoF, bodyDoF] = Khs_full[:, bodyDoF*(bodyIndex - 1) + 1:bodyDoF*bodyIndex] "Hydrostatic stiffness";
    end hydrostaticData;

    partial model multibodyData
      extends DataImport.filePath;
    protected
      parameter Real nbodies_read = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.bodies.Nb", 1, 1)) "Number of bodies";
      parameter Integer nbodies = integer(nbodies_read) "Number of bodies";
      parameter Integer bodyDoF = 6 "Degrees-of-Freedom per body";
      // assuming all bodies are 6 DoF
      parameter Integer nDoF = nbodies*bodyDoF "Total Degrees-of-Freedom";     
    end multibodyData;

    partial model frequencyData
      extends DataImport.filePath;
    protected
      parameter Integer wDim[2] = Modelica.Utilities.Streams.readMatrixSize(fileName, "hydro.parameters.w") "Dimensions of the frequency vector";
      parameter Real w[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.parameters.w", wDim[1], 1)) "Angular frequency vector [rad/s]";
    end frequencyData;

    partial model physicalConstantData
      extends DataImport.filePath;
    protected
      parameter Modelica.Units.SI.Density rho = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.parameters.rho", 1, 1)) "Density of seawater [kg/m^3]" annotation(
        Dialog(group = "Environmental Parameters"));
    end physicalConstantData;

    partial model excitationData
      extends DataImport.multibodyData;
      extends DataImport.frequencyData;
    protected
      parameter Real F_excRe_full[nDoF, wDim[1]] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.coefficients.excitation.spectralDecomp.re", nDoF, wDim[1]) "Real part of excitation force coefficients for all bodies";
      parameter Real F_excIm_full[nDoF, wDim[1]] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.coefficients.excitation.spectralDecomp.im", nDoF, wDim[1]) "Imaginary part of excitation force coefficients for all bodies";
      parameter Real F_excRe[bodyDoF, wDim[1]] = F_excRe_full[bodyDoF*(bodyIndex - 1) + 1:bodyDoF*bodyIndex, :] "Real part of excitation force coefficients";
      parameter Real F_excIm[bodyDoF, wDim[1]] = F_excIm_full[bodyDoF*(bodyIndex - 1) + 1:bodyDoF*bodyIndex, :] "Imaginary part of excitation force coefficients";
    end excitationData;

    partial model radiationDataB2B
      extends DataImport.multibodyData;
    protected
      parameter Real n_stateSpace[nDoF, nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.coefficients.radiation.stateSpace.order", nDoF, nDoF) "State-space approximation for each mode";
      // probably don't need this
      parameter Integer n_state[2] = Modelica.Utilities.Streams.readMatrixSize(fileName, "hydro.coefficients.radiation.stateSpace.A") "Number of states for all bodies";
      parameter Real n_states_full_read[1, nbodies] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.coefficients.radiation.stateSpace.bodyOrder", 1, nbodies) "Number of states for all bodies";
      //parameter Integer n_states_full[1, nbodies] = integer(n_states_full_read);
      parameter Real A_full[n_state[1], n_state[1]] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.coefficients.radiation.stateSpace.A", n_state[1], n_state[1]) "State matrix for all bodies";
      parameter Real B_full[n_state[1], nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.coefficients.radiation.stateSpace.B", n_state[1], nDoF) "Input matrix for all bodies";
      parameter Real C_full[nDoF, n_state[1]] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.coefficients.radiation.stateSpace.C", nDoF, n_state[1]) "Output matrix for all bodies";
      parameter Real D_full[nDoF, nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.coefficients.radiation.stateSpace.D", nDoF, nDoF) "Feedforward matrix for all bodies";
      parameter Integer n_states = integer(n_states_full_read[1, bodyIndex]) "Number of states";
      Real A[n_states, n_states] = A_full[stateStart + 1:stateStart + n_states, stateStart + 1:stateStart + n_states] "State matrix";
      Real B[n_states, nDoF] = B_full[stateStart + 1:stateStart + n_states, :] "Input matrix";
      Real C[bodyDoF, n_states] = C_full[bodyDoF*(bodyIndex - 1) + 1:bodyDoF*bodyIndex, stateStart + 1:stateStart + n_states] "Output matrix";
      Real D[bodyDoF, nDoF] = D_full[bodyDoF*(bodyIndex - 1) + 1:bodyDoF*bodyIndex, :] "Feedforward matrix";
      
      parameter Real one[1,1] = fill(1,1,1);
      parameter Real stateStartInter[(nbodies+1),1] = cat(1,one,transpose(n_states_full_read)) "Intermediate vector";
      parameter Integer stateStart = integer(sum(stateStartInter[1:bodyIndex]));
    
    end radiationDataB2B;

    partial model waveData
      extends OET.DataImport.filePath;
      parameter Modelica.Units.SI.Length d = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.parameters.depth", 1, 1)) "Water depth [m]" annotation(
        Dialog(group = "Wave Spectrum Parameters"));
      // allow user option to adjust in wave
      parameter Modelica.Units.SI.Angle heading = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.parameters.heading", 1, 1)) "Wave Heading [theta]" annotation(
        Dialog(group = "Wave Spectrum Parameters"));
      // use can adjust, but they shouldn't
    end waveData;

    partial model linearPTOData
    
      extends DataImport.multibodyData;
    protected
      parameter Modelica.Units.SI.TranslationalSpringConstant Kpto[bodyDoF, bodyDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.pto.linear.kpto", bodyDoF, bodyDoF) "PTO stiffness";
      parameter Modelica.Units.SI.TranslationalDampingConstant Cpto[bodyDoF, bodyDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.pto.linear.cpto", bodyDoF, bodyDoF) "PTO damping";
    
    end linearPTOData;

    partial model linearMooringData
      extends OET.DataImport.multibodyData;
      
      protected
      parameter Modelica.Units.SI.TranslationalSpringConstant Km[bodyDoF, bodyDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.mooring.linear.km", bodyDoF, bodyDoF) "Mooring stiffness";
      parameter Modelica.Units.SI.TranslationalDampingConstant Cm[bodyDoF, bodyDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.mooring.linear.cm", bodyDoF, bodyDoF) "Mooring damping";
    
    end linearMooringData;

    partial model radiationData
      extends OET.DataImport.multibodyData;
    protected
      parameter Real n_stateSpace[nDoF, nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.coefficients.radiation.stateSpace.order", nDoF, nDoF) "State-space approximation for each mode";
      // probably don't need this
      parameter Integer n_state[2] = Modelica.Utilities.Streams.readMatrixSize(fileName, "hydro.coefficients.radiation.stateSpace.A") "Number of states for all bodies";
      parameter Real n_states_full_read[1, nbodies] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.coefficients.radiation.stateSpace.bodyOrder", 1, nbodies) "Number of states for all bodies";
      parameter Real n_states_full_read_Uncoupled[1,nbodies] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.coefficients.radiation.stateSpace.bodyOrderUncoupled", 1, nbodies) "Number of states for all bodies uncoupled";
     //parameter Integer n_states_full[1, nbodies] = integer(n_states_full_read);
      //parameter Integer n_states_full_Uncoupled[1,nbodies] = integer(n_states_full_read_Uncoupled);
      parameter Real A_full[n_state[1], n_state[1]] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.coefficients.radiation.stateSpace.A", n_state[1], n_state[1]) "State matrix for all bodies";
      parameter Real B_full[n_state[1], nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.coefficients.radiation.stateSpace.B", n_state[1], nDoF) "Input matrix for all bodies";
      parameter Real C_full[nDoF, n_state[1]] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.coefficients.radiation.stateSpace.C", nDoF, n_state[1]) "Output matrix for all bodies";
      parameter Real D_full[nDoF, nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydro.coefficients.radiation.stateSpace.D", nDoF, nDoF) "Feedforward matrix for all bodies";
      parameter Integer n_states = integer(n_states_full_read[1, bodyIndex]) "Number of states";
      parameter Integer n_states_Uncoupled = integer(n_states_full_read_Uncoupled[1, bodyIndex]) "Number of states";
      Real A[n_states_Uncoupled, n_states_Uncoupled] = A_full[stateStart + 1:stateStart + n_states_Uncoupled, stateStart + 1:stateStart + n_states_Uncoupled];
      //Real A[n_states_Uncoupled, n_states_Uncoupled] = zeros(n_states_Uncoupled,n_states_Uncoupled) "State matrix";
      Real B[n_states_Uncoupled, bodyDoF] = B_full[stateStart + 1:stateStart + n_states_Uncoupled, bodyDoF*(bodyIndex - 1) + 1:bodyDoF*bodyIndex] "Input matrix";
      //Real B[n_states_Uncoupled, bodyDoF] = zeros(n_states_Uncoupled, bodyDoF) "Input matrix";
      Real C[bodyDoF, n_states_Uncoupled] = C_full[bodyDoF*(bodyIndex - 1) + 1:bodyDoF*bodyIndex, stateStart + 1:stateStart + n_states_Uncoupled] "Output matrix";
      //Real C[bodyDoF, n_states_Uncoupled] = zeros(bodyDoF, n_states_Uncoupled) "Output matrix";
      Real D[bodyDoF, bodyDoF] = D_full[bodyDoF*(bodyIndex - 1) + 1:bodyDoF*bodyIndex, bodyDoF*(bodyIndex - 1) + 1:bodyDoF*bodyIndex] "Feedforward matrix";
      //Real D[bodyDoF, bodyDoF] = zeros(bodyDoF, bodyDoF) "Feedforward matrix";
      parameter Real one[1,1] = fill(1,1,1);
      parameter Real stateStartInter[(nbodies+1),1] = cat(1,one,transpose(n_states_full_read_Uncoupled)) "Intermediate vector";
      parameter Integer stateStart = integer(sum(stateStartInter[1:bodyIndex]));
    
    end radiationData;
  end DataImport;

  package Hydro
    model HydrodynamicBody "6-Dimensional Hydrodynamic Forces and Moments Calculation"
      // Inheritance
      extends Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames;
      //extends Hydrodynamic.HydroDataImport.massData;
      /* This should be removed from here and included in the definition of the body in HydrodynamicBody, but is okay in the interim */
      // BodyShape parameters
      outer OET.Hydro.FilePath filePath;
      parameter Integer BodyIndex "Index of body corresponding to that of BEM (1, 2, 3, etc)" annotation(
        Dialog(group = "Hydro Data"));
      /* Removing mass definition here and adding it to a custom bodyShape model
                            parameter Modelica.Units.SI.Mass m = M + Ainf[3, 3] "Mass of the body" annotation(
                              Dialog(group = "Body")); /*
                            /* The mass is only valid when motion is constrained in heave. This line is also repeated in the PTO force code base to determine the control gain */
      parameter Modelica.Units.SI.Position r[3] = {0, 0, 0} "Position vector" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Position r_CM[3] = {0, 0, 0} "Center of mass position vector" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_11 = 0.001 "Element (1,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_22 = 0.001 "Element (2,2) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_33 = 0.001 "Element (3,3) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_21 = 0 "Element (2,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_31 = 0 "Element (3,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_32 = 0 "Element (3,2) of inertia tensor" annotation(
        Dialog(group = "Body"));
      OET.Hydro.BodyShape bodyShape(r = r, I_11 = I_11, I_22 = I_22, I_33 = I_33, I_21 = I_21, I_31 = I_31, I_32 = I_32, fileName = filePath.FileName) annotation(
        Placement(transformation(origin = {10, -84}, extent = {{-10, -10}, {10, 10}})));
      // Hydrostatic force parameters
      parameter Boolean enableHydrostaticForce = true "Switch to enable/disable hydrostatic force calculation" annotation(choices(checkBox = true),
        Dialog(group = "Hydrostatic Force Parameters"));
      // Radiation force paramters
      parameter Boolean enableRadiationForce = true "Switch to enable/disable 6D radiation force calculation" annotation(
        Dialog(group = "Radiation Force Parameters"));
      /* 
                                  parameter Real Kpx = 0.0 "Proportional gain for x-axis translation" annotation(
                                    Dialog(group = "PTO Parameters"));
                                  parameter Real Kpy = 0.0 "Proportional gain for y-axis translation" annotation(
                                    Dialog(group = "PTO Parameters"));
                                  parameter Real Kprx = 0.0 "Proportional gain for x-axis rotation" annotation(
                                    Dialog(group = "PTO Parameters"));
                                  parameter Real Kpry = 0.0 "Proportional gain for y-axis rotation" annotation(
                                    Dialog(group = "PTO Parameters"));
                                  parameter Real Kprz = 0.0 "Proportional gain for z-axis rotation" annotation(
                                    Dialog(group = "PTO Parameters"));
                                  parameter TranslationalSpringConstant Kix = 0.0 "Integral gain for x-axis translation" annotation(
                                    Dialog(group = "PTO Parameters"));
                                  parameter TranslationalSpringConstant Kiy = 0.0 "Integral gain for y-axis translation" annotation(
                                    Dialog(group = "PTO Parameters"));
                                  parameter RotationalSpringConstant Kirx = 0.0 "Integral gain for x-axis rotation" annotation(
                                    Dialog(group = "PTO Parameters"));
                                  parameter RotationalSpringConstant Kiry = 0.0 "Integral gain for y-axis rotation" annotation(
                                    Dialog(group = "PTO Parameters"));
                                  parameter RotationalSpringConstant Kirz = 0.0 "Integral gain for z-axis rotation" annotation(
                                    Dialog(group = "PTO Parameters"));
      
                               */
                               /*
    // Damping coefficients
      parameter Real Cvtx = 0.01 "Translational damping coefficient for x-axis [-]" annotation(HideResult = true);
      parameter Real Cvty = 0.01 "Translational damping coefficient for y-axis [-]" annotation(HideResult = true);
      parameter Real Cvtz = 0.01 "Translational damping coefficient for z-axis [-]" annotation(HideResult = true);
      parameter Real Cvrx = 0.01 "Rotational damping coefficient for x-axis [-]" annotation(HideResult = true);
      parameter Real Cvry = 0.01 "Rotational damping coefficient for y-axis [-]" annotation(HideResult = true);
      parameter Real Cvrz = 0.01 "Rotational damping coefficient for z-axis [-]" annotation(HideResult = true);
      
      // Drag coefficients
      parameter Real Cdtx = 0.01 "Translational drag coefficient for x-axis [-]" annotation(HideResult = true);
      parameter Real Cdty = 0.01 "Translational drag coefficient for y-axis [-]" annotation(HideResult = true);
      parameter Real Cdtz = 0.01 "Translational drag coefficient for z-axis [-]" annotation(HideResult = true);
      parameter Real Cdrx = 0.01 "Rotational drag coefficient for x-axis [-]" annotation(HideResult = true);
      parameter Real Cdry = 0.01 "Rotational drag coefficient for y-axis [-]" annotation(HideResult = true);
      parameter Real Cdrz = 0.01 "Rotational drag coefficient for z-axis [-]" annotation(HideResult = true);
      */
      Hydrostatic hydrostatic(fileName = filePath.FileName, bodyIndex=BodyIndex) annotation(
        Placement(transformation(origin = {4, 36}, extent = {{-10, -10}, {10, 10}})));
    Excitation excitation(fileName = filePath.FileName, bodyIndex=BodyIndex) annotation(
        Placement(transformation(origin = {8, -10}, extent = {{-10, -10}, {10, 10}})));
    Modelica.Mechanics.MultiBody.Sensors.AbsoluteSensor absoluteSensor(get_r = true, get_v = true, get_a = true, get_w = true, get_z = true, get_angles = true, resolveInFrame = Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world)  annotation(
        Placement(transformation(origin = {-54, 60}, extent = {{-10, -10}, {10, 10}})));
    DampingDrag dampingDrag annotation(
        Placement(transformation(origin = {74, 52}, extent = {{-10, -10}, {10, 10}})));
    Radiation radiation(fileName = filePath.FileName, bodyIndex=BodyIndex) annotation(
        Placement(transformation(origin = {48, -26}, extent = {{-10, -10}, {10, 10}})));
    equation
//Conections
      connect(excitation.frame_a, bodyShape.frame_a) annotation(
        Line(points = {{-2, -10}, {0, -10}, {0, -84}}, color = {95, 95, 95}));
    connect(hydrostatic.frame_a, bodyShape.frame_a) annotation(
        Line(points = {{-6, 36}, {-16, 36}, {-16, -84}, {0, -84}}, color = {95, 95, 95}));
    connect(bodyShape.frame_b, frame_b) annotation(
        Line(points = {{20, -84}, {62, -84}, {62, 0}, {102, 0}}, color = {95, 95, 95}));
    connect(bodyShape.frame_a, frame_a) annotation(
        Line(points = {{0, -84}, {-76, -84}, {-76, 0}, {-102, 0}}, color = {95, 95, 95}));
    connect(absoluteSensor.frame_a, frame_a) annotation(
        Line(points = {{-64, 60}, {-102, 60}, {-102, 0}}, color = {95, 95, 95}));
    connect(dampingDrag.frame_a, bodyShape.frame_a) annotation(
        Line(points = {{64, 52}, {-28, 52}, {-28, -84}, {0, -84}}, color = {95, 95, 95}));
    connect(radiation.frame_a, bodyShape.frame_a) annotation(
        Line(points = {{38, -26}, {-46, -26}, {-46, -84}, {0, -84}}, color = {95, 95, 95}));
     annotation(
        Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}}), graphics = {Text(
              extent={{-150,145},{150,105}},
              textString="%name",
              textColor={0,0,255}),Rectangle(extent = {{-100, -100}, {100, 100}}), Text(extent = {{-100, -100}, {100, 100}}, textString = "Hydro Body")}),
        Diagram);
    end HydrodynamicBody;

    model RadiationForceB2B "Radiation force and torque calculation"
     // Import hydro coefficients
      extends DataImport.radiationDataB2B;
      // Inherit frame_a
      extends Modelica.Mechanics.MultiBody.Interfaces.PartialOneFrame_a;
      // Velocity connectors
      Modelica.Blocks.Interfaces.RealInput v_abs[3] "Linear velocity vector [m/s]" annotation(HideResult = true,
        Placement(transformation(origin = {-20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {-20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
      Modelica.Blocks.Interfaces.RealInput omega_abs[3] "Angular velocity vector [rad/s]" annotation(HideResult = true,
        Placement(transformation(origin = {20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
      Real F[6] = cat(1, f_element, t_element) "Combined force and torque vector [N,Nm]";
      // Enable/disable radiation force
      parameter Boolean enableRadiationForce = true "Switch to enable/disable radiation force calculation" annotation(HideResult = true,
        Dialog(group = "Radiation Force Parameters"));
      Real velocityVector[nDoF];
    protected
      Real velocity[6] = cat(1, v_abs, omega_abs) "Combined velocity vector [m/s, rad/s]";
      Modelica.Units.SI.Force f_element[3];
      Modelica.Units.SI.Torque t_element[3];
    
      Real x[n_states] "Dummy variable state vector";
    
    initial equation
      x = zeros(n_states) "Initialize state vector to zero";
    equation
      for i in 1:bodyDoF loop
        velocityVector[bodyDoF*(bodyIndex-1) + i] = velocity[i];
      end for;
// Use the switch to conditionally output the radiation force torque element
      if enableRadiationForce then
// Radiation state space
        der(x) = A*x + B*velocityVector;
        F = C*x + D*velocityVector;
      else
        x = zeros(n_states);
        F = zeros(6);
      end if;
      frame_a.f = f_element;
      frame_a.t = t_element;
      annotation(
        Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}}), graphics = {Rectangle(extent = {{-100, -100}, {100, 100}}), Text(extent = {{-100, -100}, {100, 100}}, textString = "Radiation Force")}));
    end RadiationForceB2B;

    model HydrostaticForce "Hydrostatic Force and Torque Calculation"
      // Import hydro coefficients
      extends DataImport.hydrostaticData;
      // Inherit frame_a
      extends Modelica.Mechanics.MultiBody.Interfaces.PartialOneFrame_a;
      // Position connectors
      Modelica.Blocks.Interfaces.RealInput u_abs[3] "Linear displacement vector [m]" annotation(HideResult = true,
        Placement(visible = true, transformation(origin = {-100, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {-100, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
      Modelica.Blocks.Interfaces.RealInput theta_abs[3] "Angular displacement vector [rad]" annotation(HideResult = true,
        Placement(transformation(origin = {-60, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {-60, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
      Real F[6] = cat(1, f_element, t_element) "Combined force and torque vector [N,Nm]";
      // Enable/disable hydrostatic force
      parameter Boolean enableHydrostaticForce = true "Switch to enable/disable hydrostatic force calculation" annotation(HideResult = true,
        Dialog(group = "Hydrostatic Force Parameters"));
    protected
      Real displacement[6] = cat(1, u_abs, theta_abs) "Combined displacement vector [m, rad]";
      Modelica.Units.SI.Force f_element[3];
      Modelica.Units.SI.Torque t_element[3];
    equation
// Use the switch to conditionally output the hydrostatic force torque element
      if enableHydrostaticForce then
// Calculate the hydrostatic force/torque vector
        F = Khs*displacement;
      else
        F = zeros(6);
      end if;
      frame_a.f = f_element;
      frame_a.t = t_element;
      annotation(
        Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}}), graphics = {Rectangle(extent = {{-100, -100}, {100, 100}}), Text(extent = {{-100, -100}, {100, 100}}, textString = "Hydrostatic Force")}));
    end HydrostaticForce;

    model DampingDragForce "Drag Force and Torque Calculation"
      // Inherit frame_a
      extends Modelica.Mechanics.MultiBody.Interfaces.PartialOneFrame_a;
      // Velocity connectors
      Modelica.Blocks.Interfaces.RealInput v_abs[3] "Linear velocity vector [m/s]" annotation(HideResult = true,
        Placement(transformation(origin = {-20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {-20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
      Modelica.Blocks.Interfaces.RealInput omega_abs[3] "Angular velocity vector [rad/s]" annotation(HideResult = true,
        Placement(transformation(origin = {20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
      // Enable/disable dampingdrag force
      parameter Boolean enableDampingDragForce = true "Switch to enable/disable damping drag force calculation" annotation(HideResult = true,
        Dialog(group = "Damping Drag Force Parameters"));
      // Damping coefficients
      parameter Real Cvtx = 0.01 "Translational damping coefficient for x-axis [-]" annotation(HideResult = true);
      parameter Real Cvty = 0.01 "Translational damping coefficient for y-axis [-]" annotation(HideResult = true);
      parameter Real Cvtz = 0.01 "Translational damping coefficient for z-axis [-]" annotation(HideResult = true);
      parameter Real Cvrx = 0.01 "Rotational damping coefficient for x-axis [-]" annotation(HideResult = true);
      parameter Real Cvry = 0.01 "Rotational damping coefficient for y-axis [-]" annotation(HideResult = true);
      parameter Real Cvrz = 0.01 "Rotational damping coefficient for z-axis [-]" annotation(HideResult = true);
      parameter Real Cv[6, 6] = diagonal({Cvtx, Cvty, Cvtz, Cvrx, Cvry, Cvrz}) "Combined damping coefficient matrix";
      // Drag coefficients
      parameter Real Cdtx = 0.01 "Translational drag coefficient for x-axis [-]" annotation(HideResult = true);
      parameter Real Cdty = 0.01 "Translational drag coefficient for y-axis [-]" annotation(HideResult = true);
      parameter Real Cdtz = 0.01 "Translational drag coefficient for z-axis [-]" annotation(HideResult = true);
      parameter Real Cdrx = 0.01 "Rotational drag coefficient for x-axis [-]" annotation(HideResult = true);
      parameter Real Cdry = 0.01 "Rotational drag coefficient for y-axis [-]" annotation(HideResult = true);
      parameter Real Cdrz = 0.01 "Rotational drag coefficient for z-axis [-]" annotation(HideResult = true);
      parameter Real Cd[6, 6] = diagonal({Cdtx, Cdty, Cdtz, Cdrx, Cdry, Cdrz}) "Combined drag coefficient matrix";
      Real F[6] = cat(1, f_element, t_element) "Combined force and torque vector [N,Nm]";
    protected
      Real velocity[6] = cat(1, v_abs, omega_abs) "Combined velocity vector [m/s, rad/s]";
      Modelica.Units.SI.Force f_element[3];
      Modelica.Units.SI.Torque t_element[3];
    equation
// Use the switch to conditionally output the damping drag force and torque
      if enableDampingDragForce then
// Calculate the damping/drag force/torque vector
        F = Cv*velocity + Cd*velocity.*abs(velocity);
      else
        F = zeros(6);
      end if;
      frame_a.f = f_element;
      frame_a.t = t_element;
       annotation(
        Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}}), graphics = {Rectangle(extent = {{-100, -100}, {100, 100}}), Text(extent = {{-100, -100}, {100, 100}}, textString = "Damping/Drag Force")}));
    end DampingDragForce;

    model Excitation
  extends DataImport.excitationData;
      extends Models.physicalConstants;
      extends DataImport.physicalConstantData;
      // Simulation parameters w/ implicit connections
      outer OET.Wave.Environment environment;
      // Frame_a connector
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a "Coordinate system fixed at body" annotation(
        HideResult = true,
        Placement(transformation(extent = {{-116, -16}, {-84, 16}})));
      parameter Boolean enableExcitationForce = true "Switch to enable/disable hydrostatic force calculation" annotation(
        HideResult = true,
        Dialog(group = "Excitation Force Parameters"));
      Real ExcCoeffRe[bodyDoF, environment.n_omega] "Real component of excitation coefficient for frequency components" annotation(
        HideResult = true);
      Real ExcCoeffIm[bodyDoF, environment.n_omega] "Imaginary component of excitation coefficient for frequency components" annotation(
        HideResult = true);
      Real F[6] = cat(1, f_element, t_element) "Combined force and torque vector [N,Nm]";
    protected
      Modelica.Units.SI.Force f_element[3];
      Modelica.Units.SI.Torque t_element[3];
    equation
// Interpolate excitation coefficients (Re & Im) for each frequency component and for each DoF
      for i in 1:bodyDoF loop
        for j in 1:environment.n_omega loop
          ExcCoeffRe[i, j] = Modelica.Math.Vectors.interpolate(w, F_excRe[i, :], environment.omega[j])*rho*g;
          ExcCoeffIm[i, j] = Modelica.Math.Vectors.interpolate(w, F_excIm[i, :], environment.omega[j])*rho*g;
        end for;
      end for;
      if enableExcitationForce then
// Calculate the excitation force
        for i in 1:bodyDoF loop
// Calculate and apply ramping to the excitation force
          if time < environment.Trmp then
// Ramp up the excitation force during the initial phase
            F[i] = 0.5*(1 + cos(pi + (pi*time/environment.Trmp)))*sum((ExcCoeffRe[i].*environment.zeta.*cos(environment.omega*time - 2*pi*environment.epsilon)) - (ExcCoeffIm[i].*environment.zeta.*sin(environment.omega*time - 2*pi*environment.epsilon)));
          else
// Apply full excitation force after the ramping period
            F[i] = sum((ExcCoeffRe[i].*environment.zeta.*cos(environment.omega*time - 2*pi*environment.epsilon)) - (ExcCoeffIm[i].*environment.zeta.*sin(environment.omega*time - 2*pi*environment.epsilon)));
          end if;
        end for;
      else
        F = zeros(6);
      end if;
// Assign excitation force to output
      frame_a.f = f_element;
      frame_a.t = t_element;
      annotation(
        Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}}), graphics = {Rectangle(extent = {{-100, -100}, {100, 100}}), Text(extent = {{-100, -100}, {100, 100}}, textString = "Excitationc")}),
        Diagram);
  end Excitation;

    model FilePath
      // ideally would be a record, but has to be model to use inner
      parameter String FileName = "C:/Users/thogan1/Documents/GitHub/OET_6DoF/hydroCoeff_6DoF_multibody.mat" "File path to data structure" annotation(
        Dialog(group = "File Path"));
      annotation(
        defaultComponentName = "filePath",
        defaultComponentPrefixes = "inner",
        missingInnerMessage="No \"filepath\" component is defined. Drag the OET.Hydro.FilePath model into the top level of your model.");
    end FilePath;

    model ForceToqueSum
      extends Modelica.Blocks.Icons.Block;
      extends Connector.forceandTorque_con;
      extends Connector.forceTorqueSum_con;
      Real f[6];
    equation
      f = Fr + Fd + Fhs + Fex;
      F = f[1:3];
      T = f[4:6];
    end ForceToqueSum;

    model BodyShape "Rigid body with mass, inertia tensor, different shapes for animation, and two frame connectors (12 potential states)"
      extends DataImport.massData;
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a "Coordinate system fixed to the component with one cut-force and cut-torque" annotation(
        Placement(transformation(extent = {{-116, -16}, {-84, 16}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_b "Coordinate system fixed to the component with one cut-force and cut-torque" annotation(
        Placement(transformation(extent = {{84, -16}, {116, 16}})));
      parameter Boolean animation = true "= true, if animation shall be enabled (show shape between frame_a and frame_b and optionally a sphere at the center of mass)";
      parameter Boolean animateSphere = true "= true, if mass shall be animated as sphere provided animation=true";
      parameter Modelica.Units.SI.Position r[3](start = {0, 0, 0}) "Vector from frame_a to frame_b resolved in frame_a";
      parameter Modelica.Units.SI.Position r_CM[3](start = {0, 0, 0}) "Vector from frame_a to center of mass, resolved in frame_a";
      parameter Modelica.Units.SI.Mass m(min = 0, start = 1) = M + Ainf[3, 3] "Mass of rigid body";
      parameter Modelica.Units.SI.Inertia I_11(min = 0) = 0.001 "Element (1,1) of inertia tensor" annotation(
        Dialog(group = "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica.Units.SI.Inertia I_22(min = 0) = 0.001 "Element (2,2) of inertia tensor" annotation(
        Dialog(group = "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica.Units.SI.Inertia I_33(min = 0) = 0.001 "Element (3,3) of inertia tensor" annotation(
        Dialog(group = "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica.Units.SI.Inertia I_21(min = -10000000) = 0 "Element (2,1) of inertia tensor" annotation(
        Dialog(group = "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica.Units.SI.Inertia I_31(min = -10000000) = 0 "Element (3,1) of inertia tensor" annotation(
        Dialog(group = "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica.Units.SI.Inertia I_32(min = -10000000) = 0 "Element (3,2) of inertia tensor" annotation(
        Dialog(group = "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      Modelica.Units.SI.Position r_0[3](start = {0, 0, 0}, each stateSelect = if enforceStates then StateSelect.always else StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a" annotation(
        Dialog(tab = "Initialization", showStartAttribute = true));
      Modelica.Units.SI.Velocity v_0[3](start = {0, 0, 0}, each stateSelect = if enforceStates then StateSelect.always else StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))" annotation(
        Dialog(tab = "Initialization", showStartAttribute = true));
      Modelica.Units.SI.Acceleration a_0[3](start = {0, 0, 0}) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))" annotation(
        Dialog(tab = "Initialization", showStartAttribute = true));
      parameter Boolean angles_fixed = false "= true, if angles_start are used as initial values, else as guess values" annotation(
        Evaluate = true,
        choices(checkBox = true),
        Dialog(tab = "Initialization"));
      parameter Modelica.Units.SI.Angle angles_start[3] = {0, 0, 0} "Initial values of angles to rotate world frame around 'sequence_start' axes into frame_a" annotation(
        Dialog(tab = "Initialization"));
      parameter Modelica.Mechanics.MultiBody.Types.RotationSequence sequence_start = {1, 2, 3} "Sequence of rotations to rotate world frame into frame_a at initial time" annotation(
        Evaluate = true,
        Dialog(tab = "Initialization"));
      parameter Boolean w_0_fixed = false "= true, if w_0_start are used as initial values, else as guess values" annotation(
        Evaluate = true,
        choices(checkBox = true),
        Dialog(tab = "Initialization"));
      parameter Modelica.Units.SI.AngularVelocity w_0_start[3] = {0, 0, 0} "Initial or guess values of angular velocity of frame_a resolved in world frame" annotation(
        Dialog(tab = "Initialization"));
      parameter Boolean z_0_fixed = false "= true, if z_0_start are used as initial values, else as guess values" annotation(
        Evaluate = true,
        choices(checkBox = true),
        Dialog(tab = "Initialization"));
      parameter Modelica.Units.SI.AngularAcceleration z_0_start[3] = {0, 0, 0} "Initial values of angular acceleration z_0 = der(w_0)" annotation(
        Dialog(tab = "Initialization"));
      parameter Modelica.Mechanics.MultiBody.Types.ShapeType shapeType = "cylinder" "Type of shape" annotation(
        Dialog(tab = "Animation", group = "if animation = true", enable = animation));
      parameter Modelica.Units.SI.Position r_shape[3] = {0, 0, 0} "Vector from frame_a to shape origin, resolved in frame_a" annotation(
        Dialog(tab = "Animation", group = "if animation = true", enable = animation));
      parameter Modelica.Mechanics.MultiBody.Types.Axis lengthDirection = Modelica.Units.Conversions.to_unit1(r - r_shape) "Vector in length direction of shape, resolved in frame_a" annotation(
        Evaluate = true,
        Dialog(tab = "Animation", group = "if animation = true", enable = animation));
      parameter Modelica.Mechanics.MultiBody.Types.Axis widthDirection = {0, 1, 0} "Vector in width direction of shape, resolved in frame_a" annotation(
        Evaluate = true,
        Dialog(tab = "Animation", group = "if animation = true", enable = animation));
      parameter Modelica.Units.SI.Length length = Modelica.Math.Vectors.length(r - r_shape) "Length of shape" annotation(
        Dialog(tab = "Animation", group = "if animation = true", enable = animation));
      parameter Modelica.Units.SI.Distance width = length/world.defaultWidthFraction "Width of shape" annotation(
        Dialog(tab = "Animation", group = "if animation = true", enable = animation));
      parameter Modelica.Units.SI.Distance height = width "Height of shape" annotation(
        Dialog(tab = "Animation", group = "if animation = true", enable = animation));
      parameter Modelica.Mechanics.MultiBody.Types.ShapeExtra extra = 0.0 "Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape)" annotation(
        Dialog(tab = "Animation", group = "if animation = true", enable = animation));
      input Modelica.Mechanics.MultiBody.Types.Color color = Modelica.Mechanics.MultiBody.Types.Defaults.BodyColor "Color of shape" annotation(
        Dialog(colorSelector = true, tab = "Animation", group = "if animation = true", enable = animation));
      parameter Modelica.Units.SI.Diameter sphereDiameter = 2*width "Diameter of sphere" annotation(
        Dialog(tab = "Animation", group = "if animation = true and animateSphere = true", enable = animation and animateSphere));
      input Modelica.Mechanics.MultiBody.Types.Color sphereColor = color "Color of sphere of mass" annotation(
        Dialog(colorSelector = true, tab = "Animation", group = "if animation = true and animateSphere = true", enable = animation and animateSphere));
      input Modelica.Mechanics.MultiBody.Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)" annotation(
        Dialog(tab = "Animation", group = "if animation = true", enable = animation));
      parameter Boolean enforceStates = false "= true, if absolute variables of body object shall be used as states (StateSelect.always)" annotation(
        Evaluate = true,
        Dialog(tab = "Advanced"));
      parameter Boolean useQuaternions = true "= true, if quaternions shall be used as potential states otherwise use 3 angles as potential states" annotation(
        Evaluate = true,
        Dialog(tab = "Advanced"));
      parameter Modelica.Mechanics.MultiBody.Types.RotationSequence sequence_angleStates = {1, 2, 3} "Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states" annotation(
        Evaluate = true,
        Dialog(tab = "Advanced", enable = not useQuaternions));
      Modelica.Mechanics.MultiBody.Parts.FixedTranslation frameTranslation(r = r, animation = false) annotation(
        Placement(transformation(extent = {{-20, -20}, {20, 20}})));
      Modelica.Mechanics.MultiBody.Parts.Body body(r_CM = r_CM, m = m, I_11 = I_11, I_22 = I_22, I_33 = I_33, I_21 = I_21, I_31 = I_31, I_32 = I_32, animation = false, sequence_start = sequence_start, angles_fixed = angles_fixed, angles_start = angles_start, w_0_fixed = w_0_fixed, w_0_start = w_0_start, z_0_fixed = z_0_fixed, z_0_start = z_0_start, useQuaternions = useQuaternions, sequence_angleStates = sequence_angleStates, enforceStates = false) annotation(
        Placement(transformation(extent = {{-27.3333, -70.3333}, {13, -30}})));
    protected
      outer Modelica.Mechanics.MultiBody.World world;
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape shape1(shapeType = shapeType, color = color, specularCoefficient = specularCoefficient, length = length, width = width, height = height, lengthDirection = lengthDirection, widthDirection = widthDirection, r_shape = r_shape, extra = extra, r = frame_a.r_0, R = frame_a.R) if world.enableAnimation and animation;
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape shape2(shapeType = "sphere", color = sphereColor, specularCoefficient = specularCoefficient, length = sphereDiameter, width = sphereDiameter, height = sphereDiameter, lengthDirection = {1, 0, 0}, widthDirection = {0, 1, 0}, r_shape = r_CM - {1, 0, 0}*sphereDiameter/2, r = frame_a.r_0, R = frame_a.R) if world.enableAnimation and animation and animateSphere;
    equation
      r_0 = frame_a.r_0;
      v_0 = der(r_0);
      a_0 = der(v_0);
      connect(frame_a, frameTranslation.frame_a) annotation(
        Line(points = {{-100, 0}, {-20, 0}}, color = {95, 95, 95}, thickness = 0.5));
      connect(frame_b, frameTranslation.frame_b) annotation(
        Line(points = {{100, 0}, {20, 0}}, color = {95, 95, 95}, thickness = 0.5));
      connect(frame_a, body.frame_a) annotation(
        Line(points = {{-100, 0}, {-60, 0}, {-60, -50.1666}, {-27.3333, -50.1666}}, color = {95, 95, 95}, thickness = 0.5));
      annotation(
        Documentation(info = "<html>
        <p>
        <strong>Rigid body</strong> with mass and inertia tensor and <strong>two frame connectors</strong>.
        All parameter vectors have to be resolved in frame_a.
        The <strong>inertia tensor</strong> has to be defined with respect to a
        coordinate system that is parallel to frame_a with the
        origin at the center of mass of the body. The coordinate system <strong>frame_b</strong>
        is always parallel to <strong>frame_a</strong>.
        </p>
        <p>
        By default, this component is visualized by any <strong>shape</strong> that can be
        defined with Modelica.Mechanics.MultiBody.Visualizers.FixedShape. This shape is placed
        between frame_a and frame_b (default: length(shape) = Frames.length(r)).
        Additionally a <strong>sphere</strong> may be visualized that has
        its center at the center of mass.
        Note, that
        the animation may be switched off via parameter animation = <strong>false</strong>.
        </p>
        <p>
        <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Parts/BodyShape.png\" alt=\"Parts.BodyShape\">
        </p>
        
        <p>
        The following shapes can be defined via parameter <strong>shapeType</strong>,
        e.g., shapeType=\"cone\":
        </p>
        
        <p>
        <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/FixedShape.png\" alt=\"Visualizers.FixedShape\">
        </p>
        
        <p>
        A BodyShape component has potential states. For details of these
        states and of the \"Advanced\" menu parameters, see model
        <a href=\"modelica://Modelica.Mechanics.MultiBody.Parts.Body\">MultiBody.Parts.Body</a>.
        </p>
        </html>"),
        Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100, -100}, {100, 100}}), graphics = {Text(extent = {{-150, 110}, {150, 70}}, textString = "%name", textColor = {0, 0, 255}), Text(extent = {{-150, -100}, {150, -70}}, textString = "r=%r"), Rectangle(extent = {{-100, 30}, {101, -30}}, lineColor = {0, 24, 48}, fillPattern = FillPattern.HorizontalCylinder, fillColor = {0, 127, 255}, radius = 10), Ellipse(extent = {{-60, 60}, {60, -60}}, lineColor = {0, 24, 48}, fillPattern = FillPattern.Sphere, fillColor = {0, 127, 255}), Text(extent = {{-50, 24}, {55, -27}}, textString = "%m"), Text(extent = {{55, 12}, {91, -13}}, textString = "b"), Text(extent = {{-92, 13}, {-56, -12}}, textString = "a")}),
        Diagram(coordinateSystem(preserveAspectRatio = true, extent = {{-100, -100}, {100, 100}}), graphics = {Line(points = {{-100, 9}, {-100, 43}}, color = {128, 128, 128}), Line(points = {{100, 0}, {100, 44}}, color = {128, 128, 128}), Line(points = {{-100, 40}, {90, 40}}, color = {135, 135, 135}), Polygon(points = {{90, 44}, {90, 36}, {100, 40}, {90, 44}}, lineColor = {128, 128, 128}, fillColor = {128, 128, 128}, fillPattern = FillPattern.Solid), Text(extent = {{-22, 68}, {20, 40}}, textColor = {128, 128, 128}, textString = "r"), Line(points = {{-100, -10}, {-100, -90}}, color = {128, 128, 128}), Line(points = {{-100, -84}, {-10, -84}}, color = {128, 128, 128}), Polygon(points = {{-10, -80}, {-10, -88}, {0, -84}, {-10, -80}}, lineColor = {128, 128, 128}, fillColor = {128, 128, 128}, fillPattern = FillPattern.Solid), Text(extent = {{-82, -66}, {-56, -84}}, textColor = {128, 128, 128}, textString = "r_CM"), Line(points = {{0, -46}, {0, -90}}, color = {128, 128, 128})}));
    end BodyShape;

    model Hydrostatic
      parameter String fileName annotation(HideResult = true);
      parameter Integer bodyIndex "Index of body corresponding to that of BEM (1, 2, 3, etc)" annotation(HideResult = true,
        Dialog(group = "Hydro Data"));
      parameter Boolean enableHydrostaticForce = true "Switch to enable/disable hydrostatic force calculation" annotation(HideResult = true,
        Dialog(group = "Hydrostatic Force Parameters"));
      // Frame_a connector
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a "Coordinate system fixed at body" annotation(HideResult = true,
        Placement(transformation(extent = {{-116, -16}, {-84, 16}})));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteSensor absoluteSensor(get_r = true, get_angles = true, resolveInFrame = Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world) annotation(HideResult = true,
        Placement(transformation(origin = {1, 53}, extent = {{-15, -15}, {15, 15}}, rotation = -0)));
      HydrostaticForce hydrostaticForce(enableHydrostaticForce = enableHydrostaticForce, fileName = fileName, bodyIndex = bodyIndex) annotation(
        Placement(transformation(origin = {2, 0}, extent = {{-18, -18}, {18, 18}})));
    equation
      connect(absoluteSensor.frame_a, frame_a) annotation(
        Line(points = {{-14, 54}, {-100, 54}, {-100, 0}}, color = {95, 95, 95}));
      connect(absoluteSensor.r, hydrostaticForce.u_abs) annotation(
        Line(points = {{-14, 36}, {-16, 36}, {-16, 21}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.angles, hydrostaticForce.theta_abs) annotation(
        Line(points = {{4, 36}, {-9, 36}, {-9, 21}}, color = {0, 0, 127}, thickness = 0.5));
      connect(hydrostaticForce.frame_a, frame_a) annotation(
        Line(points = {{-16, 0}, {-100, 0}}, color = {95, 95, 95}));
      annotation(
        Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}}), graphics = {Rectangle(extent = {{-100, -100}, {100, 100}}), Text(extent = {{-100, -100}, {100, 100}}, textString = "Hydrostatic")}),
        Diagram);
    end Hydrostatic;

    model DampingDrag
      //parameter String filePath; // dont need as is
      //parameter Integer bodyIndex "Index of body corresponding to that of BEM (1, 2, 3, etc)" annotation(
      //Dialog(group = "Hydro Data"));
      parameter Boolean enableDampingDragForce = true "Switch to enable/disable damping/drag force calculation" annotation(
        Dialog(group = "Damping/Drag Force Parameters"));
      // Frame_a connector
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a "Coordinate system fixed at body" annotation(HideResult = true,
        Placement(transformation(extent = {{-116, -16}, {-84, 16}})));
      DampingDragForce dampingDragForce(enableDampingDragForce = enableDampingDragForce) annotation(
        Placement(transformation(origin = {1, -1}, extent = {{-13, -13}, {13, 13}})));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteSensor absoluteSensor(get_v = true, get_w = true, resolveInFrame = Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world) annotation(HideResult = true,
        Placement(transformation(origin = {0, 64}, extent = {{-12, -12}, {12, 12}})));
    equation
      connect(absoluteSensor.frame_a, frame_a) annotation(
        Line(points = {{-12, 64}, {-100, 64}, {-100, 0}}, color = {95, 95, 95}));
      connect(absoluteSensor.v, dampingDragForce.v_abs) annotation(
        Line(points = {{-8, 50}, {-2, 50}, {-2, 14}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.w, dampingDragForce.omega_abs) annotation(
        Line(points = {{8, 50}, {4, 50}, {4, 14}}, color = {0, 0, 127}, thickness = 0.5));
      connect(dampingDragForce.frame_a, frame_a) annotation(
        Line(points = {{-12, 0}, {-100, 0}}, color = {95, 95, 95}));
      annotation(
        Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}}), graphics = {Rectangle(extent = {{-100, -100}, {100, 100}}), Text(extent = {{-100, -100}, {100, 100}}, textString = "Damping/Drag")}),
        Diagram);
    
    end DampingDrag;
    
  model RadiationForce "Radiation force and torque calculation"
    // Import hydro coefficients
    extends DataImport.radiationData;
    // Inherit frame_a
    extends Modelica.Mechanics.MultiBody.Interfaces.PartialOneFrame_a;
    // Velocity connectors
    Modelica.Blocks.Interfaces.RealInput v_abs[3] "Linear velocity vector [m/s]" annotation(HideResult = true,
      Placement(transformation(origin = {-20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {-20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
    Modelica.Blocks.Interfaces.RealInput omega_abs[3] "Angular velocity vector [rad/s]" annotation(HideResult = true,
      Placement(transformation(origin = {20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
    Real F[6] = cat(1, f_element, t_element) "Combined force and torque vector [N,Nm]";
    // Enable/disable radiation force
    parameter Boolean enableRadiationForce = true "Switch to enable/disable radiation force calculation" annotation(HideResult = true,
      Dialog(group = "Radiation Force Parameters"));
  
  protected
    Real velocity[6] = cat(1, v_abs, omega_abs) "Combined velocity vector [m/s, rad/s]";
    Modelica.Units.SI.Force f_element[3];
    Modelica.Units.SI.Torque t_element[3];
    Real x[n_states_Uncoupled] "Dummy variable state vector";
    //Real velocityDummy[bodyDoF] = velocity;
  initial equation
    x = zeros(n_states_Uncoupled) "Initialize state vector to zero";
  equation
  // Use the switch to conditionally output the hydrostatic force torque element
if enableRadiationForce then
// Calculate the hydrostatic force/torque vector
      der(x) = A*x + B*velocity;
//der(x) = B*velocityDummy;
      F = C*x + D*velocity;
    else
      x = zeros(n_states_Uncoupled);
      F = zeros(6);
    end if;
    frame_a.f = f_element;
    frame_a.t = t_element;
    annotation(
      Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}}), graphics = {Rectangle(extent = {{-100, -100}, {100, 100}}), Text(extent = {{-100, -100}, {100, 100}}, textString = "Radiation Force")}));
   
  end RadiationForce;
  
  model Radiation
  
    parameter String fileName annotation(HideResult = true);
    parameter Integer bodyIndex "Index of body corresponding to that of BEM (1, 2, 3, etc)" annotation(HideResult = true,
      Dialog(group = "Hydro Data"));
    parameter Boolean enableRadiationForce = true "Switch to enable/disable radiation force calculation" annotation(HideResult = true,
      Dialog(group = "Radiation Force Parameters"));
    // Frame_a connector
    Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a "Coordinate system fixed at body" annotation(HideResult = true,
      Placement(transformation(extent = {{-116, -16}, {-84, 16}})));
    Modelica.Mechanics.MultiBody.Sensors.AbsoluteSensor absoluteSensor(get_v = true, get_w = true, resolveInFrame = Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world) annotation(HideResult = true,
      Placement(transformation(origin = {1, 53}, extent = {{-15, -15}, {15, 15}}, rotation = -0)));
    RadiationForce radiationForce(enableRadiationForce = enableRadiationForce, fileName = fileName, bodyIndex = bodyIndex) annotation(
      Placement(transformation(origin = {2, 0}, extent = {{-18, -18}, {18, 18}})));
  equation
    connect(absoluteSensor.frame_a, frame_a) annotation(
      Line(points = {{-14, 54}, {-100, 54}, {-100, 0}}, color = {95, 95, 95}));
    connect(absoluteSensor.v, radiationForce.v_abs) annotation(
      Line(points = {{-14, 36}, {-16, 36}, {-16, 21}}, color = {0, 0, 127}, thickness = 0.5));
    connect(absoluteSensor.w, radiationForce.omega_abs) annotation(
      Line(points = {{4, 36}, {-9, 36}, {-9, 21}}, color = {0, 0, 127}, thickness = 0.5));
    connect(radiationForce.frame_a, frame_a) annotation(
      Line(points = {{-16, 0}, {-100, 0}}, color = {95, 95, 95}));
    annotation(
      Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}}), graphics = {Rectangle(extent = {{-100, -100}, {100, 100}}), Text(extent = {{-100, -100}, {100, 100}}, textString = "Radiation")}),
      Diagram);
  
  end Radiation;

    model CouplingB2B
    
      extends OET.DataImport.multibodyData;
      
      outer OET.Hydro.FilePath filePath;
      Real velocityCoupled[12] "Vector containing velocities of all hydrodynamic bodies";
    
      redeclare parameter String fileName = filePath.FileName;
    
  annotation(
        defaultComponentName = "coupledB2B",
        defaultComponentPrefixes = "inner",
        missingInnerMessage="No \"coupledB2B\" component is defined. Drag the OET.Hydro.CoupledB2B model into the top level of your model.");
    end CouplingB2B;
    
    model RadiationB2B
    
      
      parameter String fileName annotation(HideResult = true);
      parameter Integer bodyIndex "Index of body corresponding to that of BEM (1, 2, 3, etc)" annotation(HideResult = true,
        Dialog(group = "Hydro Data"));
      Real velocityVector[12]; //will need to generalize
      parameter Boolean enableRadiationForce = true "Switch to enable/disable radiation force calculation" annotation(HideResult = true,
        Dialog(group = "Radiation Force Parameters"));
      // Frame_a connector
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a "Coordinate system fixed at body" annotation(HideResult = true,
        Placement(transformation(extent = {{-116, -16}, {-84, 16}})));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteSensor absoluteSensor(get_v = true, get_w = true, resolveInFrame = Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world) annotation(HideResult = true,
        Placement(transformation(origin = {1, 53}, extent = {{-15, -15}, {15, 15}}, rotation = -0)));
      RadiationForceB2B radiationForce(enableRadiationForce = enableRadiationForce, fileName = fileName, bodyIndex = bodyIndex, velocityVector = velocityVector) annotation(
        Placement(transformation(origin = {2, 0}, extent = {{-18, -18}, {18, 18}})));
    equation
      connect(absoluteSensor.frame_a, frame_a) annotation(
        Line(points = {{-14, 54}, {-100, 54}, {-100, 0}}, color = {95, 95, 95}));
      connect(absoluteSensor.v, radiationForce.v_abs) annotation(
        Line(points = {{-14, 36}, {-16, 36}, {-16, 21}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.w, radiationForce.omega_abs) annotation(
        Line(points = {{4, 36}, {-9, 36}, {-9, 21}}, color = {0, 0, 127}, thickness = 0.5));
      connect(radiationForce.frame_a, frame_a) annotation(
        Line(points = {{-16, 0}, {-100, 0}}, color = {95, 95, 95}));
      annotation(
        Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}}), graphics = {Rectangle(extent = {{-100, -100}, {100, 100}}), Text(extent = {{-100, -100}, {100, 100}}, textString = "Radiation")}),
        Diagram);
    
    end RadiationB2B;
    
    model HydrodynamicBodyB2B "6-Dimensional Hydrodynamic Forces and Moments Calculation"
      // Inheritance
      extends Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames;
      //extends Hydrodynamic.HydroDataImport.massData;
      /* This should be removed from here and included in the definition of the body in HydrodynamicBody, but is okay in the interim */
      // BodyShape parameters
      outer Hydro.FilePath filePath;
      outer Hydro.CouplingB2B couplingB2B;
      parameter Integer BodyIndex "Index of body corresponding to that of BEM (1, 2, 3, etc)" annotation(
        Dialog(group = "Hydro Data"));
      /* Removing mass definition here and adding it to a custom bodyShape model
                                  parameter Modelica.Units.SI.Mass m = M + Ainf[3, 3] "Mass of the body" annotation(
                                    Dialog(group = "Body")); /*
                                  /* The mass is only valid when motion is constrained in heave. This line is also repeated in the PTO force code base to determine the control gain */
      parameter Modelica.Units.SI.Position r[3] = {0, 0, 0} "Position vector" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Position r_CM[3] = {0, 0, 0} "Center of mass position vector" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_11 = 0.001 "Element (1,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_22 = 0.001 "Element (2,2) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_33 = 0.001 "Element (3,3) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_21 = 0 "Element (2,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_31 = 0 "Element (3,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_32 = 0 "Element (3,2) of inertia tensor" annotation(
        Dialog(group = "Body"));
      Hydro.BodyShape bodyShape(r = r, I_11 = I_11, I_22 = I_22, I_33 = I_33, I_21 = I_21, I_31 = I_31, I_32 = I_32, fileName = filePath.FileName) annotation(
        Placement(transformation(origin = {10, -84}, extent = {{-10, -10}, {10, 10}})));
      // Hydrostatic force parameters
      parameter Boolean enableHydrostaticForce = true "Switch to enable/disable hydrostatic force calculation" annotation(
        choices(checkBox = true),
        Dialog(group = "Hydrostatic Force Parameters"));
      // Radiation force paramters
      parameter Boolean enableRadiationForce = true "Switch to enable/disable 6D radiation force calculation" annotation(
        Dialog(group = "Radiation Force Parameters"));
      /* 
                                        parameter Real Kpx = 0.0 "Proportional gain for x-axis translation" annotation(
                                          Dialog(group = "PTO Parameters"));
                                        parameter Real Kpy = 0.0 "Proportional gain for y-axis translation" annotation(
                                          Dialog(group = "PTO Parameters"));
                                        parameter Real Kprx = 0.0 "Proportional gain for x-axis rotation" annotation(
                                          Dialog(group = "PTO Parameters"));
                                        parameter Real Kpry = 0.0 "Proportional gain for y-axis rotation" annotation(
                                          Dialog(group = "PTO Parameters"));
                                        parameter Real Kprz = 0.0 "Proportional gain for z-axis rotation" annotation(
                                          Dialog(group = "PTO Parameters"));
                                        parameter TranslationalSpringConstant Kix = 0.0 "Integral gain for x-axis translation" annotation(
                                          Dialog(group = "PTO Parameters"));
                                        parameter TranslationalSpringConstant Kiy = 0.0 "Integral gain for y-axis translation" annotation(
                                          Dialog(group = "PTO Parameters"));
                                        parameter RotationalSpringConstant Kirx = 0.0 "Integral gain for x-axis rotation" annotation(
                                          Dialog(group = "PTO Parameters"));
                                        parameter RotationalSpringConstant Kiry = 0.0 "Integral gain for y-axis rotation" annotation(
                                          Dialog(group = "PTO Parameters"));
                                        parameter RotationalSpringConstant Kirz = 0.0 "Integral gain for z-axis rotation" annotation(
                                          Dialog(group = "PTO Parameters"));
            
                                     */
      /*
          // Damping coefficients
            parameter Real Cvtx = 0.01 "Translational damping coefficient for x-axis [-]" annotation(HideResult = true);
            parameter Real Cvty = 0.01 "Translational damping coefficient for y-axis [-]" annotation(HideResult = true);
            parameter Real Cvtz = 0.01 "Translational damping coefficient for z-axis [-]" annotation(HideResult = true);
            parameter Real Cvrx = 0.01 "Rotational damping coefficient for x-axis [-]" annotation(HideResult = true);
            parameter Real Cvry = 0.01 "Rotational damping coefficient for y-axis [-]" annotation(HideResult = true);
            parameter Real Cvrz = 0.01 "Rotational damping coefficient for z-axis [-]" annotation(HideResult = true);
            
            // Drag coefficients
            parameter Real Cdtx = 0.01 "Translational drag coefficient for x-axis [-]" annotation(HideResult = true);
            parameter Real Cdty = 0.01 "Translational drag coefficient for y-axis [-]" annotation(HideResult = true);
            parameter Real Cdtz = 0.01 "Translational drag coefficient for z-axis [-]" annotation(HideResult = true);
            parameter Real Cdrx = 0.01 "Rotational drag coefficient for x-axis [-]" annotation(HideResult = true);
            parameter Real Cdry = 0.01 "Rotational drag coefficient for y-axis [-]" annotation(HideResult = true);
            parameter Real Cdrz = 0.01 "Rotational drag coefficient for z-axis [-]" annotation(HideResult = true);
            */
      Hydrostatic hydrostatic(fileName = filePath.FileName, bodyIndex = BodyIndex) annotation(
        Placement(transformation(origin = {4, 36}, extent = {{-10, -10}, {10, 10}})));
      Excitation excitation(fileName = filePath.FileName, bodyIndex = BodyIndex) annotation(
        Placement(transformation(origin = {8, -10}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteSensor absoluteSensor(get_r = true, get_v = true, get_a = true, get_w = true, get_z = true, get_angles = true, resolveInFrame = Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world) annotation(
        Placement(transformation(origin = {-54, 60}, extent = {{-10, -10}, {10, 10}})));
      DampingDrag dampingDrag annotation(
        Placement(transformation(origin = {74, 52}, extent = {{-10, -10}, {10, 10}})));
      RadiationB2B radiation(fileName = filePath.FileName, bodyIndex = BodyIndex,velocityVector = couplingB2B.velocityCoupled) annotation(
        Placement(transformation(origin = {48, -26}, extent = {{-10, -10}, {10, 10}})));
    equation
//Conections
      connect(excitation.frame_a, bodyShape.frame_a) annotation(
        Line(points = {{-2, -10}, {0, -10}, {0, -84}}, color = {95, 95, 95}));
      connect(hydrostatic.frame_a, bodyShape.frame_a) annotation(
        Line(points = {{-6, 36}, {-16, 36}, {-16, -84}, {0, -84}}, color = {95, 95, 95}));
      connect(bodyShape.frame_b, frame_b) annotation(
        Line(points = {{20, -84}, {62, -84}, {62, 0}, {102, 0}}, color = {95, 95, 95}));
      connect(bodyShape.frame_a, frame_a) annotation(
        Line(points = {{0, -84}, {-76, -84}, {-76, 0}, {-102, 0}}, color = {95, 95, 95}));
      connect(absoluteSensor.frame_a, frame_a) annotation(
        Line(points = {{-64, 60}, {-102, 60}, {-102, 0}}, color = {95, 95, 95}));
      connect(dampingDrag.frame_a, bodyShape.frame_a) annotation(
        Line(points = {{64, 52}, {-28, 52}, {-28, -84}, {0, -84}}, color = {95, 95, 95}));
      connect(radiation.frame_a, bodyShape.frame_a) annotation(
        Line(points = {{38, -26}, {-46, -26}, {-46, -84}, {0, -84}}, color = {95, 95, 95}));
      annotation(
        Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}}), graphics = {Text(
              extent={{-150,145},{150,105}},
              textString="%name",
              textColor={0,0,255}),Rectangle(extent = {{-100, -100}, {100, 100}}), Text(extent = {{-100, -100}, {100, 100}}, textString = "Hydro Body")}),
        Diagram);
    end HydrodynamicBodyB2B;
  end Hydro;

  package Wave
    partial model waveParameters "Top-level wave parameter class"
      // Inheritance
      //extends DataImport.physicalConstantData; // can remove
      //extends DataImport.excitationData; // can remove
      //extends Models.forceTorque; // can remove
      extends DataImport.waveData;
      extends DataImport.frequencyData;
      // need to add
      extends Models.physicalConstants;
      // Wave selection
      parameter String waveSelector = "PiersonMoskowitz" annotation(
        Dialog(group = "Wave Spectrum Parameters"),
        choices(choice = "Linear", choice = "Bretschneider", choice = "PiersonMoskowitz", choice = "JONSWAP"));
      parameter Integer n_omega = 1 "Number of frequency components (default is 100 for irregular)" annotation(
        Dialog(group = "Simulation Parameters", enable = waveSelector <> "Linear"));
      parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
        Dialog(group = "Wave Spectrum Parameters"));
      parameter Modelica.Units.SI.AngularFrequency omega_peak = 0.9423 "Peak spectral frequency [rad/s]" annotation(
        Dialog(group = "Wave Spectrum Parameters"));
      Modelica.Units.SI.AngularFrequency omega[n_omega] "Frequency components selected for simulation [rad/s]";
      /*
                              parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
                                Dialog(group = "Wave Spectrum Parameters")); // Removing because now reading
                                */
      parameter Modelica.Units.SI.Time Trmp = 200 "Interval for ramping up of waves during start phase [s]" annotation(
        Dialog(group = "Simulation Parameters"));
      Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
      Modelica.Units.SI.Length zeta[n_omega] "Wave amplitude component [m]";
      parameter Real epsilon[n_omega] = Wave.WaveFunctions.RandomFrequencyFunctions.randomNumberGen(localSeed1, globalSeed1, n_omega) "Wave components phase shift";
    protected
      // Derived parameters
      parameter Integer localSeed1 = 614757 "Local random seed for phase shifts" annotation(HideResult = true,
        Dialog(group = "Random Frequency Selection"));
      // readd , enable = frequencySelection == "random"
      parameter Integer globalSeed1 = 40020 "Global random seed for phase shifts" annotation(HideResult = true,
        Dialog(group = "Random Frequency Selection"));
      // readd , enable = frequencySelection == "random"
      Modelica.Units.SI.Time Tp[n_omega] "Wave period components [s]" annotation(HideResult = true);
      Modelica.Units.SI.WaveNumber k[n_omega] "Wave number component [1/m]";
      //Real F_exc[nDoF] "6D excitation force [N]";
    equation
// Calculate wave parameters
      Tp = 2*pi./omega;
      k = Wave.WaveFunctions.WaveParameterFunctions.waveNumber(d, omega);
// Calculate sea surface elevation (SSE) as the sum of all wave components
      SSE = sum(zeta.*cos(omega*time - 2*pi*epsilon));
      annotation(
        Documentation(info = "<html>
              <p>This model implements the linear Airy wave theory to calculate wave elevation profiles and associated excitation forces.</p>
              <p>Key features:</p>
              <ul>
                <li>Calculates sea surface elevation (SSE) based on wave parameters</li>
                <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
                <li>Applies a ramping function to the excitation force during the initial phase</li>
                <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
              </ul>
              <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            </html>"),
        Diagram(coordinateSystem(extent = {{100, 20}, {120, -20}})));
    end waveParameters;

    package RegularWave
      /* Package for regular wave elevation profile and excitation force calculations */

      model LinearWave "Implementation of linear Airy wave model"
        // Inherit from waveParameters class, modifying the number of frequency components
        extends OET.Wave.waveParameters(n_omega = 1, epsilon = fill(0, n_omega));
      equation
// Calculate wave amplityde
        zeta[n_omega] = Hs/2 "Wave amplitude [m]";
// Assign peak amplitude to the scalar frequency
        omega[n_omega] = omega_peak;
        annotation(
          Documentation(info = "<html>
            <p>This model implements the linear Airy wave theory to calculate wave elevation profiles and associated excitation forces.</p>
            <p>Key features:</p>
            <ul>
              <li>Calculates sea surface elevation (SSE) based on wave parameters</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
          </html>"),
          Icon(graphics = {Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = "Linear Wave", fontName = "Arial")}),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end LinearWave;
      annotation(
        Documentation(info = "<html>
          <p>This package contains models for generating regular wave profiles and calculating associated excitation forces.</p>
          <p>The package currently includes:</p>
          <ul>
            <li>LinearWave: A model implementing the linear Airy wave theory</li>
          </ul>
        </html>"),
        Icon(graphics = {Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-90, -70}, {90, -90}}, lineColor = {0, 0, 255}, fillColor = {0, 0, 255}, fillPattern = FillPattern.Solid, textString = "Regular Wave")}));
    end RegularWave;

    package WaveFunctions
      package EqualEnergyFrequencyFunctions
        function equalEnergyFrequencySelector
          // Can lead to errors if n_omega and n_omega_int are not selected properly, need to make more rubust
          input Real omega_min "Minimum frequency [rad/s]";
          input Real omega_max "Maximum frequency [rad/s]";
          parameter input Integer n_omega "Number of frequency compenents defining the spectrum";
          parameter input Integer n_omega_int "Number of steps for integrating the spectrum";
          input Real omega_int[n_omega_int] "Integration frquencies";
          input Real S_int[n_omega_int] "Energy Spectrum";
          output Real omega[n_omega] "Output vector of selected frequency components [rad/s]";
          output Real S[n_omega];
          //output Real Cum_energy[n_omega_int] "Vector of cumulative spectrum interval areas";
          //output Real eng_check[n_omega];
          //output Real energy_sum;
          //output Real mean_energy;
          //output Real new_energy;
        protected
          Real domega = (omega_max - omega_min)/(n_omega_int - 1) "Omega int frequency step";
          Real Cum_energy[n_omega_int] "Vector of cumulative spectrum interval areas";
          Real tot_energy "Total energy in the spectrum";
          Real energy "Element to iterate current area off of";
          //Real mean_energy;
          Real tolerance "Tolerance for area";
          //Real current_energy_diff, next_energy_diff;
          //Integer k = 1;
          Real mean_energy;
          Real new_energy;
        algorithm
//energy_sum := 0;
          new_energy := 0;
          Cum_energy[1] := 0;
          omega[1] := omega_min;
          omega[n_omega] := omega_max;
          S[1] := S_int[1];
          S[n_omega] := S_int[n_omega_int];
          for i in 2:n_omega_int loop
            energy := OET.Wave.WaveFunctions.SpectrumFunctions.Calculations.trapezoidalIntegration(S_int[i - 1], S_int[i], domega);
            Cum_energy[i] := Cum_energy[i - 1] + energy;
          end for;
          tot_energy := Cum_energy[end];
          mean_energy := tot_energy/(n_omega - 1);
// need to re add n_omega - 1
          tolerance := mean_energy/5;
          for i in 2:(n_omega - 1) loop
// This is really sensitive to integration step size, need to make more robust
/* for j in k:(n_omega_int-1) loop
                current_energy_diff := abs(Cum_energy[j] - Cum_energy[k] - mean_energy);
                next_energy_diff := abs(Cum_energy[j+1] - Cum_energy[k] - mean_energy);
              
                if  Cum_energy[j] - Cum_energy[k] >= mean_energy or current_energy_diff <= tolerance then 
                  omega[i] := omega_int[j];
                  S[i] := S_int[j];
                  eng_check[i] := Cum_energy[j] - Cum_energy[k];
                  energy_sum := energy_sum + eng_check[i];
                  k := j;
                  break;
                end if;
                
              end for; */
//for j in k:(n_omega_int-1) loop
            new_energy := new_energy + mean_energy;
            omega[i] := Modelica.Math.Vectors.interpolate(Cum_energy, omega_int, new_energy);
            S[i] := Modelica.Math.Vectors.interpolate(omega_int, S_int, omega[i]);
//end for; */
          end for;
        end equalEnergyFrequencySelector;
      end EqualEnergyFrequencyFunctions;

      package RandomFrequencyFunctions
        function randomNumberGen "Function to generate random numbers using XOR shift algorithm"
          /* Produces a vector of random numbers based on local and global seeds
                                                                                                     This function utilizes the Xorshift64star algorithm for efficient random number generation */
          input Integer ls "Local seed for random number generation";
          input Integer gs "Global seed for random number generation";
          constant input Integer n "Number of random numbers to generate";
          output Real r64[n] "Vector of generated random numbers";
        protected
          Integer state64[2](each start = 0, each fixed = true) "State vector for XOR shift algorithm";
        algorithm
          if n > 1 then
            state64[1] := 0;
            state64[2] := 0;
            for i in 1:n loop
              if i == 1 then
                state64 := Modelica.Math.Random.Generators.Xorshift64star.initialState(ls, gs);
                r64[i] := 0;
              else
                (r64[i], state64) := Modelica.Math.Random.Generators.Xorshift64star.random((state64));
              end if;
            end for;
          else
            r64 := zeros(n);
          end if;
          annotation(
            Documentation(info = "<html>
            <p>Syntax: r64 = randomNumberGen(ls, gs, n)</p>
            <p>Description: This function generates a vector of random numbers using the Xorshift64star algorithm, which is known for its efficiency and good statistical properties.</p>
            <p>Inputs:</p>
            <ul>
              <li><code>ls</code>: Local seed for random number generation (default: 614657)</li>
              <li><code>gs</code>: Global seed for random number generation (default: 30020)</li>
              <li><code>n</code>: Number of random numbers to generate (default: 100)</li>
            </ul>
            <p>Outputs:</p>
            <ul>
              <li><code>r64</code>: Vector of generated random numbers</li>
            </ul>
            <p>Algorithm: The function uses the Xorshift64star algorithm to generate random numbers based on the provided seeds.</p>
          </html>"),
            Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "RNG", textStyle = {TextStyle.Bold})}));
        end randomNumberGen;

        function randomFrequencySelector "Function to randomly select frequency components within a specified range"
          /* Uses a random phase vector to perturb frequencies
                                                                                                     This function ensures a good distribution of frequencies for irregular wave generation */
          parameter input Real omega_min "Minimum frequency [rad/s]";
          parameter input Real omega_max "Maximum frequency [rad/s]";
          parameter input Real epsilon[:] "Random phase vector for frequency perturbation";
          parameter input Integer n_omega "Number of frequency components";
          output Real omega[n_omega] "Output vector of selected frequency components [rad/s]";
        protected
          parameter Real ref_omega[n_omega] = omega_min:(omega_max - omega_min)/(n_omega - 1):omega_max "Reference frequency vector [rad/s]";
          // need ti re add -1 afrom size, but likely small diff
        algorithm
          omega[1] := omega_min;
          for i in 2:n_omega - 1 loop
            omega[i] := ref_omega[i] + epsilon[i]*omega_min;
          end for;
          omega[n_omega] := omega_max;
          annotation(
            Documentation(info = "<html>
            <p>Syntax: omega = frequencySelector(omega_min, omega_max, epsilon)</p>
            <p>Description: This function selects frequency components within a specified range, using a random phase vector to perturb the frequencies. This ensures a good distribution of frequencies for irregular wave generation.</p>
            <p>Inputs:</p>
            <ul>
              <li><code>omega_min</code>: Minimum frequency [rad/s]</li>
              <li><code>omega_max</code>: Maximum frequency [rad/s]</li>
              <li><code>epsilon</code>: Random phase vector for frequency perturbation</li>
            </ul>
            <p>Outputs:</p>
            <ul>
              <li><code>omega</code>: Output vector of selected frequency components [rad/s]</li>
            </ul>
            <p>Algorithm: The function creates a reference frequency vector and then perturbs it using the random phase vector, ensuring the first and last frequencies are exactly omega_min and omega_max.</p>
          </html>"),
            Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "()", textStyle = {TextStyle.Bold})}));
        end randomFrequencySelector;
      end RandomFrequencyFunctions;

      package SpectrumFunctions
        function spectrumGenerator_PiersonMoskowitz "Function to generate Pierson-Moskowitz spectrum"
          /* Calculates spectral values for given frequencies based on significant wave height
                                                                                                     This function implements the Pierson-Moskowitz spectrum, suitable for fully developed seas */
          extends OET.Wave.WaveFunctions.SpectrumFunctions.spectrumIO(omega_peak = 0);
        algorithm
          for i in 1:n_omega loop
            S[i] := 0.0081*g^2/omega[i]^5*exp(-0.0358*(g/(Hs*omega[i]^2))^2);
          end for;
          annotation(
            Documentation(info = "<html>
            <p>Syntax: spec = spectrumGenerator_PM(Hs, omega)</p>
            <p>Description: This function generates the Pierson-Moskowitz spectrum, which is suitable for fully developed seas. It calculates spectral values for given frequencies based on the significant wave height.</p>
            <p>Inputs:</p>
            <ul>
              <li><code>Hs</code>: Significant wave height [m] (default: 1)</li>
              <li><code>omega</code>: Array of frequency components [rad/s]</li>
            </ul>
            <p>Outputs:</p>
            <ul>
              <li><code>spec</code>: Array of spectral values for input frequencies [m^2s]</li>
            </ul>
            <p>Algorithm: The function calculates spectral values using the Pierson-Moskowitz formula: S() = 0.0081*g^2/^5 * exp(-0.0358*(g/(Hs*^2))^2)</p>
          </html>"),
            Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "PM", textStyle = {TextStyle.Bold})}));
        end spectrumGenerator_PiersonMoskowitz;

        function spectrumGenerator_Bretschneider "Function to generate Bretschneider spectrum"
          /* Calculates spectral values based on significant wave height and peak frequency
                                                                                                     This function implements the Bretschneider spectrum, a two-parameter spectrum for fetch-limited seas */
          extends OET.Wave.WaveFunctions.SpectrumFunctions.spectrumIO;
        algorithm
          for i in 1:n_omega loop
            S[i] := 1.9635*Hs^2*omega_peak^4/omega[i]^5*exp(-1.25*((omega_peak/omega[i])^4));
          end for;
          annotation(
            Documentation(info = "<html>
            <p>Syntax: spec = spectrumGenerator_BRT(Hs, omega, omega_peak)</p>
            <p>Description: This function generates the Bretschneider spectrum, which is a two-parameter spectrum suitable for fetch-limited seas. It calculates spectral values based on significant wave height and peak frequency.</p>
            <p>Inputs:</p>
            <ul>
              <li><code>Hs</code>: Significant wave height [m] (default: 1)</li>
              <li><code>omega</code>: Array of frequency components [rad/s]</li>
              <li><code>omega_peak</code>: Peak spectral frequency [rad/s] (default: 0.9423)</li>
            </ul>
            <p>Outputs:</p>
            <ul>
              <li><code>spec</code>: Array of spectral values for input frequencies [m^2s]</li>
            </ul>
            <p>Algorithm: The function calculates spectral values using the Bretschneider formula: S() = 1.9635*Hs^2*_peak^4/^5 * exp(-1.25*((_peak/)^4))</p>
          </html>"),
            Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "BRT", textStyle = {TextStyle.Bold})}));
        end spectrumGenerator_Bretschneider;

        function spectrumGenerator_JONSWAP "Function to generate JONSWAP (Joint North Sea Wave Project) spectrum"
          /* Calculates spectral values based on significant wave height, peak frequency, and spectral width parameters
                                                                                                     This function implements the JONSWAP spectrum, suitable for developing seas with fetch limitations */
          extends OET.Wave.WaveFunctions.SpectrumFunctions.spectrumIO;
          input Real spectralWidth_min "Minimum spectral width parameter";
          input Real spectralWidth_max "Maximum spectral width parameter";
        protected
          constant Real gamma = 3.3 "Peak enhancement factor for JONSWAP spectrum";
          Real sigma "Spectral width parameter";
          Real b "Exponent for peak enhancement factor";
        algorithm
          for i in 1:n_omega loop
            if omega[i] > omega_peak then
              sigma := spectralWidth_max;
            else
              sigma := spectralWidth_min;
            end if;
            b := exp(-0.5*(((omega[i] - omega_peak)/(sigma*omega_peak))^2));
            S[i] := 0.0081*g^2/omega[i]^5*exp(-1.25*((omega_peak/omega[i])^4))*gamma^b;
          end for;
          annotation(
            Documentation(info = "<html>
            <p>Syntax: spec = spectrumGenerator_JONSWAP(Hs, omega, omega_peak, spectralWidth_min, spectralWidth_max)</p>
            <p>Description: This function generates the JONSWAP (Joint North Sea Wave Project) spectrum, which is suitable for developing seas with fetch limitations. It calculates spectral values based on significant wave height, peak frequency, and spectral width parameters.</p>
            <p>Inputs:</p>
            <ul>
              <li><code>Hs</code>: Significant wave height [m] (default: 1)</li>
              <li><code>omega</code>: Array of frequency components [rad/s]</li>
              <li><code>omega_peak</code>: Peak spectral frequency [rad/s] (default: 0.9423)</li>
              <li><code>spectralWidth_min</code>: Minimum spectral width parameter</li>
              <li><code>spectralWidth_max</code>: Maximum spectral width parameter</li>
            </ul>
            <p>Outputs:</p>
            <ul>
              <li><code>spec</code>: Array of spectral values for input frequencies [m^2s]</li>
            </ul>
            <p>Algorithm: The function calculates spectral values using the JONSWAP formula, which is an extension of the Pierson-Moskowitz spectrum with additional parameters to account for fetch-limited seas.</p>
          </html>"),
            Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "JONSWAP", textStyle = {TextStyle.Bold})}));
        end spectrumGenerator_JONSWAP;

        package Calculations
          function frequencyStepGen
            input Real omega[n_omega];
            constant input Integer n_omega;
            output Real domega = (omega[end] - omega[1])/(n_omega - 1) "Frequency step size";
          end frequencyStepGen;

          function integrationFrequencyGen
            input Real omega_min "Minimum frequency [rad/s]";
            input Real omega_max "Maximum frequency [rad/s]";
            constant input Integer n_omega_int "Number of frequency compenents defining the spectrum";
            output Real omega_int[n_omega_int];
            // = omega_min:domega_int:omega_max "Frequencies for spectrum generation and integration";
          protected
            Real domega_int = (omega_max - omega_min)/(n_omega_int - 1) "Frequency step size";
          algorithm
            for i in 1:n_omega_int loop
              omega_int[i] := omega_min + (i - 1)*(omega_max - omega_min)/(n_omega_int - 1);
            end for;
          end integrationFrequencyGen;

          function trapezoidalIntegration
            input Real y1;
            input Real y2;
            input Real domega;
            output Real Area;
          algorithm
            Area := 0.5*domega*(y1 + y2);
          end trapezoidalIntegration;
        end Calculations;

        function spectrumGenerator
          import Wave.WaveFunctions.SpectrumFunctions;
          extends spectrumIO;
          input String waveSelector "Wave Generation Selector";
        protected
          // JONSWAP parameters
          parameter Real spectralWidth_min = 0.07 "Lower spectral bound for JONSWAP" annotation(
            Dialog(group = "Spectrum Parameters"));
          parameter Real spectralWidth_max = 0.09 "Upper spectral bound for JONSWAP" annotation(
            Dialog(group = "Spectrum Parameters"));
        algorithm
          if waveSelector == "PiersonMoskowitz" then
            S := spectrumGenerator_PiersonMoskowitz(Hs = Hs, omega_peak = omega_peak, omega = omega, n_omega = n_omega);
          elseif waveSelector == "Bretschneider" then
            S := spectrumGenerator_Bretschneider(Hs = Hs, omega_peak = omega_peak, omega = omega, n_omega = n_omega);
          elseif waveSelector == "JONSWAP" then
            S := spectrumGenerator_JONSWAP(Hs = Hs, omega_peak = omega_peak, omega = omega, n_omega = n_omega, spectralWidth_min = spectralWidth_min, spectralWidth_max = spectralWidth_max);
          end if;
        end spectrumGenerator;

        partial model spectrumIO "Common input/output parameters for spectrum generation"
          extends Models.physicalConstants;
          input Real Hs "Significant wave height [m]";
          input Real omega_peak "Peak spectral frequency [rad/s]" annotation(
            Dialog(group = "Wave Spectrum Parameters"));
          input Real omega[n_omega] "Array of frequency components [rad/s]";
          parameter input Integer n_omega "Number of frequency components (default is 100 for irregular)";
          output Real S[n_omega] "Array of spectral values for input frequencies [m^2s]";
        end spectrumIO;
      end SpectrumFunctions;

      package WaveParameterFunctions
        function waveNumber "Function to iteratively compute the wave number from frequency components"
          /* Uses the dispersion relationship for water waves to calculate wave numbers
                                                                                                       This function implements an iterative method to solve the implicit dispersion equation */
          input Real d "Water depth [m]";
          input Real omega[:] "Array of wave frequency components [rad/s]";
          output Real k[size(omega, 1)] "Array of wave number components [rad/m]";
        protected
          constant Real g = Modelica.Constants.g_n "Gravitational acceleration [m/s^2]";
          constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
          parameter Integer n = size(omega, 1) "Number of frequency components";
          Real T[size(omega, 1)] "Array of wave period components [s]";
          Real L0[size(omega, 1)] "Array of deepwater wavelength components [m]";
          Real L1(start = 0, fixed = true) "Temporary variable for wavelength iteration [m]";
          Real L1c(start = 0, fixed = true) "Temporary variable for wavelength iteration comparison [m]";
          Real L[size(omega, 1)] "Array of iterated wavelength components [m]";
        algorithm
          T := 2*pi./omega;
          L0 := g*T.^2/(2*pi);
          for i in 1:size(omega, 1) loop
            L1 := L0[i];
            L1c := 0;
            while abs(L1c - L1) > 0.001 loop
// could also be a return
              L1c := L1;
              L[i] := g*T[i]^2/(2*pi)*tanh(2*pi/L1*d);
              L1 := L[i];
            end while;
          end for;
          k := 2*pi./L;
          annotation(
            Documentation(info = "<html>
              <p>Syntax: k = waveNumber(d, omega)</p>
              <p>Description: This function calculates wave numbers for given frequencies and water depth using the dispersion relationship for water waves. It employs an iterative method to solve the implicit dispersion equation.</p>
              <p>Inputs:</p>
              <ul>
                <li><code>d</code>: Water depth [m]</li>
                <li><code>omega</code>: Array of wave frequency components [rad/s]</li>
              </ul>
              <p>Outputs:</p>
              <ul>
                <li><code>k</code>: Array of wave number components [rad/m]</li>
              </ul>
              <p>Algorithm:</p>
              <ol>
                <li>Calculate wave periods from frequencies</li>
                <li>Calculate deepwater wavelengths</li>
                <li>Iterate to solve the dispersion equation for each frequency component</li>
                <li>Convert wavelengths to wave numbers</li>
              </ol>
            </html>"),
            Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "k()", textStyle = {TextStyle.Bold}), Line(points = {{-80, -80}, {80, 80}}, color = {0, 0, 255}, thickness = 0.5)}),
            Diagram(graphics = {Text(extent = {{-100, 80}, {100, 40}}, textString = "Wave Number Calculation"), Line(points = {{-80, 0}, {80, 0}}, color = {0, 0, 255}), Line(points = {{0, -80}, {0, 80}}, color = {0, 0, 255}), Text(extent = {{-60, -20}, {60, -60}}, textString = "k = 2/L")}),
            experiment(StopTime = 1.0, Tolerance = 1e-06));
        end waveNumber;
      end WaveParameterFunctions;

      function spectrumFrequencySelector
        input String waveSelector;
        output Integer n_omega;
      algorithm
        if waveSelector == "Linear" then
          n_omega := 1;
        else
          n_omega := 100;
        end if;
      end spectrumFrequencySelector;
    end WaveFunctions;

    package IrregularWave
      /* Package for irregular wave elevation profile and excitation force calculations */

      model BretschneiderWave "Implementation of Bretschneider wave spectrum for irregular wave generation"
        extends Wave.IrregularWave.irregularWaveParameters(fileName = filePath.FileName);
        outer OET.Hydro.FilePath filePath;
      equation
        if frequencySelection == "equalEnergy" then
          S_int = Wave.WaveFunctions.SpectrumFunctions.spectrumGenerator_BRT(Hs, omega_int, omega_peak) "Spectral values for frequency components [m^2-s/rad]";
        elseif frequencySelection == "random" then
          S = Wave.WaveFunctions.SpectrumFunctions.spectrumGenerator_BRT(Hs, omega, omega_peak) "Spectral values for frequency components [m^2-s/rad]";
        end if;
        annotation(
          Documentation(info = "<html>
          <h4>Pierson-Moskowitz Wave Spectrum Model</h4>
          <p>This model implements the Pierson-Moskowitz (PM) wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
          <p>Key features:</p>
          <ul>
            <li>Generates a wave spectrum based on the PM formulation</li>
            <li>Discretizes the spectrum into multiple frequency components</li>
            <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
            <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
            <li>Applies a ramping function to the excitation force during the initial phase</li>
            <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
          </ul>
          <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
          <h4>Usage Notes:</h4>
          <ul>
            <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
            <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
            <li>Random seeds can be changed to generate different realizations of the same sea state</li>
          </ul>
        </html>"),
          Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " Pierson Moskowitz ", fontName = "Arial")}, coordinateSystem(initialScale = 0.1)),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end BretschneiderWave;

      model PiersonMoskowitzWave "Implementation of Pierson-Moskowitz (PM) wave spectrum for irregular wave generation"
        extends Wave.IrregularWave.irregularWaveParameters(fileName = filePath.FileName);
        outer OET.Hydro.FilePath filePath;
      equation
        if frequencySelection == "equalEnergy" then
          S_int = Wave.WaveFunctions.SpectrumFunctions.spectrumGenerator_PM(Hs, omega_int) "Spectral values for frequency components [m^2-s/rad]";
        elseif frequencySelection == "random" then
          S = Wave.WaveFunctions.SpectrumFunctions.spectrumGenerator_PM(Hs, omega) "Spectral values for frequency components [m^2-s/rad]";
        end if;
        annotation(
          Documentation(info = "<html>
            <h4>Pierson-Moskowitz Wave Spectrum Model</h4>
            <p>This model implements the Pierson-Moskowitz (PM) wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p>Key features:</p>
            <ul>
              <li>Generates a wave spectrum based on the PM formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <h4>Usage Notes:</h4>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " Pierson Moskowitz ", fontName = "Arial")}, coordinateSystem(initialScale = 0.1)),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end PiersonMoskowitzWave;

      model JONSWAPWave "Implementation of JONSWAP wave spectrum for irregular wave generation"
        extends Wave.IrregularWave.irregularWaveParameters(fileName = filePath.FileName);
        outer OET.Hydro.FilePath filePath;
        // JONSWAP parameters
        parameter Real spectralWidth_min = 0.07 "Lower spectral bound for JONSWAP" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Real spectralWidth_max = 0.09 "Upper spectral bound for JONSWAP" annotation(
          Dialog(group = "Spectrum Parameters"));
      equation
        if frequencySelection == "equalEnergy" then
          S_int = Wave.WaveFunctions.SpectrumFunctions.spectrumGenerator_JONSWAP(Hs, omega_int, omega_peak, spectralWidth_min, spectralWidth_max) "Spectral values for frequency components [m^2-s/rad]";
        elseif frequencySelection == "random" then
          S = Wave.WaveFunctions.SpectrumFunctions.spectrumGenerator_JONSWAP(Hs, omega, omega_peak, spectralWidth_min, spectralWidth_max) "Spectral values for frequency components [m^2-s/rad]";
        end if;
        annotation(
          Documentation(info = "<html>
          <h4>JONSWAP Wave Spectrum Model</h4>
          <p>This model implements the JONSWAP (Joint North Sea Wave Project) wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
          <p>Key features:</p>
          <ul>
            <li>Generates a wave spectrum based on the JONSWAP formulation</li>
            <li>Discretizes the spectrum into multiple frequency components</li>
            <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
            <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
            <li>Applies a ramping function to the excitation force during the initial phase</li>
            <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
          </ul>
          <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
          <h4>Usage Notes:</h4>
          <ul>
            <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
            <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
            <li>Random seeds can be changed to generate different realizations of the same sea state</li>
            <li>JONSWAP spectrum is particularly suitable for modeling developing seas and storm conditions</li>
          </ul>
        </html>"),
          Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " JONSWAP ", fontName = "Arial")}),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end JONSWAPWave;

      partial model irregularWaveParameters "Irregular wave parameter class"
        // Inhertiance from the top-level wave parameter class, modifying the phase shift components
        extends Wave.waveParameters(epsilon = Wave.WaveFunctions.RandomFrequencyFunctions.randomNumberGen(localSeed1, globalSeed1, n_omega));
        // Irregular wave spectrum parameters
        parameter String frequencySelection = "random" annotation(
          Dialog(group = "Wave Spectrum Parameters"),
          choices(choice = "random", choice = "equalEnergy"));
        parameter Modelica.Units.SI.AngularFrequency omega_min = w[1] "Lowest frequency component [rad/s]" annotation(
          Dialog(group = "Wave Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_max = w[end] "Highest frequency component [rad/s]" annotation(
          Dialog(group = "Wave Spectrum Parameters"));
        // Random freqeuncy selection paramters (will be disabled if user opts to use equal energy method)
        parameter Integer localSeed = 614657 "Local random seed for frequency selection" annotation(
          Dialog(group = "Random Frequency Selection", enable = frequencySelection == "random"));
        parameter Integer globalSeed = 30020 "Global random seed for frequency selection" annotation(
          Dialog(group = "Random Frequency Selection", enable = frequencySelection == "random"));
        parameter Integer localSeed1 = 614757 "Local random seed for phase shifts" annotation(
          Dialog(group = "Random Frequency Selection", enable = frequencySelection == "random"));
        parameter Integer globalSeed1 = 40020 "Global random seed for phase shifts" annotation(
          Dialog(group = "Random Frequency Selection", enable = frequencySelection == "random"));
        // Equal Energy Parameters
        parameter Integer n_omega_int = 500 "Number of frequency components for spectrum generation and integration (equal energy only)" annotation(
          Dialog(group = "Equal Energy Frequency Selection", enable = frequencySelection == "equalEnergy"));
      protected
        // Random phase shift
        parameter Real rnd_shft[n_omega] = WaveProfile.WaveFunctions.RandomFrequencyFunctions.randomNumberGen(localSeed, globalSeed, n_omega) "Random shifts for frequency selection";
        // Frequency selection and wave spectrum
        Modelica.Units.SI.AngularFrequency domega "Frequency step size [rad/s]";
        Units.SpectrumEnergyDensity S[n_omega] "Wave energy spectrum [m^2 s/rad]";
        Modelica.Units.SI.AngularFrequency omega_int[n_omega_int] "Integration frequency step size (equal energy only) [rad/s]";
        Units.SpectrumEnergyDensity S_int[n_omega_int] "Integratation wave energy spectrum [m^2 s/rad]";
      equation
// Calculate wave parameter
        domega = WaveProfile.WaveFunctions.SpectrumFunctions.Calculations.frequencyStepGen(omega, n_omega);
        zeta = sqrt(2*S*domega);
// Select equal energy or random frequency selection
        if frequencySelection == "equalEnergy" then
          omega_int = Wave.WaveFunctions.SpectrumFunctions.Calculations.integrationFrequencyGen(omega_min, omega_max, n_omega_int);
          (omega, S) = Wave.WaveFunctions.EqualEnergyFrequencyFunctions.equalEnergyFrequencySelector(omega_min, omega_max, n_omega, n_omega_int, omega_int, S_int);
        elseif frequencySelection == "random" then
          omega = Wave.WaveFunctions.RandomFrequencyFunctions.randomFrequencySelector(omega_min, omega_max, rnd_shft) "Selected frequency components [rad/s]";
          omega_int = zeros(n_omega_int);
          S_int = zeros(n_omega_int);
        end if;
        annotation(
          Documentation(info = "<html>
            <p><b>Bretschneider Wave Spectrum Model</b></p>
            <p>This model implements the Bretschneider wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p><b>Key features:</b></p>
            <ul>
              <li>Generates a wave spectrum based on the Bretschneider formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <p><b>Usage Notes:</b></p>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " Bretschneider ", fontName = "Arial")}, coordinateSystem(initialScale = 0.1)),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05),
          Diagram(coordinateSystem(extent = {{100, 20}, {120, -20}})));
      end irregularWaveParameters;
      annotation(
        Documentation(info = "<html>
      <p><strong>IrregularWave Package</strong></p>
      <p>This package provides models for generating irregular wave profiles and calculating associated excitation forces using various wave spectra commonly used in ocean engineering and naval architecture.</p>
      <p><em>Included Models:</em></p>
      <ul>
        <p><strong>PiersonMoskowitzWave:</strong> Implements the Pierson-Moskowitz spectrum, suitable for fully developed seas.</p>
        <p><strong>BretschneiderWave:</strong> Implements the Bretschneider spectrum, a two-parameter spectrum also known as the modified Pierson-Moskowitz spectrum.</p>
        <p><strong>JonswapWave:</strong> Implements the JONSWAP (Joint North Sea Wave Project) spectrum, particularly useful for modeling developing seas and storm conditions.</p>
      </ul>
      <p>Each model provides options for customizing sea state parameters and offers both wave elevation profiles and excitation force calculations.</p>
    </html>"),
        Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-90, -70}, {90, -90}}, lineColor = {0, 0, 255}, fillColor = {0, 0, 255}, fillPattern = FillPattern.Solid, textString = "Irregular Wave")}));
    end IrregularWave;

    model Environment
      extends Wave.waveParameters(fileName = filePath.FileName);
      outer OET.Hydro.FilePath filePath;
      // Irregular wave spectrum parameters
      parameter String frequencySelection = "random" annotation(
        Dialog(group = "Wave Spectrum Parameters"),
        choices(choice = "random", choice = "equalEnergy"));
      parameter Modelica.Units.SI.AngularFrequency omega_min = w[1] "Lowest frequency component [rad/s]" annotation(
        Dialog(group = "Wave Spectrum Parameters"));
      parameter Modelica.Units.SI.AngularFrequency omega_max = w[end] "Highest frequency component [rad/s]" annotation(Dialog(group = "Wave Spectrum Parameters"));
      // Random freqeuncy selection paramters (will be disabled if user opts to use equal energy method)
      parameter Integer localSeed = 614657 "Local random seed for frequency selection" annotation(HideResult = true,
        Dialog(group = "Random Frequency Selection", enable = frequencySelection == "random"));
      parameter Integer globalSeed = 30020 "Global random seed for frequency selection" annotation(HideResult = true,
        Dialog(group = "Random Frequency Selection", enable = frequencySelection == "random"));
      // Equal Energy Parameters
      parameter Integer n_omega_int = 500 "Number of frequency components for spectrum generation and integration (equal energy only)" annotation(HideResult = true,
        Dialog(group = "Equal Energy Frequency Selection", enable = frequencySelection == "equalEnergy"));
      inner Units.SpectrumEnergyDensity S[n_omega] "Wave energy spectrum [m^2*s/rad]";
    protected
      // Random phase shift
      Real rnd_shft[n_omega] "Random shifts for frequency selection";
      // Frequency selection and wave spectrum
      Modelica.Units.SI.AngularFrequency domega "Frequency step size [rad/s]";
      //unit issue here
      Modelica.Units.SI.AngularFrequency omega_int[n_omega_int] "Integration frequency step size (equal energy only) [rad/s]";
      Units.SpectrumEnergyDensity S_int[n_omega_int] "Integratation wave energy spectrum [m^2*s/rad]";
    equation
      if waveSelector == "Linear" then
// Calculate wave amplityde
        zeta[n_omega] = Hs/2 "Wave amplitude [m]";
// Assign peak amplitude to the scalar frequency
        omega[n_omega] = omega_peak;
        rnd_shft = zeros(n_omega);
      else
        rnd_shft = Wave.WaveFunctions.RandomFrequencyFunctions.randomNumberGen(localSeed, globalSeed, n_omega);
// Calculate wave parameter
        domega = Wave.WaveFunctions.SpectrumFunctions.Calculations.frequencyStepGen(omega, n_omega);
        zeta = sqrt(2*S*domega);
// Select equal energy or random frequency selection
        if frequencySelection == "equalEnergy" then
          omega_int = Wave.WaveFunctions.SpectrumFunctions.Calculations.integrationFrequencyGen(omega_min, omega_max, n_omega_int);
          S_int = Wave.WaveFunctions.SpectrumFunctions.spectrumGenerator(waveSelector = waveSelector, Hs = Hs, omega_peak = omega_peak, omega = omega_int, n_omega = n_omega_int);
          (omega, S) = Wave.WaveFunctions.EqualEnergyFrequencyFunctions.equalEnergyFrequencySelector(omega_min, omega_max, n_omega, n_omega_int, omega_int, S_int);
        elseif frequencySelection == "random" then
          omega = Wave.WaveFunctions.RandomFrequencyFunctions.randomFrequencySelector(omega_min, omega_max, rnd_shft, n_omega) "Selected frequency components [rad/s]";
          S = Wave.WaveFunctions.SpectrumFunctions.spectrumGenerator(waveSelector = waveSelector, Hs = Hs, omega_peak = omega_peak, omega = omega, n_omega = n_omega);
          omega_int = zeros(n_omega_int);
          S_int = zeros(n_omega_int);
        end if;
      end if;
      annotation(
        defaultComponentName = "environment",
        defaultComponentPrefixes = "inner",
        missingInnerMessage="No \"environemnt\" component is defined. Drag the OET.Wave.Environment model into the top level of your model.",
        Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}}), graphics = {Rectangle(extent = {{-100, -100}, {100, 100}}), Text(extent = {{-100, -100}, {100, 100}}, textString = "Environment")}),
        Diagram);
    end Environment;

    type waveSelectorOptions = enumeration(Linear,Bretschneider,PiersonMoskowitz,JONSWAP);
  end Wave;

  package Mooring
    model LinearMooringForce
      // Import hydro coefficients
      extends DataImport.linearMooringData;
      // Inherit frame_a
      extends Modelica.Mechanics.MultiBody.Interfaces.PartialOneFrame_a;
      // Position connectors
      Modelica.Blocks.Interfaces.RealInput u_abs[3] "Linear displacement vector [m]" annotation(HideResult = true,
        Placement(transformation(origin = {-100, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {-100, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
      Modelica.Blocks.Interfaces.RealInput theta_abs[3] "Angular displacement vector [rad]" annotation(HideResult = true,
        Placement(transformation(origin = {-60, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {-60, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
      // Velocity connectors
      Modelica.Blocks.Interfaces.RealInput v_abs[3] "Linear velocity vector [m/s]" annotation(HideResult = true,
        Placement(transformation(origin = {-20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {-20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
      Modelica.Blocks.Interfaces.RealInput omega_abs[3] "Angular velocity vector [rad/s]" annotation(HideResult = true,
        Placement(transformation(origin = {20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
        parameter Boolean enableLinearMooringForce = true "Switch to enable/disable linear mooring force calculation" annotation(HideResult = true,
        Dialog(group = "Linear Mooring Force Parameters"));
      Real F[6] = cat(1, f_element, t_element) "Combined force and torque vector [N,Nm]";
    protected
      Real displacement[6] = cat(1, u_abs, theta_abs) "Combined displacement vector [m, rad]";
      Real velocity[6] = cat(1, v_abs, omega_abs) "Combined velocity vector [m/s, rad/s]";
      Modelica.Units.SI.Force f_element[3];
      Modelica.Units.SI.Torque t_element[3];
    equation
// Use the switch to conditionally output the hydrostatic force torque element
      if enableLinearMooringForce then
// Calculate the linear mooring force/torque vector
        F = Cm*velocity + Km*displacement;
      else
        F = zeros(6);
      end if;
    
      frame_a.f = f_element;
      frame_a.t = t_element;
      annotation(
        Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}}), graphics = {Rectangle(extent = {{-100, -100}, {100, 100}}), Text(extent = {{-100, -100}, {100, 100}}, textString = "Mooring Force")}));
    end LinearMooringForce;

    model LinearMooring
      outer OET.Hydro.FilePath filePath;
      parameter Boolean enableLinearMooringForce = true "Switch to enable/disable linear mooring force calculation" annotation(
        Dialog(group = "Linear Mooring Force Parameters"));
      // Frame_a connector
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a "Coordinate system fixed at body" annotation(HideResult = true,
        Placement(transformation(extent = {{-116, -16}, {-84, 16}})));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteSensor absoluteSensor(get_r = true, get_angles = true, resolveInFrame = Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world, get_w = true, get_v = true) annotation(HideResult = true,
        Placement(transformation(origin = {1, 53}, extent = {{-15, -15}, {15, 15}}, rotation = -0)));
      LinearMooringForce linearMooringForce(enableLinearMooringForce = enableLinearMooringForce, fileName = filePath.FileName) annotation(
        Placement(transformation(origin = {2, -10}, extent = {{-18, -18}, {18, 18}})));
    equation
      connect(linearMooringForce.frame_a, frame_a) annotation(
        Line(points = {{-16, -10}, {-16, -1}, {-100, -1}, {-100, 0}}, color = {95, 95, 95}));
      connect(linearMooringForce.u_abs, absoluteSensor.r) annotation(
        Line(points = {{-16, 11}, {-16, 14}, {-14, 14}, {-14, 36}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.v, linearMooringForce.v_abs) annotation(
        Line(points = {{-8, 36}, {-8, 26.5}, {-2, 26.5}, {-2, 11}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.angles, linearMooringForce.theta_abs) annotation(
        Line(points = {{4, 36}, {4, 24}, {-9, 24}, {-9, 11}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.w, linearMooringForce.omega_abs) annotation(
        Line(points = {{10, 36}, {10, 25.5}, {6, 25.5}, {6, 11}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.frame_a, frame_a) annotation(
        Line(points = {{-14, 54}, {-100, 54}, {-100, 0}}, color = {95, 95, 95}));
      annotation(
        Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}}), graphics = {Text(
              extent={{-150,145},{150,105}},
              textString="%name",
              textColor={0,0,255}),Rectangle(extent = {{-100, -100}, {100, 100}}), Text(extent = {{-100, -100}, {100, 100}}, textString = "Linear Mooring")}),
        Diagram);
    end LinearMooring;
  end Mooring;

  package PTO
    model LinearPTOForce
      // Import hydro coefficients
      extends DataImport.linearPTOData;
      // Inherit frame_b
      extends Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames;
      // Body 1
      // Position connectors
      Modelica.Blocks.Interfaces.RealInput u_abs1[3] "Linear displacement vector [m]" annotation(HideResult = true,
        Placement(transformation(origin = {-100, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {-100, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
      Modelica.Blocks.Interfaces.RealInput theta_abs1[3] "Angular displacement vector [rad]" annotation(HideResult = true,
        Placement(transformation(origin = {-60, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {-60, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
      // Velocity connectors
      Modelica.Blocks.Interfaces.RealInput v_abs1[3] "Linear velocity vector [m/s]" annotation(HideResult = true,
        Placement(transformation(origin = {-20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {-20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
      Modelica.Blocks.Interfaces.RealInput omega_abs1[3] "Angular velocity vector [rad/s]" annotation(HideResult = true,
        Placement(transformation(origin = {20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270), iconTransformation(origin = {20, 115}, extent = {{-15, -15}, {15, 15}}, rotation = 270)));
      // Body 2
      // Position connectors
      Modelica.Blocks.Interfaces.RealInput u_abs2[3] "Linear displacement vector [m]" annotation(HideResult = true,
        Placement(transformation(origin = {100, -115}, extent = {{-15, -15}, {15, 15}}, rotation = 90), iconTransformation(origin = {100, -115}, extent = {{-15, -15}, {15, 15}}, rotation = 90)));
      Modelica.Blocks.Interfaces.RealInput theta_abs2[3] "Angular displacement vector [rad]" annotation(HideResult = true,
        Placement(transformation(origin = {60, -115}, extent = {{-15, -15}, {15, 15}}, rotation = 90), iconTransformation(origin = {60, -115}, extent = {{-15, -15}, {15, 15}}, rotation = 90)));
      // Velocity connectors
      Modelica.Blocks.Interfaces.RealInput v_abs2[3] "Linear velocity vector [m/s]" annotation(HideResult = true,
        Placement(transformation(origin = {20, -115}, extent = {{-15, -15}, {15, 15}}, rotation = 90), iconTransformation(origin = {20, -115}, extent = {{-15, -15}, {15, 15}}, rotation = 90)));
      Modelica.Blocks.Interfaces.RealInput omega_abs2[3] "Angular velocity vector [rad/s]" annotation(HideResult = true,
        Placement(transformation(origin = {-20, -115}, extent = {{-15, -15}, {15, 15}}, rotation = 90), iconTransformation(origin = {-20, -115}, extent = {{-15, -15}, {15, 15}}, rotation = 90)));
      // Enable/disable dampingdrag force
      parameter Boolean enableLinearPTOForce = true "Switch to enable/disable linear PTO force calculation" annotation(HideResult = true,
        Dialog(group = "Linear PTO Force Parameters"));
      // I should eventually inherit these
      Real F[6] = cat(1, f_element, t_element) "Combined force and torque vector [N,Nm]";
    protected
      Real displacement1[6] = cat(1, u_abs1, theta_abs1) "Combined displacement vector [m, rad]";
      Real velocity1[6] = cat(1, v_abs1, omega_abs1) "Combined velocity vector [m/s, rad/s]";
      Real displacement2[6] = cat(1, u_abs2, theta_abs2) "Combined displacement vector [m, rad]";
      Real velocity2[6] = cat(1, v_abs2, omega_abs2) "Combined velocity vector [m/s, rad/s]";
      Modelica.Units.SI.Force f_element[3];
      Modelica.Units.SI.Torque t_element[3];
    equation
// Use the switch to conditionally output the damping drag force and torque
      if enableLinearPTOForce then
// Calculate the PTO force/torque vector
        F = Cpto*(velocity1 - velocity2) + Kpto*(displacement1 - displacement2);
      else
        F = zeros(6);
      end if;
      frame_a.f = -f_element;
      frame_a.t = -t_element;
      frame_b.f = f_element;
      frame_b.t = t_element;
      annotation(
        Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}}), graphics = {Rectangle(extent = {{-100, -100}, {100, 100}}), Text(extent = {{-100, -100}, {100, 100}}, textString = "PTO Force")}));
    end LinearPTOForce;

    model LinearPTO
      outer OET.Hydro.FilePath filePath;
      parameter Boolean enableLinearPTOForce = true "Switch to enable/disable Linear PTO force calculation" annotation(
        Dialog(group = "Linear PTO Force Parameters"));
      // Frame_ and frame_b connectors
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a "Coordinate system fixed to the component with one cut-force and cut-torque" annotation(HideResult = true,
        Placement(transformation(extent = {{-116, -16}, {-84, 16}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_b "Coordinate system fixed at body" annotation(HideResult = true,
        Placement(transformation(extent = {{84, -16}, {116, 16}})));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteSensor absoluteSensor(resolveInFrame = Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world, get_r = true, get_v = true, get_w = true, get_angles = true) annotation(HideResult = true,
        Placement(transformation(origin = {0, 54}, extent = {{-14, -14}, {14, 14}}, rotation = -0)));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteSensor absoluteSensor1(get_angles = true, get_r = true, get_v = true, get_w = true, resolveInFrame = Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world) annotation(HideResult = true,
        Placement(transformation(origin = {2, -60}, extent = {{-14, -14}, {14, 14}}, rotation = -180)));
      LinearPTOForce linearPTOForce(enableLinearPTOForce = enableLinearPTOForce, fileName = filePath.FileName) annotation(
        Placement(transformation(extent = {{-16, -16}, {16, 16}})));
    equation
      connect(absoluteSensor1.frame_a, frame_b) annotation(
        Line(points = {{16, -60}, {100, -60}, {100, 0}}, color = {95, 95, 95}));
      connect(absoluteSensor.frame_a, frame_a) annotation(
        Line(points = {{-14, 54}, {-100, 54}, {-100, 0}}, color = {95, 95, 95}));
      connect(absoluteSensor1.r, linearPTOForce.u_abs2) annotation(
        Line(points = {{16, -44}, {16, -18}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor1.v, linearPTOForce.v_abs2) annotation(
        Line(points = {{10, -44}, {10, -38}, {3, -38}, {3, -18}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor1.angles, linearPTOForce.theta_abs2) annotation(
        Line(points = {{0, -44}, {0, -34}, {10, -34}, {10, -18}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor1.w, linearPTOForce.omega_abs2) annotation(
        Line(points = {{-6, -44}, {-6, -18}, {-3, -18}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.r, linearPTOForce.u_abs1) annotation(
        Line(points = {{-14, 38}, {-14, 26}, {-16, 26}, {-16, 18}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.v, linearPTOForce.v_abs1) annotation(
        Line(points = {{-8, 38}, {-8, 34}, {-3, 34}, {-3, 18}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.angles, linearPTOForce.theta_abs1) annotation(
        Line(points = {{2, 38}, {4, 38}, {4, 28}, {-10, 28}, {-10, 18}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.w, linearPTOForce.omega_abs1) annotation(
        Line(points = {{8, 38}, {8, 18}, {3, 18}}, color = {0, 0, 127}, thickness = 0.5));
      connect(linearPTOForce.frame_a, frame_a) annotation(
        Line(points = {{-16, 0}, {-100, 0}}, color = {95, 95, 95}));
      connect(linearPTOForce.frame_b, frame_b) annotation(
        Line(points = {{16, 0}, {100, 0}}, color = {95, 95, 95}));
      annotation(
        Icon(coordinateSystem(extent = {{-100, -100}, {100, 100}}), graphics = {Text(
              extent={{-150,145},{150,105}},
              textString="%name",
              textColor={0,0,255}),Rectangle(extent = {{-100, -100}, {100, 100}}), Text(extent = {{-100, -100}, {100, 100}}, textString = "Linear PTO")}),
        Diagram);
    end LinearPTO;
  end PTO;
  annotation(
    Icon(graphics = {Line(points = {{-90, 40}, {-60, 60}, {-30, 20}, {0, 60}, {30, 20}, {60, 60}, {90, 40}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Line(points = {{-90, -40}, {-60, -20}, {-30, -60}, {0, -20}, {30, -60}, {60, -20}, {90, -40}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Ellipse(extent = {{-20, 20}, {20, -20}}, lineColor = {0, 0, 0}, fillColor = // Black circle
    {0, 0, 0}, fillPattern = // Light gray fill
    FillPattern.Solid// Solid fill
    )}),
    Documentation(info = "<html>
    <p><strong>Hydrodynamic Package</strong></p>
    
    <p>This package contains models and components for simulating hydrodynamic systems, 
    particularly focused on Wave Energy Converters (WECs). The current implementation 
    includes a variety of models and force components across several sub-packages.</p>
    
    <p><strong>Key Sub-Packages:</strong></p>
    <ul>
        <li><strong>Example:</strong>
            <ul>
                <li><strong>SingleBodyWEC1D:</strong> A 1D single-body Wave Energy Converter model.</li>
            </ul>
        </li>
        <li><strong>Forces:</strong>
            <ul>
                <li><strong>HydrostaticForce6D:</strong> Calculates 6D hydrostatic forces and torques.</li>
                <li><strong>RadiationForce:</strong> Computes radiation forces (currently 1D, vertical direction only).</li>
                <li><strong>DragForce6D:</strong> Computes 6D drag forces and torques.</li>
                <li><strong>PTO6D:</strong> Models a 6D Power Take-Off system.</li>
                <li><strong>HydrodynamicBlock6D:</strong> Calculates and applies 6D hydrodynamic forces and moments.</li>
                <li><strong>RadiationF3D:</strong> An extended version of RadiationForce for 3D modeling.</li>
            </ul>
        </li>
        <li><strong>WaveProfile:</strong>
            <ul>
                <li><strong>RegularWave:</strong> A linear wave model.</li>
                <li><strong>IrregularWave:</strong> Includes Pierson-Moskowitz, Bretschneider, JONSWAP wave models, and various irregular parameters.</li>
            </ul>
        </li>
        <li><strong>Connector:</strong> Contains connector definitions for hydrodynamic components.</li>
        <li><strong>Internal:</strong> Contains internal utility components used across the package.</li>
        <li><strong>Archive:</strong> Contains deprecated or experimental models and components.</li>
    </ul>
    
    <p><strong>Current Capabilities:</strong></p>
    <p>The package allows for modeling of a single-body WEC with the following features:</p>
    <ul>
        <li>6D modeling of drag, PTO, and hydrostatic forces</li>
        <li>1D and 3D modeling of radiation forces</li>
        <li>External excitation force input</li>
        <li>Rigid body dynamics in 6D</li>
        <li>Wave profile modeling including regular and irregular waves</li>
    </ul>
    
    <p><strong>Limitations and Future Work:</strong></p>
    <ul>
        <li>Further extension of radiation forces to full 6D capabilities</li>
        <li>Expansion of the excitation force model to include full 6D capabilities</li>
        <li>Implementation of additional WEC configurations (e.g., multi-body systems)</li>
    </ul>
    
    <p>This package provides a foundation for hydrodynamic simulations in Modelica, 
    particularly suited for Wave Energy Converter applications. Users can leverage 
    these components to build and simulate various marine energy devices.</p>
</html>"),
    uses(Modelica(version = "4.0.0")));
end OET;
