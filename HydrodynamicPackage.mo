package Hydrodynamic
  extends Modelica.Icons.Package;

  package Example
    extends Modelica.Icons.Package;

    model SingleBodyWEC1D "1D Single-Body Wave Energy Converter Model"
      extends Modelica.Icons.Package;
      // World component (no gravity, Z-axis pointing downwards)
      inner Modelica.Mechanics.MultiBody.World world(gravityType = Modelica.Mechanics.MultiBody.Types.GravityTypes.NoGravity, n = {0, 0, -1}) "World coordinate system without gravity" annotation(
        Placement(transformation(origin = {-40, -20}, extent = {{-10, -10}, {10, 10}})));
      // Force application component
      // Prismatic joint for vertical motion
      Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic(n = {0, 0, 1}) "Prismatic joint allowing vertical motion" annotation(
        Placement(transformation(origin = {-14, -20}, extent = {{-10, -10}, {10, 10}})));
      // Hydrodynamic body component
      // Wave profile component
      Forces.HydrodynamicBlock6D hydrodynamicBlock6D(enablePTOForce = true, enableDragForce = false, enableRadiationForce = true, enableHydrostaticForce = true) annotation(
        Placement(transformation(origin = {12, -20}, extent = {{-10, -10}, {10, 10}})));
      WaveProfile.IrregularWave.PiersonMoskowitzWave piersonMoskowitzWave annotation(
        Placement(transformation(origin = {70, -20}, extent = {{-10, 10}, {10, -10}}, rotation = -180)));
      Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque forceAndTorque annotation(
        Placement(transformation(origin = {38, -20}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
    equation
// Connections between components
      connect(world.frame_b, prismatic.frame_a) annotation(
        Line(points = {{-30, -20}, {-24, -20}}, color = {95, 95, 95}));
      connect(prismatic.frame_b, hydrodynamicBlock6D.frame_a) annotation(
        Line(points = {{-4, -20}, {2, -20}}, color = {95, 95, 95}));
      connect(forceAndTorque.frame_b, hydrodynamicBlock6D.frame_b) annotation(
        Line(points = {{28, -20}, {22, -20}}, color = {95, 95, 95}));
      connect(piersonMoskowitzWave.F, forceAndTorque.force) annotation(
        Line(points = {{60, -14}, {50, -14}}, color = {0, 0, 127}, thickness = 0.5));
      connect(piersonMoskowitzWave.T, forceAndTorque.torque) annotation(
        Line(points = {{60, -24}, {50, -24}, {50, -26}}, color = {0, 0, 127}, thickness = 0.5));
      annotation(
        Icon(graphics = {Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Ellipse(extent = {{-20, 20}, {20, -20}}, lineColor = {0, 0, 0}, fillColor = {0, 0, 0}, fillPattern = FillPattern.Solid)}),
        Documentation(info = "<html>
          <p><b>1D Single-Body Wave Energy Converter (WEC) Model</b></p>
          <p>This model represents a simplified 1D single-body wave energy converter system, 
          focusing on the vertical motion of the body in response to wave excitation forces.</p>
          
          <p><b>Model Description</b></p>
          <p>The WEC consists of a hydrodynamic body constrained to move vertically using a prismatic joint. 
          The body is subjected to wave excitation forces generated by Regular (Linear) and Irregular (PM, Bretschneider, JONSWAP) wave profiles.</p>
          
          <p><b>Key Components</b></p>
          <ul>
            <li><code>world</code>: Defines the world coordinate system without gravity</li>
            <li><code>bodyHD6D</code>: Represents the hydrodynamic body of the WEC</li>
            <li><code>prismatic</code>: Allows vertical motion of the body</li>
            <li><code>Regular and Irregular Wave Profiles</code>: Generates regular and irregular wave excitation forces</li>
            <li><code>forceAndTorque</code>: Applies the excitation force to the body</li>
          </ul>
          
          <p><b>Assumptions and Simplifications</b></p>
          <ul>
            <li>The model considers only vertical motion (1D) of the WEC</li>
            <li>Gravity is not included in the world model</li>
            <li>The excitation force is applied as an external input based on the Pierson-Moskowitz or Regular wave profile</li>
          </ul>
          
          <p><b>Notes</b></p>
          <ul>
            <li>This model serves as a basic framework for WEC simulations and can be extended for more complex analyses</li>
            <li>Additional forces like radiation damping or PTO forces can be added to enhance the model's realism</li>
            <li>Ensure that the BodyHD6D component is properly configured for accurate results</li>
            <li>The wave parameters may need to be adjusted to represent specific sea states</li>
          </ul>
        </html>"),
        Diagram(coordinateSystem(extent = {{-80, 0}, {100, -40}})),
        experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
    end SingleBodyWEC1D;

    model SingleBodyWEC1D_1DoFRad "1D Single-Body Wave Energy Converter Model"
      extends Modelica.Icons.Package;
      // World component (no gravity, Z-axis pointing downwards)
      inner Modelica.Mechanics.MultiBody.World world(gravityType = Modelica.Mechanics.MultiBody.Types.GravityTypes.NoGravity, n = {0, 0, -1}) "World coordinate system without gravity" annotation(
        Placement(transformation(origin = {-40, -20}, extent = {{-10, -10}, {10, 10}})));
      // Force application component
      // Prismatic joint for vertical motion
      Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic(n = {0, 0, 1}) "Prismatic joint allowing vertical motion" annotation(
        Placement(transformation(origin = {-14, -20}, extent = {{-10, -10}, {10, 10}})));
      // Hydrodynamic body component
      // Wave profile component
      //Hydrodynamic.Forces1D.PiersonMoskowitzWave1D piersonMoskowitzWave1D annotation(Placement(transformation(origin = {70, -20}, extent = {{-10, 10}, {10, -10}}, rotation = -180)));
      Forces1D.EqualEnergy_PiersonMoskowitzWave1D piersonMoskowitzWave1D annotation(
        Placement(transformation(origin = {70, -20}, extent = {{-10, 10}, {10, -10}}, rotation = -180)));
      Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque forceAndTorque annotation(
        Placement(transformation(origin = {38, -20}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
      Forces1D.HydrodynamicBlock6D_1DoFRad hydrodynamicBlock6D_1DoFRad(enablePTOForce = true, enableRadiationForce = true) annotation(
        Placement(transformation(origin = {10, -20}, extent = {{-10, -10}, {10, 10}})));
    equation
// Connections between components
      connect(world.frame_b, prismatic.frame_a) annotation(
        Line(points = {{-30, -20}, {-24, -20}}, color = {95, 95, 95}));
      connect(piersonMoskowitzWave1D.F, forceAndTorque.force) annotation(
        Line(points = {{60, -14}, {50, -14}}, color = {0, 0, 127}, thickness = 0.5));
      connect(piersonMoskowitzWave1D.T, forceAndTorque.torque) annotation(
        Line(points = {{60, -24}, {50, -24}, {50, -26}}, color = {0, 0, 127}, thickness = 0.5));
      connect(hydrodynamicBlock6D_1DoFRad.frame_b, forceAndTorque.frame_b) annotation(
        Line(points = {{20, -20}, {28, -20}}));
      connect(prismatic.frame_b, hydrodynamicBlock6D_1DoFRad.frame_a) annotation(
        Line(points = {{-4, -20}, {0, -20}}, color = {95, 95, 95}));
      annotation(
        Icon(graphics = {Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Ellipse(extent = {{-20, 20}, {20, -20}}, lineColor = {0, 0, 0}, fillColor = {0, 0, 0}, fillPattern = FillPattern.Solid)}),
        Documentation(info = "<html>
          <p><b>1D Single-Body Wave Energy Converter (WEC) Model</b></p>
          <p>This model represents a simplified 1D single-body wave energy converter system, 
          focusing on the vertical motion of the body in response to wave excitation forces.</p>
          
          <p><b>Model Description</b></p>
          <p>The WEC consists of a hydrodynamic body constrained to move vertically using a prismatic joint. 
          The body is subjected to wave excitation forces generated by Regular (Linear) and Irregular (PM, Bretschneider, JONSWAP) wave profiles.</p>
          
          <p><b>Key Components</b></p>
          <ul>
            <li><code>world</code>: Defines the world coordinate system without gravity</li>
            <li><code>bodyHD6D</code>: Represents the hydrodynamic body of the WEC</li>
            <li><code>prismatic</code>: Allows vertical motion of the body</li>
            <li><code>Regular and Irregular Wave Profiles</code>: Generates regular and irregular wave excitation forces</li>
            <li><code>forceAndTorque</code>: Applies the excitation force to the body</li>
          </ul>
          
          <p><b>Assumptions and Simplifications</b></p>
          <ul>
            <li>The model considers only vertical motion (1D) of the WEC</li>
            <li>Gravity is not included in the world model</li>
            <li>The excitation force is applied as an external input based on the Pierson-Moskowitz or Regular wave profile</li>
          </ul>
          
          <p><b>Notes</b></p>
          <ul>
            <li>This model serves as a basic framework for WEC simulations and can be extended for more complex analyses</li>
            <li>Additional forces like radiation damping or PTO forces can be added to enhance the model's realism</li>
            <li>Ensure that the BodyHD6D component is properly configured for accurate results</li>
            <li>The wave parameters may need to be adjusted to represent specific sea states</li>
          </ul>
        </html>"),
        Diagram(coordinateSystem(extent = {{-80, 0}, {100, -40}})),
        experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
    end SingleBodyWEC1D_1DoFRad;

    model OOP_SingleBodyWEC1D "1D Single-Body Wave Energy Converter Model"
      extends Modelica.Icons.Package;
    // World component (no gravity, Z-axis pointing downwards)
      inner Modelica.Mechanics.MultiBody.World world(gravityType = Modelica.Mechanics.MultiBody.Types.GravityTypes.NoGravity, n = {0, 0, -1}) "World coordinate system without gravity" annotation(
        Placement(transformation(origin = {-40, -20}, extent = {{-10, -10}, {10, 10}})));
      // Prismatic joint constraining motion in heave
      Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic(n = {0, 0, 1}) "Prismatic joint allowing vertical motion" annotation(
        Placement(transformation(origin = {-14, -20}, extent = {{-10, -10}, {10, 10}})));
      // Force and torque element (adapt wave output to a force and apply to the body)
      Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque forceAndTorque annotation(
        Placement(transformation(origin = {38, -20}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
      // Define hydrodynamic body
      Hydrodynamic.Forces.HydrodynamicBody hydrodynamicBody( /*enableHydrostaticForce = true, */enablePTOForce = true, enableRadiationForce = true,FileName=filePath.FileName) annotation(
        Placement(transformation(origin = {10, -20}, extent = {{-10, -10}, {10, 10}})));
      // Define wave and current bus
      WaveProfile.WaveAndCurrentBus waveAndCurrentBus annotation(
        Placement(transformation(origin = {68, -18}, extent = {{10, -10}, {-10, 10}}, rotation = -0)));
      // Define wave spectrum
      WaveProfile.IrregularWave.Bus_PiersonMoskowitzWave bus_PiersonMoskowitzWave(fileName=filePath.FileName) annotation(
        Placement(transformation(origin = {100, -18}, extent = {{10, -10}, {-10, 10}}, rotation = -0)));
  Forces.FilePath filePath annotation(
        Placement(transformation(origin = {132, -18}, extent = {{-10, -10}, {10, 10}})));
    equation
// Connections
      connect(world.frame_b, prismatic.frame_a) annotation(
        Line(points = {{-30, -20}, {-24, -20}}, color = {95, 95, 95}));
      connect(hydrodynamicBody.frame_b, forceAndTorque.frame_b) annotation(
        Line(points = {{20, -20}, {28, -20}}));
      connect(prismatic.frame_b, hydrodynamicBody.frame_a) annotation(
        Line(points = {{-4, -20}, {0, -20}}, color = {95, 95, 95}));
      connect(waveAndCurrentBus.F, forceAndTorque.force) annotation(
        Line(points = {{58, -12}, {50, -12}, {50, -14}}, color = {0, 0, 127}, thickness = 0.5));
      connect(waveAndCurrentBus.T, forceAndTorque.torque) annotation(
        Line(points = {{58, -22}, {50, -22}, {50, -26}}, color = {0, 0, 127}, thickness = 0.5));
      connect(bus_PiersonMoskowitzWave.F, waveAndCurrentBus.Fw) annotation(
        Line(points = {{90, -18}, {80, -18}, {80, -10}}, color = {0, 0, 127}, thickness = 0.5));
      annotation(
        Icon(graphics = {Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Ellipse(extent = {{-20, 20}, {20, -20}}, lineColor = {0, 0, 0}, fillColor = {0, 0, 0}, fillPattern = FillPattern.Solid)}),
        Documentation(info = "<html>
          <p><b>1D Single-Body Wave Energy Converter (WEC) Model</b></p>
          <p>This model represents a simplified 1D single-body wave energy converter system, 
          focusing on the vertical motion of the body in response to wave excitation forces.</p>
          
          <p><b>Model Description</b></p>
          <p>The WEC consists of a hydrodynamic body constrained to move vertically using a prismatic joint. 
          The body is subjected to wave excitation forces generated by Regular (Linear) and Irregular (PM, Bretschneider, JONSWAP) wave profiles.</p>
          
          <p><b>Key Components</b></p>
          <ul>
            <li><code>world</code>: Defines the world coordinate system without gravity</li>
            <li><code>bodyHD6D</code>: Represents the hydrodynamic body of the WEC</li>
            <li><code>prismatic</code>: Allows vertical motion of the body</li>
            <li><code>Regular and Irregular Wave Profiles</code>: Generates regular and irregular wave excitation forces</li>
            <li><code>forceAndTorque</code>: Applies the excitation force to the body</li>
          </ul>
          
          <p><b>Assumptions and Simplifications</b></p>
          <ul>
            <li>The model considers only vertical motion (1D) of the WEC</li>
            <li>Gravity is not included in the world model</li>
            <li>The excitation force is applied as an external input based on the Pierson-Moskowitz or Regular wave profile</li>
          </ul>
          
          <p><b>Notes</b></p>
          <ul>
            <li>This model serves as a basic framework for WEC simulations and can be extended for more complex analyses</li>
            <li>Additional forces like radiation damping or PTO forces can be added to enhance the model's realism</li>
            <li>Ensure that the BodyHD6D component is properly configured for accurate results</li>
            <li>The wave parameters may need to be adjusted to represent specific sea states</li>
          </ul>
        </html>"),
        Diagram(coordinateSystem(extent = {{-80, 0}, {150, -40}})),
        experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
    end OOP_SingleBodyWEC1D;

    model OOP_SingleBodyWECMooring
      extends Modelica.Icons.Package;
    // World component (no gravity, Z-axis pointing downwards)
      inner Modelica.Mechanics.MultiBody.World world(gravityType = Modelica.Mechanics.MultiBody.Types.GravityTypes.NoGravity, n = {0, 0, -1}) "World coordinate system without gravity" annotation(
        Placement(transformation(origin = {-40, -20}, extent = {{-10, -10}, {10, 10}})));
      // Prismatic joint constraining motion in heave
      Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic(n = {0, 0, 1}) "Prismatic joint allowing vertical motion" annotation(
        Placement(transformation(origin = {-14, -20}, extent = {{-10, -10}, {10, 10}})));
      // Force and torque element (adapt wave output to a force and apply to the body)
      Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque forceAndTorque annotation(
        Placement(transformation(origin = {38, -20}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
      // Define hydrodynamic body
      Hydrodynamic.Forces.HydrodynamicBody hydrodynamicBody( /*enableHydrostaticForce = true, */enablePTOForce = true, enableRadiationForce = true,FileName=filePath.FileName) annotation(
        Placement(transformation(origin = {10, -20}, extent = {{-10, -10}, {10, 10}})));
      // Define wave and current bus
      WaveProfile.WaveAndCurrentBus waveAndCurrentBus annotation(
        Placement(transformation(origin = {68, -18}, extent = {{10, -10}, {-10, 10}}, rotation = -0)));
      // Define wave spectrum
      WaveProfile.IrregularWave.Bus_PiersonMoskowitzWave bus_PiersonMoskowitzWave(fileName=filePath.FileName) annotation(
        Placement(transformation(origin = {100, -18}, extent = {{10, -10}, {-10, 10}}, rotation = -0)));
    Forces.FilePath filePath annotation(
        Placement(transformation(origin = {132, -18}, extent = {{-10, -10}, {10, 10}})));
  Mooring.LinearMooring linearMooring annotation(
        Placement(transformation(origin = {4, -50}, extent = {{-10, -10}, {10, 10}})));
    equation
    // Connections
      connect(world.frame_b, prismatic.frame_a) annotation(
        Line(points = {{-30, -20}, {-24, -20}}, color = {95, 95, 95}));
      connect(hydrodynamicBody.frame_b, forceAndTorque.frame_b) annotation(
        Line(points = {{20, -20}, {28, -20}}));
      connect(prismatic.frame_b, hydrodynamicBody.frame_a) annotation(
        Line(points = {{-4, -20}, {0, -20}}, color = {95, 95, 95}));
      connect(waveAndCurrentBus.F, forceAndTorque.force) annotation(
        Line(points = {{58, -12}, {50, -12}, {50, -14}}, color = {0, 0, 127}, thickness = 0.5));
      connect(waveAndCurrentBus.T, forceAndTorque.torque) annotation(
        Line(points = {{58, -22}, {50, -22}, {50, -26}}, color = {0, 0, 127}, thickness = 0.5));
      connect(bus_PiersonMoskowitzWave.F, waveAndCurrentBus.Fw) annotation(
        Line(points = {{90, -18}, {80, -18}, {80, -10}}, color = {0, 0, 127}, thickness = 0.5));
      annotation(
        Icon(graphics = {Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Ellipse(extent = {{-20, 20}, {20, -20}}, lineColor = {0, 0, 0}, fillColor = {0, 0, 0}, fillPattern = FillPattern.Solid)}),
        Documentation(info = "<html>
          <p><b>1D Single-Body Wave Energy Converter (WEC) Model</b></p>
          <p>This model represents a simplified 1D single-body wave energy converter system, 
          focusing on the vertical motion of the body in response to wave excitation forces.</p>
          
          <p><b>Model Description</b></p>
          <p>The WEC consists of a hydrodynamic body constrained to move vertically using a prismatic joint. 
          The body is subjected to wave excitation forces generated by Regular (Linear) and Irregular (PM, Bretschneider, JONSWAP) wave profiles.</p>
          
          <p><b>Key Components</b></p>
          <ul>
            <li><code>world</code>: Defines the world coordinate system without gravity</li>
            <li><code>bodyHD6D</code>: Represents the hydrodynamic body of the WEC</li>
            <li><code>prismatic</code>: Allows vertical motion of the body</li>
            <li><code>Regular and Irregular Wave Profiles</code>: Generates regular and irregular wave excitation forces</li>
            <li><code>forceAndTorque</code>: Applies the excitation force to the body</li>
          </ul>
          
          <p><b>Assumptions and Simplifications</b></p>
          <ul>
            <li>The model considers only vertical motion (1D) of the WEC</li>
            <li>Gravity is not included in the world model</li>
            <li>The excitation force is applied as an external input based on the Pierson-Moskowitz or Regular wave profile</li>
          </ul>
          
          <p><b>Notes</b></p>
          <ul>
            <li>This model serves as a basic framework for WEC simulations and can be extended for more complex analyses</li>
            <li>Additional forces like radiation damping or PTO forces can be added to enhance the model's realism</li>
            <li>Ensure that the BodyHD6D component is properly configured for accurate results</li>
            <li>The wave parameters may need to be adjusted to represent specific sea states</li>
          </ul>
        </html>"),
        Diagram(coordinateSystem(extent = {{-80, 0}, {150, -40}})),
        experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
    
    

    end OOP_SingleBodyWECMooring;
    annotation(
      Icon(graphics = {Polygon(points = {{-40, 40}, {40, 0}, {-40, -40}, {-40, 40}}, lineColor = {0, 0, 0}, fillColor = // Red color for the polygon
      {0, 0, 0}, fillPattern = // Red fill
      FillPattern.Solid)}),
      Documentation(info = "<html>
        <p><b>Wave Energy Converter (WEC) Examples</b></p>
        <p>This package contains example models for Wave Energy Converter (WEC) systems. 
        It provides a set of ready-to-use models that demonstrate various aspects of WEC modeling and simulation.</p>
        
        <p><b>Package Contents</b></p>
        <ul>
          <li><b>SingleBodyWEC1D</b>: A 1D model of a single-body wave energy converter. The hydrodynamic data from the Toroidal Float of the US DoE RM-3</li>
        </ul>
        
        <p><b>Usage</b></p>
        <p>The models in this package can be used as starting points for more complex WEC simulations 
        or as educational tools to understand the basic principles of WEC modeling.</p>
        
        <p><b>See Also</b></p>
        <p>For more detailed information on individual models, please refer to their respective documentation.</p>
      </html>"));
  end Example;

  package Forces
    extends Modelica.Icons.Package;

    model HydrostaticForce6D "6-Dimensional Hydrostatic Force and Torque Calculation"
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.absolutePosition_con;
      extends Hydrodynamic.Connector.forceTorque_con;
      extends Hydrodynamic.Forces.readHydroCoeff;
      // Enable/disable force
      parameter Boolean enableHydrostaticForce = true "Switch to enable/disable hydrostatic force calculation";
      // Internal variables
      Real u_theta[6] "Combined displacement vector [m, rad]";
      Real fhs[6] "Hydrostatic force/torque vector [N, N*m]";
    equation
// Combine linear and angular displacements into a single vector
      u_theta = cat(1, u_abs, theta_abs);
// Calculate the 6D hydrostatic force/torque vector
      fhs = -Khs*u_theta;
// Use the switch to conditionally output the force and torque
      if enableHydrostaticForce then
        F = fhs;
      else
        F = zeros(6);
      end if;
      annotation(
        Documentation(info = "<html>
        <p>This block calculates the 6-dimensional hydrostatic force and torque for both translational and rotational motion in a fluid medium.</p>
        <p>The hydrostatic force/torque is calculated using linear restoring coefficients, where the force is proportional to the displacement from the equilibrium position.</p>
        <p>The block can be enabled or disabled using the <code>enableHydrostaticForce</code> parameter.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>u</code>: Linear displacement vector [m]</li>
          <li><code>theta</code>: Angular displacement vector [rad]</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>y</code>: Translational hydrostatic force vector [N]</li>
          <li><code>y1</code>: Rotational hydrostatic torque vector [N*m]</li>
        </ul>
        <p>Key Parameters:</p>
        <ul>
          <li><code>G1</code>, <code>G2</code>, <code>G3</code>: Translational hydrostatic restoring coefficients [N/m]</li>
          <li><code>G4</code>, <code>G5</code>, <code>G6</code>: Rotational hydrostatic restoring coefficients [N*m/rad]</li>
        </ul>
        <p>The hydrostatic restoring coefficients are combined into a diagonal matrix to allow for different coefficients in each dimension.</p>
        <p>Note: By default, only the z-axis translation (heave) has a non-zero restoring coefficient, which is typical for floating bodies.</p>
      </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "HS 6D", fontName = "Arial")}));
    end HydrostaticForce6D;

    model DragForce6D "6-Dimensional Drag Force and Torque Calculation"
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.absoluteVelocity_con;
      extends Hydrodynamic.Connector.forceTorque_con;
      // Fluid and reference parameters
      parameter Real rho "Density of fluid [kg/m^3]";
      parameter Real A "Reference area [m^2]";
      // Drag coefficients
      parameter Real Cdx "Translational drag coefficient for x-axis [-]";
      parameter Real Cdy "Translational drag coefficient for y-axis [-]";
      parameter Real Cdz "Translational drag coefficient for z-axis [-]";
      parameter Real Crx "Rotational drag coefficient for x-axis [-]";
      parameter Real Cry "Rotational drag coefficient for y-axis [-]";
      parameter Real Crz "Rotational drag coefficient for z-axis [-]";
      parameter Real Cd[6, 6] = diagonal({Cdx, Cdy, Cdz, Crx, Cry, Crz}) "Combined drag coefficient matrix";
      // Control parameter
      parameter Boolean enableDragForce = true "Switch to enable/disable drag force calculation";
      // Internal variables
      Real c "Combined constant term for drag calculation";
      Real fd[6] "6D drag force/torque vector [N, N*m]";
      Real v_omega[6] "Combined linear and angular velocity vector [m/s, rad/s]";
    equation
// Calculate the combined constant term
      c = 0.5*rho*A;
// Combine linear and angular velocities into a single vector
      v_omega = cat(1, v_abs, omega_abs);
// Calculate the 6D drag force/torque vector
      fd = -c*Cd*v_omega.*abs(v_omega);
// Use the switch to conditionally output the force and torque
      if enableDragForce then
        F = fd[1:3];
      else
        F = zeros(6);
      end if;
      annotation(
        Documentation(info = "<html>
        <p>This block calculates the 6-dimensional drag force and torque for both translational and rotational motion in a fluid medium.</p>
        <p>The drag force/torque is calculated using a quadratic drag model, where the force is proportional to the square of the velocity.</p>
        <p>The block can be enabled or disabled using the <code>enableDragForce</code> parameter.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>u</code>: Linear velocity vector [m/s]</li>
          <li><code>a</code>: Angular velocity vector [rad/s]</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>y</code>: Translational drag force vector [N]</li>
          <li><code>y1</code>: Rotational drag torque vector [N*m]</li>
        </ul>
        <p>Key Parameters:</p>
        <ul>
          <li><code>rho</code>: Fluid density [kg/m^3]</li>
          <li><code>A</code>: Reference area [m^2]</li>
          <li><code>Cdx</code>, <code>Cdy</code>, <code>Cdz</code>: Translational drag coefficients [-]</li>
          <li><code>Crx</code>, <code>Cry</code>, <code>Crz</code>: Rotational drag coefficients [-]</li>
        </ul>
        <p>The drag coefficients are combined into a diagonal matrix to allow for different coefficients in each dimension.</p>
      </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "Drag F 6D", fontName = "Arial")}));
    end DragForce6D;

    block PTO6D "Power Take-Off (PTO) force"
      extends Hydrodynamic.readHydroParam;
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.absolutePosition_con;
      extends Hydrodynamic.Connector.absoluteVelocity_con;
      extends Hydrodynamic.Connector.forceTorque_con;
      parameter Modelica.Units.SI.AngularFrequency omega_peak "Peak spectral frequency";
      Modelica.Units.SI.Mass amdep = Modelica.Math.Vectors.interpolate(w, Adep, omega_peak);
      Modelica.Units.SI.TranslationalDampingConstant Bpto = Modelica.Math.Vectors.interpolate(w, Rdamp, omega_peak);
      Modelica.Units.SI.TranslationalSpringConstant Kpto;
      Modelica.Units.SI.Mass Mpto;
      //Modelica.Units.SI.Force Fpto;
      //Modelica.Units.SI.Power Ppto;
      //Modelica.Blocks.Math.ContinuousMean Ppto_avg;
      // Proportional gain parameters
      parameter Real Kpx "Proportional gain for x-axis translation [N/(m/s)]";
      parameter Real Kpy "Proportional gain for y-axis translation [N/(m/s)]";
      Real Kpz "Proportional gain for z-axis translation [N/(m/s)]";
      parameter Real Kprx "Proportional gain for x-axis rotation [N*m/(rad/s)]";
      parameter Real Kpry "Proportional gain for y-axis rotation [N*m/(rad/s)]";
      parameter Real Kprz "Proportional gain for z-axis rotation [N*m/(rad/s)]";
      Real Kp[6, 6] "Combined proportional gain matrix";
      // Integral gain parameters
      parameter Real Kix "Integral gain for x-axis translation [N/m]";
      parameter Real Kiy "Integral gain for y-axis translation [N/m]";
      Real Kiz "Integral gain for z-axis translation [N/m]";
      parameter Real Kirx "Integral gain for x-axis rotation [N*m/rad]";
      parameter Real Kiry "Integral gain for y-axis rotation [N*m/rad]";
      parameter Real Kirz "Integral gain for z-axis rotation [N*m/rad]";
      Real Ki[6, 6] "Combined integral gain matrix";
      // Control parameter
      parameter Boolean enablePTOForce = true "Switch to enable/disable PTO force calculation";
      // Internal variable
      Real fpto[6] "Combined PTO force/torque vector [N, N*m]";
      Real u_theta[6] "Combined displacement vector [m, rad]";
      Real v_omega[6] "Combined linear and angular velocity vector [m/s, rad/s]";
      Real bpto;
      parameter String controllerSelect = "reactive" annotation(
        Dialog(group = "Controller type select"));
    equation
      Kiz = Kpto;
      Kp = diagonal({Kpx, Kpy, Kpz, Kprx, Kpry, Kprz});
      Kpz = bpto;
      Ki = diagonal({Kix, Kiy, Kiz, Kirx, Kiry, Kirz});
      u_theta = cat(1, u_abs, theta_abs);
      v_omega = cat(1, v_abs, omega_abs);
// Calculate the combined PTO force/torque vector
      fpto = Kp*v_omega + Ki*u_theta;
      Mpto = M + amdep;
// Use the switch to conditionally output the force and torque
      if enablePTOForce then
        F = -fpto;
      else
        F = zeros(6);
      end if;
      if controllerSelect == "passive" then
        Kpto = 0;
        bpto = (Bpto^2 + (omega_peak*(Mpto) - Khs/omega_peak)^2)^(1/2);
      elseif controllerSelect == "reactive" then
        Kpto = (Mpto)*omega_peak - Khs/omega_peak;
// no khs in here
        bpto = Bpto;
      end if;
      annotation(
        Documentation(info = "<html>
        <p>This block models a 6-dimensional Power Take-Off (PTO) system for both translational and rotational motion.</p>
        <p>The PTO force/torque is calculated using a combination of proportional and integral control based on the input velocities and displacements.</p>
        <p>The block can be enabled or disabled using the <code>enablePTOForce</code> parameter.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>u</code>: Linear velocity vector [m/s]</li>
          <li><code>s</code>: Linear displacement vector [m]</li>
          <li><code>omega</code>: Angular velocity vector [rad/s]</li>
          <li><code>theta</code>: Angular displacement vector [rad]</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>y</code>: Translational PTO force vector [N]</li>
          <li><code>y1</code>: Rotational PTO torque vector [N*m]</li>
        </ul>
      </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "PTO 6D", fontName = "Arial")}));
    end PTO6D;

    model HydrodynamicBlock6D "6-Dimensional Hydrodynamic Forces and Moments Calculation"
      extends Hydrodynamic.readHydroParam;
      extends Modelica.Units.SI;
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.inputOutput_con;
      // Parameters for BodyShape
      parameter Position r[3] = {0, 0, 0} "Position vector" annotation(
        Dialog(group = "Body"));
      parameter Position r_CM[3] = {0, 0, 0} "Center of mass position vector" annotation(
        Dialog(group = "Body"));
      parameter Position length = 0.1 "Length of the body" annotation(
        Dialog(group = "Body"));
      parameter Position width = 0.1 "Width of the body" annotation(
        Dialog(group = "Body"));
      parameter Position height = 0.1 "Height of the body" annotation(
        Dialog(group = "Body"));
      parameter Inertia I_11 = 0.001 "Element (1,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Inertia I_22 = 0.001 "Element (2,2) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Inertia I_33 = 0.001 "Element (3,3) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Inertia I_21 = 0 "Element (2,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Inertia I_31 = 0 "Element (3,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Inertia I_32 = 0 "Element (3,2) of inertia tensor" annotation(
        Dialog(group = "Body"));
      Modelica.Mechanics.MultiBody.Parts.BodyShape bodyShape(r = r, r_CM = r_CM, m = m, length = length, width = width, height = height, I_11 = I_11, I_22 = I_22, I_33 = I_33, I_21 = I_21, I_31 = I_31, I_32 = I_32) annotation(
        Placement(transformation(origin = {10, -84}, extent = {{-10, -10}, {10, 10}})));
      // Parameters for HydrostaticForce6D
      parameter Boolean enableHydrostaticForce = true "Switch to enable/disable hydrostatic force calculation" annotation(
        Dialog(group = "Hydrostatic Stiffness Parameters"));
      HydrostaticForce6D hydrostaticForce6D(enableHydrostaticForce = enableHydrostaticForce) "Hydrostatic force calculation" annotation(
        Placement(transformation(origin = {16, -20}, extent = {{-10, -10}, {10, 10}})));
      parameter Boolean enableRadiationForce = true "Switch to enable/disable 6D radiation force calculation" annotation(
        Dialog(group = "Radiation Force Parameters"));
      // HydrodynamicBlock6D components and connections
      // Parameters for PTO6D
      parameter Boolean enablePTOForce = false "Switch to enable/disable PTO force calculation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter String controllerSelect = "reactive" "Controller type select" annotation(
        Dialog(group = "PTO Parameters"));
      parameter AngularFrequency omega_peak = 0.9423 "Peak spectral frequency" annotation(
        Dialog(group = "PTO Parameters"));
      parameter Real Kpx = 0.0 "Proportional gain for x-axis translation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter Real Kpy = 0.0 "Proportional gain for y-axis translation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter Real Kprx = 0.0 "Proportional gain for x-axis rotation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter Real Kpry = 0.0 "Proportional gain for y-axis rotation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter Real Kprz = 0.0 "Proportional gain for z-axis rotation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter TranslationalSpringConstant Kix = 0.0 "Integral gain for x-axis translation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter TranslationalSpringConstant Kiy = 0.0 "Integral gain for y-axis translation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter RotationalSpringConstant Kirx = 0.0 "Integral gain for x-axis rotation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter RotationalSpringConstant Kiry = 0.0 "Integral gain for y-axis rotation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter RotationalSpringConstant Kirz = 0.0 "Integral gain for z-axis rotation" annotation(
        Dialog(group = "PTO Parameters"));
      // PTO components
      PTO6D pto6d(omega_peak = omega_peak, Kpx = Kpx, Kpy = Kpy, Kprx = Kprx, Kpry = Kpry, Kprz = Kprz, Kix = Kix, Kiy = Kiy, Kirx = Kirx, Kiry = Kiry, Kirz = Kirz, enablePTOForce = enablePTOForce, controllerSelect = controllerSelect) "Power Take-Off force calculation" annotation(
        Placement(transformation(origin = {16, -46}, extent = {{-10, -10}, {10, 10}})));
      // Parameters for DragForce6D
      parameter Boolean enableDragForce = false "Switch to enable/disable drag force calculation" annotation(
        Dialog(group = "Drag Parameters"));
      parameter MassConcentration rho = 1000 "Density of fluid" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Area A1 = 1 "Reference area" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Real Cdx = 100 "Translational drag coefficient for x-axis" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Real Cdy = 0.01 "Translational drag coefficient for y-axis" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Real Cdz = 100 "Translational drag coefficient for z-axis" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Real Crx = 100 "Rotational drag coefficient for x-axis" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Real Cry = 0.01 "Rotational drag coefficient for y-axis" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Real Crz = 100 "Rotational drag coefficient for z-axis" annotation(
        Dialog(group = "Drag Parameters"));
      // Drag force components
      DragForce6D dragForce6D(rho = rho, A = A1, Cdx = Cdx, Cdy = Cdy, Cdz = Cdz, Crx = Crx, Cry = Cry, Crz = Crz, enableDragForce = enableDragForce) "Drag force calculation" annotation(
        Placement(transformation(origin = {16, 24}, extent = {{-10, -10}, {10, 10}})));
      // Force and torque application components
      ForceToqueSum forceToqueSum annotation(
        Placement(transformation(origin = {50, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque forceAndTorque annotation(
        Placement(transformation(origin = {82, 0}, extent = {{-10, 10}, {10, -10}}, rotation = -0)));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteSensor absoluteSensor(get_r = true, get_v = true, get_a = false, get_z = false, get_angles = true, get_w = true) annotation(
        Placement(transformation(origin = {-61, 1}, extent = {{-11, -11}, {11, 11}})));
      RadiationForce6D radiationForce6D annotation(
        Placement(transformation(origin = {18, 64}, extent = {{-10, -10}, {10, 10}})));
    equation
      connect(bodyShape.frame_a, frame_a) annotation(
        Line(points = {{0, -84}, {-102, -84}, {-102, 0}}, color = {95, 95, 95}));
      connect(bodyShape.frame_b, frame_b) annotation(
        Line(points = {{20, -84}, {102, -84}, {102, 0}}, color = {95, 95, 95}));
      connect(forceAndTorque.frame_b, bodyShape.frame_b) annotation(
        Line(points = {{92, 0}, {92, -84}, {20, -84}}, color = {95, 95, 95}));
      connect(forceToqueSum.F, forceAndTorque.force) annotation(
        Line(points = {{61, 5}, {64, 5}, {64, 6}, {70, 6}}, color = {0, 0, 127}, thickness = 0.5));
      connect(forceToqueSum.T, forceAndTorque.torque) annotation(
        Line(points = {{61, -5}, {70, -5}, {70, -6}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.w, dragForce6D.omega_abs) annotation(
        Line(points = {{-54, -11}, {-72, -11}, {-72, 16}, {4, 16}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.w, pto6d.omega_abs) annotation(
        Line(points = {{-54, -12}, {-72, -12}, {-72, -54}, {4, -54}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.r, pto6d.u_abs) annotation(
        Line(points = {{-72, -12}, {-72, -38}, {4, -38}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.angles, pto6d.theta_abs) annotation(
        Line(points = {{-58, -12}, {-72, -12}, {-72, -44}, {4, -44}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.v, pto6d.v_abs) annotation(
        Line(points = {{-68, -12}, {-72, -12}, {-72, -48}, {4, -48}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.v, dragForce6D.v_abs) annotation(
        Line(points = {{-68, -12}, {-72, -12}, {-72, 22}, {4, 22}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.r, hydrostaticForce6D.u_abs) annotation(
        Line(points = {{-72, -12}, {4, -12}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.angles, hydrostaticForce6D.theta_abs) annotation(
        Line(points = {{-58, -12}, {-4, -12}, {-4, -18}, {4, -18}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.frame_a, bodyShape.frame_b) annotation(
        Line(points = {{-72, 2}, {-86, 2}, {-86, -68}, {20, -68}, {20, -84}}, color = {95, 95, 95}));
      connect(dragForce6D.F, forceToqueSum.Fd) annotation(
        Line(points = {{27, 24}, {30, 24}, {30, -2}, {38, -2}}, color = {0, 0, 127}, thickness = 0.5));
      connect(pto6d.F, forceToqueSum.Fpto) annotation(
        Line(points = {{28, -46}, {30, -46}, {30, -8}, {38, -8}}, color = {0, 0, 127}, thickness = 0.5));
      connect(hydrostaticForce6D.F, forceToqueSum.Fhs) annotation(
        Line(points = {{28, -20}, {30, -20}, {30, 2}, {38, 2}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.v, radiationForce6D.v_abs) annotation(
        Line(points = {{-68, -12}, {-70, -12}, {-70, 62}, {6, 62}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.w, radiationForce6D.omega_abs) annotation(
        Line(points = {{-54, -12}, {-48, -12}, {-48, 56}, {6, 56}}, color = {0, 0, 127}, thickness = 0.5));
      connect(radiationForce6D.F, forceToqueSum.Fr) annotation(
        Line(points = {{30, 64}, {38, 64}, {38, 8}}, color = {0, 0, 127}, thickness = 0.5));
      annotation(
        Diagram,
        Documentation(info = "<html>
        <p>This model calculates and applies 6-dimensional hydrodynamic forces and moments to a multibody system.</p>
        <p>It incorporates the following hydrodynamic effects:</p>
        <ul>
          <li>Drag forces and torques</li>
          <li>Power Take-Off (PTO) forces and torques</li>
          <li>Hydrostatic forces and torques</li>
          <li>Radiation forces</li>
        </ul>
        <p>The model uses absolute position, velocity, and angular sensors to determine the body's state, 
        calculates the various hydrodynamic forces, and applies them to the body.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>frame_a</code>: Input frame for body state</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>frame_b</code>: Output frame with applied hydrodynamic forces and torques</li>
        </ul>
        <p>Note: Some force components (e.g., drag and PTO) are disabled by default and can be enabled by modifying the respective parameters.</p>
      </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "HD Block 6D", fontName = "Arial")}));
    end HydrodynamicBlock6D;

    model RadiationForce6D
      extends Hydrodynamic.Forces.readHydroCoeff;
      extends Hydrodynamic.Connector.forceTorque_con;
      extends Hydrodynamic.Connector.absoluteVelocity_con;
      Real x[n_states[2]] "State vector for 1D radiation force model";
      Real F_rad[6] "6D radiation force [N]";
      Real v_omega[6];
      parameter Boolean enableRadiationForce = true "Switch to enable/disable 1D radiation force calculation";
    initial equation
      x = zeros(n_states[2]) "Initialize state vector to zero";
    equation
      v_omega = cat(1, v_abs, omega_abs);
// 1D Radiation force state-space model
// Note: Only the third element of the velocity vector (vertical motion) is used
      der(x) = A*x + B*v_omega;
      F_rad = C*x + D*v_omega;
// Output: 1D radiation force only in the third element (vertical direction), with enable/disable switch
      if enableRadiationForce then
        F = -F_rad;
      else
        F = {0, 0, 0, 0, 0, 0};
      end if;
    end RadiationForce6D;

    model readHydroCoeff "No longer needed, keeping for use in SingleBodyWEC1D"
      parameter String fileName = "C:/Users/Thomas/Documents/GitHub/OET_6DoF/hydroCoeff_6DoF.mat" annotation(
        Dialog(group = "Filepath"));
    protected
      parameter Modelica.Units.SI.Density rho = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.parameters.rho", 1, 1)) "Density of seawater [kg/m^3]" annotation(
        Dialog(group = "Environmental Parameters"));
      parameter Real nDoF_read = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.body.ndof", 1, 1)) "Degrees-of-Freedom";
      parameter Integer nDoF = integer(nDoF_read) "Degrees-of-Freedom";
      parameter Real n_stateSpace[nDoF, nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad.order", nDoF, nDoF) "State-space approximation for each mode";
      parameter Integer n_states[2] = Modelica.Utilities.Streams.readMatrixSize(fileName, "hydroCoeff.ss_rad.processed.A") "Number of states in the radiation state space approximation";
      parameter Real A[n_states[1], n_states[1]] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad.processed.A", n_states[1], n_states[1]) "State matrix";
      parameter Real B[n_states[1], nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad.processed.B", n_states[1], nDoF) "Input matrix";
      parameter Real C[nDoF, n_states[1]] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad.processed.C", nDoF, n_states[1]) "Output matrix";
      parameter Real D[nDoF, nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad.processed.D", nDoF, nDoF) "Feedforward matrix";
      parameter Modelica.Units.SI.Mass M = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.hydroCoefficients.m", 1, 1)) "Total mass of the body (including ballast)";
      parameter Modelica.Units.SI.Mass Ainf[nDoF, nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.hydroCoefficients.Ainf", nDoF, nDoF) "Added mass at maximum (cut-off) frequency";
      parameter Modelica.Units.SI.TranslationalSpringConstant Khs[nDoF, nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.hydroCoefficients.Khs", nDoF, nDoF) "Hydrostatic stiffness";
      parameter Real F_excRe[nDoF, :] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.excitation.FexcRe", nDoF, wDim[1]) "Real part of excitation force coefficients";
      parameter Real F_excIm[nDoF, :] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.excitation.FexcIm", nDoF, wDim[1]) "Imaginary part of excitation force coefficients";
      parameter Integer wDim[2] = Modelica.Utilities.Streams.readMatrixSize(fileName, "hydroCoeff.excitation.w") "Dimensions of the frequency vector";
      parameter Real w[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.excitation.w", wDim[1], 1)) "Angular frequency vector [rad/s]";
    end readHydroCoeff;

    model HydrodynamicBody "6-Dimensional Hydrodynamic Forces and Moments Calculation"
      // Inheritance
      extends Hydrodynamic.Connector.inputOutput_con;
      //extends Hydrodynamic.HydroDataImport.massData;
      /* This should be removed from here and included in the definition of the body in HydrodynamicBody, but is okay in the interim */
      // BodyShape parameters
      parameter String FileName;
      
      /* Removing mass definition here and adding it to a custom bodyShape model
      parameter Modelica.Units.SI.Mass m = M + Ainf[3, 3] "Mass of the body" annotation(
        Dialog(group = "Body")); /*
      /* The mass is only valid when motion is constrained in heave. This line is also repeated in the PTO force code base to determine the control gain */
      parameter Modelica.Units.SI.Position r[3] = {0, 0, 0} "Position vector" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Position r_CM[3] = {0, 0, 0} "Center of mass position vector" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_11 = 0.001 "Element (1,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_22 = 0.001 "Element (2,2) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_33 = 0.001 "Element (3,3) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_21 = 0 "Element (2,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_31 = 0 "Element (3,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_32 = 0 "Element (3,2) of inertia tensor" annotation(
        Dialog(group = "Body"));
      Hydrodynamic.Forces.BodyShape bodyShape(r = r, r_CM = {0, 0, -0.72}, /*m = m,*/ I_11 = I_11, I_22 = I_22, I_33 = I_33, I_21 = I_21, I_31 = I_31, I_32 = I_32,fileName=FileName) annotation(
        Placement(transformation(origin = {10, -84}, extent = {{-10, -10}, {10, 10}})));
      // Hydrostatic force parameters
      parameter Boolean enableHydrostaticForce = true "Switch to enable/disable hydrostatic force calculation" annotation(
        Dialog(group = "Hydrostatic Force Parameters"));
      Hydrodynamic.Forces.HydrostaticForce hydrostaticForce(enableHydrostaticForce = enableHydrostaticForce,fileName=FileName) "Hydrostatic force calculation" annotation(
        Placement(transformation(origin = {16, -20}, extent = {{-10, -10}, {10, 10}})));
      // Radiation force paramters
      parameter Boolean enableRadiationForce = true "Switch to enable/disable 6D radiation force calculation" annotation(
        Dialog(group = "Radiation Force Parameters"));
      Hydrodynamic.Forces.RadiationForce radiationForce(fileName=FileName) annotation(
        Placement(transformation(origin = {18, 64}, extent = {{-10, -10}, {10, 10}})));
      // PTO force parameters
      parameter Boolean enablePTOForce = true "Switch to enable/disable PTO force calculation" annotation(
        Dialog(group = "PTO Force Parameters"));
      parameter String controllerSelect = "reactive" "Controller type select" annotation(
        Dialog(group = "PTO Force Parameters"));
      Hydrodynamic.Forces.PTOForce ptoForce( /*omega_peak = omega_peak, Kpx = Kpx, Kpy = Kpy, Kprx = Kprx, Kpry = Kpry, Kprz = Kprz, Kix = Kix, Kiy = Kiy, Kirx = Kirx, Kiry = Kiry, Kirz = Kirz, */enablePTOForce = enablePTOForce, controllerSelect = controllerSelect,fileName=FileName) "PTO force calculation" annotation(
        Placement(transformation(origin = {16, -46}, extent = {{-10, -10}, {10, 10}})));
      /* 
            parameter Real Kpx = 0.0 "Proportional gain for x-axis translation" annotation(
              Dialog(group = "PTO Parameters"));
            parameter Real Kpy = 0.0 "Proportional gain for y-axis translation" annotation(
              Dialog(group = "PTO Parameters"));
            parameter Real Kprx = 0.0 "Proportional gain for x-axis rotation" annotation(
              Dialog(group = "PTO Parameters"));
            parameter Real Kpry = 0.0 "Proportional gain for y-axis rotation" annotation(
              Dialog(group = "PTO Parameters"));
            parameter Real Kprz = 0.0 "Proportional gain for z-axis rotation" annotation(
              Dialog(group = "PTO Parameters"));
            parameter TranslationalSpringConstant Kix = 0.0 "Integral gain for x-axis translation" annotation(
              Dialog(group = "PTO Parameters"));
            parameter TranslationalSpringConstant Kiy = 0.0 "Integral gain for y-axis translation" annotation(
              Dialog(group = "PTO Parameters"));
            parameter RotationalSpringConstant Kirx = 0.0 "Integral gain for x-axis rotation" annotation(
              Dialog(group = "PTO Parameters"));
            parameter RotationalSpringConstant Kiry = 0.0 "Integral gain for y-axis rotation" annotation(
              Dialog(group = "PTO Parameters"));
            parameter RotationalSpringConstant Kirz = 0.0 "Integral gain for z-axis rotation" annotation(
              Dialog(group = "PTO Parameters"));
          */
      // Drag force parameters
      parameter Boolean enableDampingDragForce = false "Switch to enable/disable drag force calculation" annotation(
        Dialog(group = "Damping and Drag Force Parameters"));
      parameter Modelica.Units.SI.Area Ac = 1 "Reference area" annotation(
        Dialog(group = "Damping and Drag Force Parameters"));
      parameter Real Cdx = 100 "Translational drag coefficient for x-axis" annotation(
        Dialog(group = "Damping and Drag Force Parameters"));
      parameter Real Cdy = 0.01 "Translational drag coefficient for y-axis" annotation(
        Dialog(group = "Damping and Drag Force Parameters"));
      parameter Real Cdz = 100 "Translational drag coefficient for z-axis" annotation(
        Dialog(group = "Damping and Drag Force Parameters"));
      parameter Real Crx = 100 "Rotational drag coefficient for x-axis" annotation(
        Dialog(group = "Damping and Drag Force Parameters"));
      parameter Real Cry = 0.01 "Rotational drag coefficient for y-axis" annotation(
        Dialog(group = "Damping and Drag Force Parameters"));
      parameter Real Crz = 100 "Rotational drag coefficient for z-axis" annotation(
        Dialog(group = "Damping and Drag Force Parameters"));
      Hydrodynamic.Forces.DampingDragForce dampingDragForce(Ac = Ac, Cdx = Cdx, Cdy = Cdy, Cdz = Cdz, Crx = Crx, Cry = Cry, Crz = Crz, enableDampingDragForce = enableDampingDragForce,fileName=FileName) "Drag force calculation" annotation(
        Placement(transformation(origin = {16, 24}, extent = {{-10, -10}, {10, 10}})));
      // Force and torque blocks
      ForceToqueSum forceToqueSum annotation(
        Placement(transformation(origin = {50, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque forceAndTorque annotation(
        Placement(transformation(origin = {82, 0}, extent = {{-10, 10}, {10, -10}}, rotation = -0)));
      // Absolute sensor
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteSensor absoluteSensor(get_r = true, get_v = true, get_a = true, get_z = true, get_angles = true, get_w = true) annotation(
        Placement(transformation(origin = {-61, 1}, extent = {{-11, -11}, {11, 11}})));
    equation
//Conections
      connect(bodyShape.frame_a, frame_a) annotation(
        Line(points = {{0, -84}, {-102, -84}, {-102, 0}}, color = {95, 95, 95}));
      connect(bodyShape.frame_b, frame_b) annotation(
        Line(points = {{20, -84}, {102, -84}, {102, 0}}, color = {95, 95, 95}));
      connect(forceAndTorque.frame_b, bodyShape.frame_b) annotation(
        Line(points = {{92, 0}, {92, -84}, {20, -84}}, color = {95, 95, 95}));
      connect(forceToqueSum.F, forceAndTorque.force) annotation(
        Line(points = {{61, 5}, {64, 5}, {64, 6}, {70, 6}}, color = {0, 0, 127}, thickness = 0.5));
      connect(forceToqueSum.T, forceAndTorque.torque) annotation(
        Line(points = {{61, -5}, {70, -5}, {70, -6}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.w, dampingDragForce.omega_abs) annotation(
        Line(points = {{-54, -11}, {-72, -11}, {-72, 16}, {4, 16}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.w, ptoForce.omega_abs) annotation(
        Line(points = {{-54, -12}, {-72, -12}, {-72, -54}, {4, -54}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.r, ptoForce.u_abs) annotation(
        Line(points = {{-72, -12}, {-72, -38}, {4, -38}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.angles, ptoForce.theta_abs) annotation(
        Line(points = {{-58, -12}, {-72, -12}, {-72, -44}, {4, -44}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.v, ptoForce.v_abs) annotation(
        Line(points = {{-68, -12}, {-72, -12}, {-72, -48}, {4, -48}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.v, dampingDragForce.v_abs) annotation(
        Line(points = {{-68, -12}, {-72, -12}, {-72, 22}, {4, 22}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.r, hydrostaticForce.u_abs) annotation(
        Line(points = {{-72, -12}, {4, -12}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.angles, hydrostaticForce.theta_abs) annotation(
        Line(points = {{-58, -12}, {-4, -12}, {-4, -18}, {4, -18}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.frame_a, bodyShape.frame_b) annotation(
        Line(points = {{-72, 2}, {-86, 2}, {-86, -68}, {20, -68}, {20, -84}}, color = {95, 95, 95}));
      connect(dampingDragForce.F, forceToqueSum.Fd) annotation(
        Line(points = {{27, 24}, {30, 24}, {30, -2}, {38, -2}}, color = {0, 0, 127}, thickness = 0.5));
      connect(ptoForce.F, forceToqueSum.Fpto) annotation(
        Line(points = {{28, -46}, {30, -46}, {30, -8}, {38, -8}}, color = {0, 0, 127}, thickness = 0.5));
      connect(hydrostaticForce.F, forceToqueSum.Fhs) annotation(
        Line(points = {{28, -20}, {30, -20}, {30, 2}, {38, 2}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.v, radiationForce.v_abs) annotation(
        Line(points = {{-68, -12}, {-70, -12}, {-70, 62}, {6, 62}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.w, radiationForce.omega_abs) annotation(
        Line(points = {{-54, -12}, {-48, -12}, {-48, 56}, {6, 56}}, color = {0, 0, 127}, thickness = 0.5));
      connect(radiationForce.F, forceToqueSum.Fr) annotation(
        Line(points = {{30, 64}, {38, 64}, {38, 8}}, color = {0, 0, 127}, thickness = 0.5));
      annotation(
        Diagram,
        Documentation(info = "<html>
        <p>This model calculates and applies 6-dimensional hydrodynamic forces and moments to a multibody system.</p>
        <p>It incorporates the following hydrodynamic effects:</p>
        <ul>
          <li>Drag forces and torques</li>
          <li>Power Take-Off (PTO) forces and torques</li>
          <li>Hydrostatic forces and torques</li>
          <li>Radiation forces</li>
        </ul>
        <p>The model uses absolute position, velocity, and angular sensors to determine the body's state, 
        calculates the various hydrodynamic forces, and applies them to the body.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>frame_a</code>: Input frame for body state</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>frame_b</code>: Output frame with applied hydrodynamic forces and torques</li>
        </ul>
        <p>Note: Some force components (e.g., drag and PTO) are disabled by default and can be enabled by modifying the respective parameters.</p>
      </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "HD Block 6D", fontName = "Arial")}));
    end HydrodynamicBody;

    block PTOForce "Power Take-Off (PTO) force"
      /* The code has not been refined, work needs to be done on fully importing the 260x6x6 frequency dependent data, selecting which mode is being excited and which is responding, remove control gains as parameters, and integrate power metrics */
      // Inheritance
      extends Hydrodynamic.Models.positionSensorInput;
      // position input and concatenation
      extends Hydrodynamic.Models.velocitySensorInput;
      // velocity input and concatenation
      extends Hydrodynamic.Models.forceTorque;
      // force declaration and output
      extends Hydrodynamic.HydroDataImport.ptoData;
      // PTO parameters
      extends Hydrodynamic.HydroDataImport.hydrostaticData;
      // hydrostatic data
      // Enable/disable PTO force
      parameter Boolean enablePTOForce = true "Switch to enable/disable PTO force calculation" annotation(
        Dialog(group = "PTO Force Parameters"));
      // Select controller
      parameter String controllerSelect = "reactive" annotation(
        Dialog(group = "PTO Force Parameters"));
      // User input peak spectral frequency
      parameter Modelica.Units.SI.AngularFrequency PTO_omega_peak = 0.9423 "Peak spectral frequency" annotation(
        Dialog(group = "PTO Force Parameters"));
      // PTO power variables (not currently enabled)
      //Modelica.Units.SI.Power Ppto;
      //Modelica.Blocks.Math.ContinuousMean Ppto_avg;
      // Proportional gain parameters
      parameter Real Kpx = 0"Proportional gain for x-axis translation [N/(m/s)]";
      parameter Real Kpy = 0"Proportional gain for y-axis translation [N/(m/s)]";
      Real Kpz "Proportional gain for z-axis translation [N/(m/s)]";
      parameter Real Kprx = 0"Proportional gain for x-axis rotation [N*m/(rad/s)]";
      parameter Real Kpry = 0"Proportional gain for y-axis rotation [N*m/(rad/s)]";
      parameter Real Kprz = 0"Proportional gain for z-axis rotation [N*m/(rad/s)]";
      Real Kp[6, 6] "Combined proportional gain matrix";
      // Integral gain parameters
      parameter Real Kix = 0"Integral gain for x-axis translation [N/m]";
      parameter Real Kiy = 0"Integral gain for y-axis translation [N/m]";
      Real Kiz "Integral gain for z-axis translation [N/m]";
      parameter Real Kirx = 0"Integral gain for x-axis rotation [N*m/rad]";
      parameter Real Kiry = 0"Integral gain for y-axis rotation [N*m/rad]";
      parameter Real Kirz = 0 "Integral gain for z-axis rotation [N*m/rad]";
      Real Ki[6, 6] "Combined integral gain matrix";
    protected
      // Frequency dependent added mass at the peak spectral frequency
      Modelica.Units.SI.Mass Adep_interp = Modelica.Math.Vectors.interpolate(w, Adep, PTO_omega_peak);
      // Radiation damping at the peak spectral frequency
      Modelica.Units.SI.TranslationalDampingConstant Bpto = Modelica.Math.Vectors.interpolate(w, Rdamp, PTO_omega_peak);
      // Intermediate calculations
      Modelica.Units.SI.TranslationalSpringConstant Kpto;
      Modelica.Units.SI.Mass Mpto;
      Modelica.Units.SI.TranslationalDampingConstant bpto;
    equation
// Setting intermediate PTO parameters (heave excitation and response)
      Kiz = Kpto;
      Kp = diagonal({Kpx, Kpy, Kpz, Kprx, Kpry, Kprz});
      Kpz = bpto;
      Ki = diagonal({Kix, Kiy, Kiz, Kirx, Kiry, Kirz});
// Use the switch to conditionally output the force and torque
      if enablePTOForce then
// Calculate the combined PTO force/torque vector
        f = Kp*velocity + Ki*displacement;
        Mpto = M + Adep_interp;
        /* when this parameter was defined (unlike 6D case) the infinite frequency added mass
        was not subtracted from in the preprocessing, so only need to add the body mass for this computation */
        
      else
        f = zeros(6);
        Mpto = 0;
      end if;
      
       F = -f;
      
      if controllerSelect == "passive" then
        Kpto = 0;
        bpto = (Bpto^2 + (PTO_omega_peak*(Mpto) - Khs[3, 3]/PTO_omega_peak)^2)^(1/2);
      elseif controllerSelect == "reactive" then
        Kpto = (Mpto)*PTO_omega_peak - Khs[3, 3]/PTO_omega_peak;
        bpto = Bpto;
      end if;
      annotation(
        Documentation(info = "<html>
        <p>This block models a 6-dimensional Power Take-Off (PTO) system for both translational and rotational motion.</p>
        <p>The PTO force/torque is calculated using a combination of proportional and integral control based on the input velocities and displacements.</p>
        <p>The block can be enabled or disabled using the <code>enablePTOForce</code> parameter.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>u</code>: Linear velocity vector [m/s]</li>
          <li><code>s</code>: Linear displacement vector [m]</li>
          <li><code>omega</code>: Angular velocity vector [rad/s]</li>
          <li><code>theta</code>: Angular displacement vector [rad]</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>y</code>: Translational PTO force vector [N]</li>
          <li><code>y1</code>: Rotational PTO torque vector [N*m]</li>
        </ul>
      </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "PTO 6D", fontName = "Arial")}));
    end PTOForce;

    model HydrostaticForce "Hydrostatic Force and Torque Calculation"
      // Inheritance
      extends Hydrodynamic.Models.positionSensorInput;
      // position input and concatenation
      extends Hydrodynamic.Models.forceTorque;
      // force declaration and output
      extends Hydrodynamic.HydroDataImport.hydrostaticData;
      // hydrostatic parameters
      // Enable/disable hydrostatic force
      parameter Boolean enableHydrostaticForce = true "Switch to enable/disable hydrostatic force calculation" annotation(
        Dialog(group = "Hydrostatic Force Parameters"));
    equation
// Use the switch to conditionally output the hydrostatic force torque element
      if enableHydrostaticForce then
// Calculate the  hydrostatic force/torque vector
        f = Khs*displacement;
      else
        f = zeros(6);
      end if;
      
      F = -f;
      
      annotation(
        Documentation(info = "<html>
        <p>This block calculates the 6-dimensional hydrostatic force and torque for both translational and rotational motion in a fluid medium.</p>
        <p>The hydrostatic force/torque is calculated using linear restoring coefficients, where the force is proportional to the displacement from the equilibrium position.</p>
        <p>The block can be enabled or disabled using the <code>enableHydrostaticForce</code> parameter.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>u</code>: Linear displacement vector [m]</li>
          <li><code>theta</code>: Angular displacement vector [rad]</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>y</code>: Translational hydrostatic force vector [N]</li>
          <li><code>y1</code>: Rotational hydrostatic torque vector [N*m]</li>
        </ul>
        <p>Key Parameters:</p>
        <ul>
          <li><code>G1</code>, <code>G2</code>, <code>G3</code>: Translational hydrostatic restoring coefficients [N/m]</li>
          <li><code>G4</code>, <code>G5</code>, <code>G6</code>: Rotational hydrostatic restoring coefficients [N*m/rad]</li>
        </ul>
        <p>The hydrostatic restoring coefficients are combined into a diagonal matrix to allow for different coefficients in each dimension.</p>
        <p>Note: By default, only the z-axis translation (heave) has a non-zero restoring coefficient, which is typical for floating bodies.</p>
      </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "HS 6D", fontName = "Arial")}));
    end HydrostaticForce;

    model RadiationForce "Radiation force and torque calculation"
      // Inhertitance
      extends Hydrodynamic.Models.velocitySensorInput;
      // velocity input and concatenation
      extends Hydrodynamic.Models.forceTorque;
      // force declaration and output
      extends Hydrodynamic.HydroDataImport.radiationData;
      // hydrodynamic parameters
      // Enable/disable radiation Forces
      parameter Boolean enableRadiationForce = true "Switch to enable/disable radiation force calculation" annotation(
        Dialog(group = "Radiation Force Parameters"));
    protected
      Real x[n_states[2]] "Dummy variable state vector";
    initial equation
      x = zeros(n_states[2]) "Initialize state vector to zero";
    equation
// Use the switch to conditionally output the radiation force torque element
      if enableRadiationForce then
// Radiation state space
        der(x) = A*x + B*velocity;
        f = C*x + D*velocity;
      else
        x = zeros(n_states[2]);
        f = zeros(6);
      end if;
      
       F = -f;
    end RadiationForce;

    model DampingDragForce "Drag Force and Torque Calculation"
      // This simply acts as a placeholder and is not yet operational
      // All rotational damping and drag elements will be zero due to the irrotational assumption in linear wave theory
      // Inheritance
      extends Hydrodynamic.Models.velocitySensorInput;
      // velocity input and concatenation
      extends Hydrodynamic.Models.forceTorque;
      // force declaration and output
      extends Hydrodynamic.HydroDataImport.physicalConstantData;
      // hydrodynamic parameters
      // Enable/disable dampingdrag force
      parameter Boolean enableDampingDragForce = true "Switch to enable/disable damping drag force calculation" annotation(
        Dialog(group = "Damping Drag Force Parameters"));
      // Characteristic area
      parameter Real Ac "Reference area [m^2]";
      // Drag coefficients
      parameter Real Cdx "Translational drag coefficient for x-axis [-]";
      parameter Real Cdy "Translational drag coefficient for y-axis [-]";
      parameter Real Cdz "Translational drag coefficient for z-axis [-]";
      parameter Real Crx "Rotational drag coefficient for x-axis [-]";
      parameter Real Cry "Rotational drag coefficient for y-axis [-]";
      parameter Real Crz "Rotational drag coefficient for z-axis [-]";
      parameter Real Cd[6, 6] = diagonal({Cdx, Cdy, Cdz, Crx, Cry, Crz}) "Combined drag coefficient matrix";
    protected
      Real c "Combined constant term for drag calculation";
    equation
    // Use the switch to conditionally output the damping drag force and torque
if enableDampingDragForce then
// Calculate the combined constant term
        c = 0.5*rho*Ac;
// Will have different char areas, so c will need to be a vector
// Calculate the 6D drag force/torque vector
        f = c*Cd*velocity.*abs(velocity);
      else
        c = 0;
        f = zeros(6);
      end if;
      
       F = -f;
      annotation(
        Documentation(info = "<html>
        <p>This block calculates the 6-dimensional drag force and torque for both translational and rotational motion in a fluid medium.</p>
        <p>The drag force/torque is calculated using a quadratic drag model, where the force is proportional to the square of the velocity.</p>
        <p>The block can be enabled or disabled using the <code>enableDragForce</code> parameter.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>u</code>: Linear velocity vector [m/s]</li>
          <li><code>a</code>: Angular velocity vector [rad/s]</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>y</code>: Translational drag force vector [N]</li>
          <li><code>y1</code>: Rotational drag torque vector [N*m]</li>
        </ul>
        <p>Key Parameters:</p>
        <ul>
          <li><code>rho</code>: Fluid density [kg/m^3]</li>
          <li><code>A</code>: Reference area [m^2]</li>
          <li><code>Cdx</code>, <code>Cdy</code>, <code>Cdz</code>: Translational drag coefficients [-]</li>
          <li><code>Crx</code>, <code>Cry</code>, <code>Crz</code>: Rotational drag coefficients [-]</li>
        </ul>
        <p>The drag coefficients are combined into a diagonal matrix to allow for different coefficients in each dimension.</p>
      </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "Drag F 6D", fontName = "Arial")}));
    end DampingDragForce;

    model BodyShape "Rigid body with mass, inertia tensor, different shapes for animation, and two frame connectors (12 potential states)"
    
      extends Hydrodynamic.HydroDataImport.massData;
    
    
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a "Coordinate system fixed to the component with one cut-force and cut-torque" annotation(
        Placement(transformation(extent = {{-116, -16}, {-84, 16}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_b "Coordinate system fixed to the component with one cut-force and cut-torque" annotation(
        Placement(transformation(extent = {{84, -16}, {116, 16}})));
      parameter Boolean animation = true "= true, if animation shall be enabled (show shape between frame_a and frame_b and optionally a sphere at the center of mass)";
      parameter Boolean animateSphere = true "= true, if mass shall be animated as sphere provided animation=true";
      parameter Modelica.Units.SI.Position r[3](start = {0, 0, 0}) "Vector from frame_a to frame_b resolved in frame_a";
      parameter Modelica.Units.SI.Position r_CM[3](start = {0, 0, 0}) "Vector from frame_a to center of mass, resolved in frame_a";
      parameter Modelica.Units.SI.Mass m(min = 0, start = 1) = M + Ainf[3,3] "Mass of rigid body";
      parameter Modelica.Units.SI.Inertia I_11(min = 0) = 0.001 "Element (1,1) of inertia tensor" annotation(
        Dialog(group = "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica.Units.SI.Inertia I_22(min = 0) = 0.001 "Element (2,2) of inertia tensor" annotation(
        Dialog(group = "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica.Units.SI.Inertia I_33(min = 0) = 0.001 "Element (3,3) of inertia tensor" annotation(
        Dialog(group = "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica.Units.SI.Inertia I_21(min = -10000000) = 0 "Element (2,1) of inertia tensor" annotation(
        Dialog(group = "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica.Units.SI.Inertia I_31(min = -10000000) = 0 "Element (3,1) of inertia tensor" annotation(
        Dialog(group = "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      parameter Modelica.Units.SI.Inertia I_32(min = -10000000) = 0 "Element (3,2) of inertia tensor" annotation(
        Dialog(group = "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
      Modelica.Units.SI.Position r_0[3](start = {0, 0, 0}, each stateSelect = if enforceStates then StateSelect.always else StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a" annotation(
        Dialog(tab = "Initialization", showStartAttribute = true));
      Modelica.Units.SI.Velocity v_0[3](start = {0, 0, 0}, each stateSelect = if enforceStates then StateSelect.always else StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))" annotation(
        Dialog(tab = "Initialization", showStartAttribute = true));
      Modelica.Units.SI.Acceleration a_0[3](start = {0, 0, 0}) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))" annotation(
        Dialog(tab = "Initialization", showStartAttribute = true));
      parameter Boolean angles_fixed = false "= true, if angles_start are used as initial values, else as guess values" annotation(
        Evaluate = true,
        choices(checkBox = true),
        Dialog(tab = "Initialization"));
      parameter Modelica.Units.SI.Angle angles_start[3] = {0, 0, 0} "Initial values of angles to rotate world frame around 'sequence_start' axes into frame_a" annotation(
        Dialog(tab = "Initialization"));
      parameter Modelica.Mechanics.MultiBody.Types.RotationSequence sequence_start = {1, 2, 3} "Sequence of rotations to rotate world frame into frame_a at initial time" annotation(
        Evaluate = true,
        Dialog(tab = "Initialization"));
      parameter Boolean w_0_fixed = false "= true, if w_0_start are used as initial values, else as guess values" annotation(
        Evaluate = true,
        choices(checkBox = true),
        Dialog(tab = "Initialization"));
      parameter Modelica.Units.SI.AngularVelocity w_0_start[3] = {0, 0, 0} "Initial or guess values of angular velocity of frame_a resolved in world frame" annotation(
        Dialog(tab = "Initialization"));
      parameter Boolean z_0_fixed = false "= true, if z_0_start are used as initial values, else as guess values" annotation(
        Evaluate = true,
        choices(checkBox = true),
        Dialog(tab = "Initialization"));
      parameter Modelica.Units.SI.AngularAcceleration z_0_start[3] = {0, 0, 0} "Initial values of angular acceleration z_0 = der(w_0)" annotation(
        Dialog(tab = "Initialization"));
      parameter Modelica.Mechanics.MultiBody.Types.ShapeType shapeType = "cylinder" "Type of shape" annotation(
        Dialog(tab = "Animation", group = "if animation = true", enable = animation));
      parameter Modelica.Units.SI.Position r_shape[3] = {0, 0, 0} "Vector from frame_a to shape origin, resolved in frame_a" annotation(
        Dialog(tab = "Animation", group = "if animation = true", enable = animation));
      parameter Modelica.Mechanics.MultiBody.Types.Axis lengthDirection = Modelica.Units.Conversions.to_unit1(r - r_shape) "Vector in length direction of shape, resolved in frame_a" annotation(
        Evaluate = true,
        Dialog(tab = "Animation", group = "if animation = true", enable = animation));
      parameter Modelica.Mechanics.MultiBody.Types.Axis widthDirection = {0, 1, 0} "Vector in width direction of shape, resolved in frame_a" annotation(
        Evaluate = true,
        Dialog(tab = "Animation", group = "if animation = true", enable = animation));
      parameter Modelica.Units.SI.Length length = Modelica.Math.Vectors.length(r - r_shape) "Length of shape" annotation(
        Dialog(tab = "Animation", group = "if animation = true", enable = animation));
      parameter Modelica.Units.SI.Distance width = length/world.defaultWidthFraction "Width of shape" annotation(
        Dialog(tab = "Animation", group = "if animation = true", enable = animation));
      parameter Modelica.Units.SI.Distance height = width "Height of shape" annotation(
        Dialog(tab = "Animation", group = "if animation = true", enable = animation));
      parameter Modelica.Mechanics.MultiBody.Types.ShapeExtra extra = 0.0 "Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape)" annotation(
        Dialog(tab = "Animation", group = "if animation = true", enable = animation));
      input Modelica.Mechanics.MultiBody.Types.Color color = Modelica.Mechanics.MultiBody.Types.Defaults.BodyColor "Color of shape" annotation(
        Dialog(colorSelector = true, tab = "Animation", group = "if animation = true", enable = animation));
      parameter Modelica.Units.SI.Diameter sphereDiameter = 2*width "Diameter of sphere" annotation(
        Dialog(tab = "Animation", group = "if animation = true and animateSphere = true", enable = animation and animateSphere));
      input Modelica.Mechanics.MultiBody.Types.Color sphereColor = color "Color of sphere of mass" annotation(
        Dialog(colorSelector = true, tab = "Animation", group = "if animation = true and animateSphere = true", enable = animation and animateSphere));
      input Modelica.Mechanics.MultiBody.Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)" annotation(
        Dialog(tab = "Animation", group = "if animation = true", enable = animation));
      parameter Boolean enforceStates = false "= true, if absolute variables of body object shall be used as states (StateSelect.always)" annotation(
        Evaluate = true,
        Dialog(tab = "Advanced"));
      parameter Boolean useQuaternions = true "= true, if quaternions shall be used as potential states otherwise use 3 angles as potential states" annotation(
        Evaluate = true,
        Dialog(tab = "Advanced"));
      parameter Modelica.Mechanics.MultiBody.Types.RotationSequence sequence_angleStates = {1, 2, 3} "Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states" annotation(
        Evaluate = true,
        Dialog(tab = "Advanced", enable = not useQuaternions));
      Modelica.Mechanics.MultiBody.Parts.FixedTranslation frameTranslation(r = r, animation = false) annotation(
        Placement(transformation(extent = {{-20, -20}, {20, 20}})));
      Modelica.Mechanics.MultiBody.Parts.Body body(r_CM = r_CM, m = m, I_11 = I_11, I_22 = I_22, I_33 = I_33, I_21 = I_21, I_31 = I_31, I_32 = I_32, animation = false, sequence_start = sequence_start, angles_fixed = angles_fixed, angles_start = angles_start, w_0_fixed = w_0_fixed, w_0_start = w_0_start, z_0_fixed = z_0_fixed, z_0_start = z_0_start, useQuaternions = useQuaternions, sequence_angleStates = sequence_angleStates, enforceStates = false) annotation(
        Placement(transformation(extent = {{-27.3333, -70.3333}, {13, -30}})));
    protected
      outer Modelica.Mechanics.MultiBody.World world;
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape shape1(shapeType = shapeType, color = color, specularCoefficient = specularCoefficient, length = length, width = width, height = height, lengthDirection = lengthDirection, widthDirection = widthDirection, r_shape = r_shape, extra = extra, r = frame_a.r_0, R = frame_a.R) if world.enableAnimation and animation;
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape shape2(shapeType = "sphere", color = sphereColor, specularCoefficient = specularCoefficient, length = sphereDiameter, width = sphereDiameter, height = sphereDiameter, lengthDirection = {1, 0, 0}, widthDirection = {0, 1, 0}, r_shape = r_CM - {1, 0, 0}*sphereDiameter/2, r = frame_a.r_0, R = frame_a.R) if world.enableAnimation and animation and animateSphere;
    equation
      r_0 = frame_a.r_0;
      v_0 = der(r_0);
      a_0 = der(v_0);
      connect(frame_a, frameTranslation.frame_a) annotation(
        Line(points = {{-100, 0}, {-20, 0}}, color = {95, 95, 95}, thickness = 0.5));
      connect(frame_b, frameTranslation.frame_b) annotation(
        Line(points = {{100, 0}, {20, 0}}, color = {95, 95, 95}, thickness = 0.5));
      connect(frame_a, body.frame_a) annotation(
        Line(points = {{-100, 0}, {-60, 0}, {-60, -50.1666}, {-27.3333, -50.1666}}, color = {95, 95, 95}, thickness = 0.5));
      annotation(
        Documentation(info = "<html>
    <p>
    <strong>Rigid body</strong> with mass and inertia tensor and <strong>two frame connectors</strong>.
    All parameter vectors have to be resolved in frame_a.
    The <strong>inertia tensor</strong> has to be defined with respect to a
    coordinate system that is parallel to frame_a with the
    origin at the center of mass of the body. The coordinate system <strong>frame_b</strong>
    is always parallel to <strong>frame_a</strong>.
    </p>
    <p>
    By default, this component is visualized by any <strong>shape</strong> that can be
    defined with Modelica.Mechanics.MultiBody.Visualizers.FixedShape. This shape is placed
    between frame_a and frame_b (default: length(shape) = Frames.length(r)).
    Additionally a <strong>sphere</strong> may be visualized that has
    its center at the center of mass.
    Note, that
    the animation may be switched off via parameter animation = <strong>false</strong>.
    </p>
    <p>
    <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Parts/BodyShape.png\" alt=\"Parts.BodyShape\">
    </p>
    
    <p>
    The following shapes can be defined via parameter <strong>shapeType</strong>,
    e.g., shapeType=\"cone\":
    </p>
    
    <p>
    <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/FixedShape.png\" alt=\"Visualizers.FixedShape\">
    </p>
    
    <p>
    A BodyShape component has potential states. For details of these
    states and of the \"Advanced\" menu parameters, see model
    <a href=\"modelica://Modelica.Mechanics.MultiBody.Parts.Body\">MultiBody.Parts.Body</a>.
    </p>
    </html>"),
        Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100, -100}, {100, 100}}), graphics = {Text(extent = {{-150, 110}, {150, 70}}, textString = "%name", textColor = {0, 0, 255}), Text(extent = {{-150, -100}, {150, -70}}, textString = "r=%r"), Rectangle(extent = {{-100, 30}, {101, -30}}, lineColor = {0, 24, 48}, fillPattern = FillPattern.HorizontalCylinder, fillColor = {0, 127, 255}, radius = 10), Ellipse(extent = {{-60, 60}, {60, -60}}, lineColor = {0, 24, 48}, fillPattern = FillPattern.Sphere, fillColor = {0, 127, 255}), Text(extent = {{-50, 24}, {55, -27}}, textString = "%m"), Text(extent = {{55, 12}, {91, -13}}, textString = "b"), Text(extent = {{-92, 13}, {-56, -12}}, textString = "a")}),
        Diagram(coordinateSystem(preserveAspectRatio = true, extent = {{-100, -100}, {100, 100}}), graphics = {Line(points = {{-100, 9}, {-100, 43}}, color = {128, 128, 128}), Line(points = {{100, 0}, {100, 44}}, color = {128, 128, 128}), Line(points = {{-100, 40}, {90, 40}}, color = {135, 135, 135}), Polygon(points = {{90, 44}, {90, 36}, {100, 40}, {90, 44}}, lineColor = {128, 128, 128}, fillColor = {128, 128, 128}, fillPattern = FillPattern.Solid), Text(extent = {{-22, 68}, {20, 40}}, textColor = {128, 128, 128}, textString = "r"), Line(points = {{-100, -10}, {-100, -90}}, color = {128, 128, 128}), Line(points = {{-100, -84}, {-10, -84}}, color = {128, 128, 128}), Polygon(points = {{-10, -80}, {-10, -88}, {0, -84}, {-10, -80}}, lineColor = {128, 128, 128}, fillColor = {128, 128, 128}, fillPattern = FillPattern.Solid), Text(extent = {{-82, -66}, {-56, -84}}, textColor = {128, 128, 128}, textString = "r_CM"), Line(points = {{0, -46}, {0, -90}}, color = {128, 128, 128})}));
    end BodyShape;

    package Bodies
   
model BodyShape "Rigid body with mass, inertia tensor, different shapes for animation, and two frame connectors (12 potential states)"
        extends Hydrodynamic.HydroDataImport.massData;
        Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a "Coordinate system fixed to the component with one cut-force and cut-torque" annotation(
          Placement(transformation(extent = {{-116, -16}, {-84, 16}})));
        Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_b "Coordinate system fixed to the component with one cut-force and cut-torque" annotation(
          Placement(transformation(extent = {{84, -16}, {116, 16}})));
        parameter Boolean animation = true "= true, if animation shall be enabled (show shape between frame_a and frame_b and optionally a sphere at the center of mass)";
        parameter Boolean animateSphere = true "= true, if mass shall be animated as sphere provided animation=true";
        parameter Modelica.Units.SI.Position r[3](start = {0, 0, 0}) "Vector from frame_a to frame_b resolved in frame_a";
        parameter Modelica.Units.SI.Position r_CM[3](start = {0, 0, 0}) "Vector from frame_a to center of mass, resolved in frame_a";
       
        parameter Modelica.Units.SI.Inertia I_11(min = 0) = 0.001 "Element (1,1) of inertia tensor" annotation(
          Dialog(group = "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
        parameter Modelica.Units.SI.Inertia I_22(min = 0) = 0.001 "Element (2,2) of inertia tensor" annotation(
          Dialog(group = "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
        parameter Modelica.Units.SI.Inertia I_33(min = 0) = 0.001 "Element (3,3) of inertia tensor" annotation(
          Dialog(group = "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
        parameter Modelica.Units.SI.Inertia I_21(min = -10000000) = 0 "Element (2,1) of inertia tensor" annotation(
          Dialog(group = "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
        parameter Modelica.Units.SI.Inertia I_31(min = -10000000) = 0 "Element (3,1) of inertia tensor" annotation(
          Dialog(group = "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
        parameter Modelica.Units.SI.Inertia I_32(min = -10000000) = 0 "Element (3,2) of inertia tensor" annotation(
          Dialog(group = "Inertia tensor (resolved in center of mass, parallel to frame_a)"));
        Modelica.Units.SI.Position r_0[3](start = {0, 0, 0}, each stateSelect = if enforceStates then StateSelect.always else StateSelect.avoid) "Position vector from origin of world frame to origin of frame_a" annotation(
          Dialog(tab = "Initialization", showStartAttribute = true));
        Modelica.Units.SI.Velocity v_0[3](start = {0, 0, 0}, each stateSelect = if enforceStates then StateSelect.always else StateSelect.avoid) "Absolute velocity of frame_a, resolved in world frame (= der(r_0))" annotation(
          Dialog(tab = "Initialization", showStartAttribute = true));
        Modelica.Units.SI.Acceleration a_0[3](start = {0, 0, 0}) "Absolute acceleration of frame_a resolved in world frame (= der(v_0))" annotation(
          Dialog(tab = "Initialization", showStartAttribute = true));
        parameter Boolean angles_fixed = false "= true, if angles_start are used as initial values, else as guess values" annotation(
          Evaluate = true,
          choices(checkBox = true),
          Dialog(tab = "Initialization"));
        parameter Modelica.Units.SI.Angle angles_start[3] = {0, 0, 0} "Initial values of angles to rotate world frame around 'sequence_start' axes into frame_a" annotation(
          Dialog(tab = "Initialization"));
        parameter Modelica.Mechanics.MultiBody.Types.RotationSequence sequence_start = {1, 2, 3} "Sequence of rotations to rotate world frame into frame_a at initial time" annotation(
          Evaluate = true,
          Dialog(tab = "Initialization"));
        parameter Boolean w_0_fixed = false "= true, if w_0_start are used as initial values, else as guess values" annotation(
          Evaluate = true,
          choices(checkBox = true),
          Dialog(tab = "Initialization"));
        parameter Modelica.Units.SI.AngularVelocity w_0_start[3] = {0, 0, 0} "Initial or guess values of angular velocity of frame_a resolved in world frame" annotation(
          Dialog(tab = "Initialization"));
        parameter Boolean z_0_fixed = false "= true, if z_0_start are used as initial values, else as guess values" annotation(
          Evaluate = true,
          choices(checkBox = true),
          Dialog(tab = "Initialization"));
        parameter Modelica.Units.SI.AngularAcceleration z_0_start[3] = {0, 0, 0} "Initial values of angular acceleration z_0 = der(w_0)" annotation(
          Dialog(tab = "Initialization"));
        parameter Modelica.Mechanics.MultiBody.Types.ShapeType shapeType = "cylinder" "Type of shape" annotation(
          Dialog(tab = "Animation", group = "if animation = true", enable = animation));
        parameter Modelica.Units.SI.Position r_shape[3] = {0, 0, 0} "Vector from frame_a to shape origin, resolved in frame_a" annotation(
          Dialog(tab = "Animation", group = "if animation = true", enable = animation));
        parameter Modelica.Mechanics.MultiBody.Types.Axis lengthDirection = Modelica.Units.Conversions.to_unit1(r - r_shape) "Vector in length direction of shape, resolved in frame_a" annotation(
          Evaluate = true,
          Dialog(tab = "Animation", group = "if animation = true", enable = animation));
        parameter Modelica.Mechanics.MultiBody.Types.Axis widthDirection = {0, 1, 0} "Vector in width direction of shape, resolved in frame_a" annotation(
          Evaluate = true,
          Dialog(tab = "Animation", group = "if animation = true", enable = animation));
        parameter Modelica.Units.SI.Length length = Modelica.Math.Vectors.length(r - r_shape) "Length of shape" annotation(
          Dialog(tab = "Animation", group = "if animation = true", enable = animation));
        parameter Modelica.Units.SI.Distance width = length/world.defaultWidthFraction "Width of shape" annotation(
          Dialog(tab = "Animation", group = "if animation = true", enable = animation));
        parameter Modelica.Units.SI.Distance height = width "Height of shape" annotation(
          Dialog(tab = "Animation", group = "if animation = true", enable = animation));
        parameter Modelica.Mechanics.MultiBody.Types.ShapeExtra extra = 0.0 "Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape)" annotation(
          Dialog(tab = "Animation", group = "if animation = true", enable = animation));
        input Modelica.Mechanics.MultiBody.Types.Color color = Modelica.Mechanics.MultiBody.Types.Defaults.BodyColor "Color of shape" annotation(
          Dialog(colorSelector = true, tab = "Animation", group = "if animation = true", enable = animation));
        parameter Modelica.Units.SI.Diameter sphereDiameter = 2*width "Diameter of sphere" annotation(
          Dialog(tab = "Animation", group = "if animation = true and animateSphere = true", enable = animation and animateSphere));
        input Modelica.Mechanics.MultiBody.Types.Color sphereColor = color "Color of sphere of mass" annotation(
          Dialog(colorSelector = true, tab = "Animation", group = "if animation = true and animateSphere = true", enable = animation and animateSphere));
        input Modelica.Mechanics.MultiBody.Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient "Reflection of ambient light (= 0: light is completely absorbed)" annotation(
          Dialog(tab = "Animation", group = "if animation = true", enable = animation));
        parameter Boolean enforceStates = false "= true, if absolute variables of body object shall be used as states (StateSelect.always)" annotation(
          Evaluate = true,
          Dialog(tab = "Advanced"));
        parameter Boolean useQuaternions = true "= true, if quaternions shall be used as potential states otherwise use 3 angles as potential states" annotation(
          Evaluate = true,
          Dialog(tab = "Advanced"));
        parameter Modelica.Mechanics.MultiBody.Types.RotationSequence sequence_angleStates = {1, 2, 3} "Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states" annotation(
          Evaluate = true,
          Dialog(tab = "Advanced", enable = not useQuaternions));
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation frameTranslation(r = r, animation = false) annotation(
          Placement(transformation(extent = {{-20, -20}, {20, 20}})));
        Hydrodynamic.Forces.Bodies.Body_addedMass body(fileName=FileName, r_CM = r_CM, I_11 = I_11, I_22 = I_22, I_33 = I_33, I_21 = I_21, I_31 = I_31, I_32 = I_32, animation = false, sequence_start = sequence_start, angles_fixed = angles_fixed, angles_start = angles_start, w_0_fixed = w_0_fixed, w_0_start = w_0_start, z_0_fixed = z_0_fixed, z_0_start = z_0_start, useQuaternions = useQuaternions, sequence_angleStates = sequence_angleStates, enforceStates = false) annotation(
          Placement(transformation(extent = {{-27.3333, -70.3333}, {13, -30}})));
      protected
        outer Modelica.Mechanics.MultiBody.World world;
        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape shape1(shapeType = shapeType, color = color, specularCoefficient = specularCoefficient, length = length, width = width, height = height, lengthDirection = lengthDirection, widthDirection = widthDirection, r_shape = r_shape, extra = extra, r = frame_a.r_0, R = frame_a.R) if world.enableAnimation and animation;
        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape shape2(shapeType = "sphere", color = sphereColor, specularCoefficient = specularCoefficient, length = sphereDiameter, width = sphereDiameter, height = sphereDiameter, lengthDirection = {1, 0, 0}, widthDirection = {0, 1, 0}, r_shape = r_CM - {1, 0, 0}*sphereDiameter/2, r = frame_a.r_0, R = frame_a.R) if world.enableAnimation and animation and animateSphere;
      equation
        r_0 = frame_a.r_0;
        v_0 = der(r_0);
        a_0 = der(v_0);
        connect(frame_a, frameTranslation.frame_a) annotation(
          Line(points = {{-100, 0}, {-20, 0}}, color = {95, 95, 95}, thickness = 0.5));
        connect(frame_b, frameTranslation.frame_b) annotation(
          Line(points = {{100, 0}, {20, 0}}, color = {95, 95, 95}, thickness = 0.5));
        connect(frame_a, body.frame_a) annotation(
          Line(points = {{-100, 0}, {-60, 0}, {-60, -50.1666}, {-27.3333, -50.1666}}, color = {95, 95, 95}, thickness = 0.5));
        annotation(
          Documentation(info = "<html>
    <p>
    <strong>Rigid body</strong> with mass and inertia tensor and <strong>two frame connectors</strong>.
    All parameter vectors have to be resolved in frame_a.
    The <strong>inertia tensor</strong> has to be defined with respect to a
    coordinate system that is parallel to frame_a with the
    origin at the center of mass of the body. The coordinate system <strong>frame_b</strong>
    is always parallel to <strong>frame_a</strong>.
    </p>
    <p>
    By default, this component is visualized by any <strong>shape</strong> that can be
    defined with Modelica.Mechanics.MultiBody.Visualizers.FixedShape. This shape is placed
    between frame_a and frame_b (default: length(shape) = Frames.length(r)).
    Additionally a <strong>sphere</strong> may be visualized that has
    its center at the center of mass.
    Note, that
    the animation may be switched off via parameter animation = <strong>false</strong>.
    </p>
    <p>
    <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Parts/BodyShape.png\" alt=\"Parts.BodyShape\">
    </p>
    
    <p>
    The following shapes can be defined via parameter <strong>shapeType</strong>,
    e.g., shapeType=\"cone\":
    </p>
    
    <p>
    <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/FixedShape.png\" alt=\"Visualizers.FixedShape\">
    </p>
    
    <p>
    A BodyShape component has potential states. For details of these
    states and of the \"Advanced\" menu parameters, see model
    <a href=\"modelica://Modelica.Mechanics.MultiBody.Parts.Body\">MultiBody.Parts.Body</a>.
    </p>
    </html>"),
          Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100, -100}, {100, 100}}), graphics = {Text(extent = {{-150, 110}, {150, 70}}, textString = "%name", textColor = {0, 0, 255}), Text(extent = {{-150, -100}, {150, -70}}, textString = "r=%r"), Rectangle(extent = {{-100, 30}, {101, -30}}, lineColor = {0, 24, 48}, fillPattern = FillPattern.HorizontalCylinder, fillColor = {0, 127, 255}, radius = 10), Ellipse(extent = {{-60, 60}, {60, -60}}, lineColor = {0, 24, 48}, fillPattern = FillPattern.Sphere, fillColor = {0, 127, 255}), Text(extent = {{-50, 24}, {55, -27}}, textString = "%m"), Text(extent = {{55, 12}, {91, -13}}, textString = "b"), Text(extent = {{-92, 13}, {-56, -12}}, textString = "a")}),
          Diagram(coordinateSystem(preserveAspectRatio = true, extent = {{-100, -100}, {100, 100}}), graphics = {Line(points = {{-100, 9}, {-100, 43}}, color = {128, 128, 128}), Line(points = {{100, 0}, {100, 44}}, color = {128, 128, 128}), Line(points = {{-100, 40}, {90, 40}}, color = {135, 135, 135}), Polygon(points = {{90, 44}, {90, 36}, {100, 40}, {90, 44}}, lineColor = {128, 128, 128}, fillColor = {128, 128, 128}, fillPattern = FillPattern.Solid), Text(extent = {{-22, 68}, {20, 40}}, textColor = {128, 128, 128}, textString = "r"), Line(points = {{-100, -10}, {-100, -90}}, color = {128, 128, 128}), Line(points = {{-100, -84}, {-10, -84}}, color = {128, 128, 128}), Polygon(points = {{-10, -80}, {-10, -88}, {0, -84}, {-10, -80}}, lineColor = {128, 128, 128}, fillColor = {128, 128, 128}, fillPattern = FillPattern.Solid), Text(extent = {{-82, -66}, {-56, -84}}, textColor = {128, 128, 128}, textString = "r_CM"), Line(points = {{0, -46}, {0, -90}}, color = {128, 128, 128})}));
      end BodyShape;

      model Body_addedMass  "Rigid body with mass, inertia tensor and one frame connector (12 potential states)"
      
        extends Hydrodynamic.HydroDataImport.massData;
      
      
      
        Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a
          "Coordinate system fixed at body" annotation (Placement(transformation(
                extent={{-116,-16},{-84,16}})));
        parameter Boolean animation=true
          "= true, if animation shall be enabled (show cylinder and sphere)";
        parameter Modelica.Units.SI.Position r_CM[3](start={0,0,0})
          "Vector from frame_a to center of mass, resolved in frame_a";
        parameter Modelica.Units.SI.Mass m[3,3] = diagonal({M,M,M}) "Mass of rigid body";
        parameter Modelica.Units.SI.Mass am[3,3] = [50,0,0;0,50,0;0,0,50] "Mass of rigid body";
        parameter Modelica.Units.SI.Mass am_off[3,3] = [50,0,0;0,50,0;0,0,50] "Mass of rigid body";
        parameter Modelica.Units.SI.Inertia I_11(min=0) = 0.0005 "Element (1,1) of inertia tensor"
          annotation (Dialog(group="Inertia tensor (resolved in center of mass, parallel to frame_a)"));
        parameter Modelica.Units.SI.Inertia I_22(min=0) = 0.0005 "Element (2,2) of inertia tensor"
          annotation (Dialog(group="Inertia tensor (resolved in center of mass, parallel to frame_a)"));
        parameter Modelica.Units.SI.Inertia I_33(min=0) = 0.0005 "Element (3,3) of inertia tensor"
          annotation (Dialog(group="Inertia tensor (resolved in center of mass, parallel to frame_a)"));
        parameter Modelica.Units.SI.Inertia I_21(min=-10000000) = 0 "Element (2,1) of inertia tensor"
          annotation (Dialog(group="Inertia tensor (resolved in center of mass, parallel to frame_a)"));
        parameter Modelica.Units.SI.Inertia I_31(min=-10000000) = 0 "Element (3,1) of inertia tensor"
          annotation (Dialog(group="Inertia tensor (resolved in center of mass, parallel to frame_a)"));
        parameter Modelica.Units.SI.Inertia I_32(min=-10000000) = 0 "Element (3,2) of inertia tensor"
          annotation (Dialog(group="Inertia tensor (resolved in center of mass, parallel to frame_a)"));
        parameter Modelica.Units.SI.Inertia I_am[3,3] = [0.0005,0,0;0,0.0005,0;0,0,0.0005];
      
        Modelica.Units.SI.Position r_0[3](start={0,0,0}, each stateSelect=if enforceStates then
              StateSelect.always else StateSelect.avoid)
          "Position vector from origin of world frame to origin of frame_a"
          annotation (Dialog(tab="Initialization",showStartAttribute=true));
        Modelica.Units.SI.Velocity v_0[3](start={0,0,0}, each stateSelect=if enforceStates then
              StateSelect.always else StateSelect.avoid)
          "Absolute velocity of frame_a, resolved in world frame (= der(r_0))"
          annotation (Dialog(tab="Initialization",showStartAttribute=true));
        Modelica.Units.SI.Acceleration a_0[3](start={0,0,0})
          "Absolute acceleration of frame_a resolved in world frame (= der(v_0))"
          annotation (Dialog(tab="Initialization",showStartAttribute=true));
      
        parameter Boolean angles_fixed=false
          "= true, if angles_start are used as initial values, else as guess values"
          annotation (
          Evaluate=true,
          choices(checkBox=true),
          Dialog(tab="Initialization"));
        parameter Modelica.Units.SI.Angle angles_start[3]={0,0,0}
          "Initial values of angles to rotate world frame around 'sequence_start' axes into frame_a"
          annotation (Dialog(tab="Initialization"));
        parameter Modelica.Mechanics.MultiBody.Types.RotationSequence sequence_start={1,2,3}
          "Sequence of rotations to rotate world frame into frame_a at initial time"
          annotation (Evaluate=true, Dialog(tab="Initialization"));
      
        parameter Boolean w_0_fixed=false
          "= true, if w_0_start are used as initial values, else as guess values"
          annotation (
          Evaluate=true,
          choices(checkBox=true),
          Dialog(tab="Initialization"));
        parameter Modelica.Units.SI.AngularVelocity w_0_start[3]={0,0,0}
          "Initial or guess values of angular velocity of frame_a resolved in world frame"
          annotation (Dialog(tab="Initialization"));
      
        parameter Boolean z_0_fixed=false
          "= true, if z_0_start are used as initial values, else as guess values"
          annotation (
          Evaluate=true,
          choices(checkBox=true),
          Dialog(tab="Initialization"));
        parameter Modelica.Units.SI.AngularAcceleration z_0_start[3]={0,0,0}
          "Initial values of angular acceleration z_0 = der(w_0)"
          annotation (Dialog(tab="Initialization"));
      
        parameter Modelica.Units.SI.Diameter sphereDiameter=world.defaultBodyDiameter
          "Diameter of sphere" annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Modelica.Mechanics.MultiBody.Types.Color sphereColor=Modelica.Mechanics.MultiBody.Types.Defaults.BodyColor
          "Color of sphere" annotation (Dialog(
            colorSelector=true,
            tab="Animation",
            group="if animation = true",
            enable=animation));
        parameter Modelica.Units.SI.Diameter cylinderDiameter=sphereDiameter/Modelica.Mechanics.MultiBody.Types.Defaults.BodyCylinderDiameterFraction
          "Diameter of cylinder" annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Modelica.Mechanics.MultiBody.Types.Color cylinderColor=sphereColor "Color of cylinder" annotation (
           Dialog(
            colorSelector=true,
            tab="Animation",
            group="if animation = true",
            enable=animation));
        input Modelica.Mechanics.MultiBody.Types.SpecularCoefficient specularCoefficient=world.defaultSpecularCoefficient
          "Reflection of ambient light (= 0: light is completely absorbed)"
          annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        parameter Boolean enforceStates=false
          "= true, if absolute variables of body object shall be used as states (StateSelect.always)"
          annotation (Evaluate=true, Dialog(tab="Advanced"));
        parameter Boolean useQuaternions=true
          "= true, if quaternions shall be used as potential states otherwise use 3 angles as potential states"
          annotation (Evaluate=true, Dialog(tab="Advanced"));
        parameter Modelica.Mechanics.MultiBody.Types.RotationSequence sequence_angleStates={1,2,3}
          "Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states"
          annotation (Evaluate=true, Dialog(tab="Advanced", enable=not
                useQuaternions));
      
        final parameter Modelica.Units.SI.Inertia I[3, 3]=[I_11, I_21, I_31; I_21, I_22, I_32;
            I_31, I_32, I_33] "Inertia tensor";
        final parameter Modelica.Mechanics.MultiBody.Frames.Orientation R_start=
            Modelica.Mechanics.MultiBody.Frames.axesRotations(
              sequence_start,
              angles_start,
              zeros(3))
          "Orientation object from world frame to frame_a at initial time";
      
        Modelica.Units.SI.AngularVelocity w_a[3](
          start=Modelica.Mechanics.MultiBody.Frames.resolve2(R_start, w_0_start),
          fixed=fill(w_0_fixed, 3),
          each stateSelect=if enforceStates then (if useQuaternions then
              StateSelect.always else StateSelect.never) else StateSelect.avoid)
          "Absolute angular velocity of frame_a resolved in frame_a";
        Modelica.Units.SI.AngularAcceleration z_a[3](start=Modelica.Mechanics.MultiBody.Frames.resolve2(R_start, z_0_start),
            fixed=fill(z_0_fixed, 3))
          "Absolute angular acceleration of frame_a resolved in frame_a";
        Modelica.Units.SI.Acceleration g_0[3] "Gravity acceleration resolved in world frame";
      
      protected
        outer Modelica.Mechanics.MultiBody.World world;
      // Declarations for quaternions (dummies, if quaternions are not used)
        parameter Modelica.Mechanics.MultiBody.Frames.Quaternions.Orientation Q_start=Modelica.Mechanics.MultiBody.Frames.to_Q(R_start)
          "Quaternion orientation object from world frame to frame_a at initial time";
        Modelica.Mechanics.MultiBody.Frames.Quaternions.Orientation Q(start=Q_start, each stateSelect=if
              enforceStates then (if useQuaternions then StateSelect.prefer else
              StateSelect.never) else StateSelect.avoid)
          "Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)";
      // Declaration for 3 angles
        parameter Modelica.Units.SI.Angle phi_start[3]=if sequence_start[1] ==
            sequence_angleStates[1] and sequence_start[2] == sequence_angleStates[2]
             and sequence_start[3] == sequence_angleStates[3] then angles_start
             else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(R_start, sequence_angleStates)
          "Potential angle states at initial time";
        Modelica.Units.SI.Angle phi[3](start=phi_start, each stateSelect=if enforceStates then (
              if useQuaternions then StateSelect.never else StateSelect.always)
               else StateSelect.avoid)
          "Dummy or 3 angles to rotate world frame into frame_a of body";
        Modelica.Units.SI.AngularVelocity phi_d[3](each stateSelect=if enforceStates then (if
              useQuaternions then StateSelect.never else StateSelect.always) else
              StateSelect.avoid) "= der(phi)";
        Modelica.Units.SI.AngularAcceleration phi_dd[3] "= der(phi_d)";
      // Declarations for animation
        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape cylinder(
          shapeType="cylinder",
          color=cylinderColor,
          specularCoefficient=specularCoefficient,
          length=if Modelica.Math.Vectors.length(r_CM) > sphereDiameter/2 then
              Modelica.Math.Vectors.length(r_CM) - (if cylinderDiameter > 1.1*
              sphereDiameter then sphereDiameter/2 else 0) else 0,
          width=cylinderDiameter,
          height=cylinderDiameter,
          lengthDirection = to_unit1(r_CM),
          widthDirection={0,1,0},
          r=frame_a.r_0,
          R=frame_a.R) if world.enableAnimation and animation;
        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape sphere(
          shapeType="sphere",
          color=sphereColor,
          specularCoefficient=specularCoefficient,
          length=sphereDiameter,
          width=sphereDiameter,
          height=sphereDiameter,
          lengthDirection={1,0,0},
          widthDirection={0,1,0},
          r_shape=r_CM - {1,0,0}*sphereDiameter/2,
          r=frame_a.r_0,
          R=frame_a.R) if world.enableAnimation and animation and sphereDiameter >
          0;
      initial equation
        if angles_fixed then
          // Initialize positional variables
if not Connections.isRoot(frame_a.R) then
// frame_a.R is computed somewhere else
            zeros(3) = Modelica.Mechanics.MultiBody.Frames.Orientation.equalityConstraint(frame_a.R, R_start);
          elseif useQuaternions then
// frame_a.R is computed from quaternions Q
            zeros(3) = Modelica.Mechanics.MultiBody.Frames.Quaternions.Orientation.equalityConstraint(Q, Q_start);
          else
// frame_a.R is computed from the 3 angles 'phi'
            phi = phi_start;
          end if;
        end if;
      
      equation
        if enforceStates then
          Connections.root(frame_a.R);
        else
          Connections.potentialRoot(frame_a.R);
        end if;
        r_0 = frame_a.r_0;
      
        if not Connections.isRoot(frame_a.R) then
// Body does not have states
// Dummies
          Q = {0,0,0,1};
          phi = zeros(3);
          phi_d = zeros(3);
          phi_dd = zeros(3);
        elseif useQuaternions then
// Use Quaternions as states (with dynamic state selection)
          frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q(Q, Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2(Q, der(Q)));
          {0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint(Q);
// Dummies
          phi = zeros(3);
          phi_d = zeros(3);
          phi_dd = zeros(3);
        else
// Use Cardan angles as states
          phi_d = der(phi);
          phi_dd = der(phi_d);
          frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations(
              sequence_angleStates,
              phi,
              phi_d);
// Dummies
          Q = {0,0,0,1};
        end if;
// gravity acceleration at center of mass resolved in world frame
        g_0 = Modelica.Mechanics.MultiBody.World.gravityAcceleration(frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(frame_a.R,
          r_CM));
// translational kinematic differential equations
        v_0 = der(frame_a.r_0);
        a_0 = der(v_0);
// rotational kinematic differential equations
        w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(frame_a.R);
        z_a = der(w_a);
      
        /* Newton/Euler equations with respect to center of mass
                  a_CM = a_a + cross(z_a, r_CM) + cross(w_a, cross(w_a, r_CM));
                  f_CM = m*(a_CM - g_a);
                  t_CM = I*z_a + cross(w_a, I*w_a);
             frame_a.f = f_CM
             frame_a.t = t_CM + cross(r_CM, f_CM);
          Inserting the first three equations in the last two results in:
        */
        frame_a.f = (m+Ainf[1:3,1:3])*(Modelica.Mechanics.MultiBody.Frames.resolve2(frame_a.R, a_0 - g_0) + cross(z_a, r_CM) +
          cross(w_a, cross(w_a, r_CM))) + Ainf[1:3,4:6]*z_a;
        frame_a.t = (I+Ainf[4:6,4:6])*z_a + cross(w_a, (I+I_am)*w_a) + cross(r_CM, frame_a.f) + Ainf[4:6,1:3]*(Modelica.Mechanics.MultiBody.Frames.resolve2(frame_a.R, a_0 - g_0) + cross(z_a, r_CM) +
          cross(w_a, cross(w_a, r_CM)));
        annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,30},{-3,-30}},
                lineColor={0,24,48},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255},
                radius=10),
              Text(
                extent={{150,-100},{-150,-70}},
                textString="m=%m"),
              Text(
                extent={{-150,110},{150,70}},
                textString="%name",
                textColor={0,0,255}),
              Ellipse(
                extent={{-20,60},{100,-60}},
                lineColor={0,24,48},
                fillPattern=FillPattern.Sphere,
                fillColor={0,127,255})}), Documentation(info="<html>
      <p>
      <strong>Rigid body</strong> with mass and inertia tensor.
      All parameter vectors have to be resolved in frame_a.
      The <strong>inertia tensor</strong> has to be defined with respect to a
      coordinate system that is parallel to frame_a with the
      origin at the center of mass of the body.
      </p>
      <p>
      By default, this component is visualized by a <strong>cylinder</strong> located
      between frame_a and the center of mass and by a <strong>sphere</strong> that has
      its center at the center of mass. If the cylinder length is smaller as
      the radius of the sphere, e.g., since frame_a is located at the
      center of mass, the cylinder is not displayed. Note, that
      the animation may be switched off via parameter animation = <strong>false</strong>.
      </p>
      <p>
      <img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Parts/Body.png\" alt=\"Parts.Body\">
      </p>
      
      <p>
      <strong>States of Body Components</strong>
      </p>
      <p>
      Every body has potential states. If possible a tool will select
      the states of joints and not the states of bodies because this is
      usually the most efficient choice. In this case the position, orientation,
      velocity and angular velocity of frame_a of the body will be computed
      by the component that is connected to frame_a. However, if a body is moving
      freely in space, variables of the body have to be used as states. The potential
      states of the body are:
      </p>
      <ul>
      <li> The <strong>position vector</strong> frame_a.r_0 from the origin of the
           world frame to the origin of frame_a of the body, resolved in
           the world frame and the <strong>absolute velocity</strong> v_0 of the origin of
           frame_a, resolved in the world frame (= der(frame_a.r_0)).
      </li>
      <li> If parameter <strong>useQuaternions</strong> in the \"Advanced\" menu
           is <strong>true</strong> (this is the default), then <strong>4 quaternions</strong>
           are potential states. Additionally, the coordinates of the
           absolute angular velocity vector of the
           body are 3 potential states.<br>
           If <strong>useQuaternions</strong> in the \"Advanced\" menu
           is <strong>false</strong>, then <strong>3 angles</strong> and the derivatives of
           these angles are potential states. The orientation of frame_a
           is computed by rotating the world frame along the axes defined
           in parameter vector \"sequence_angleStates\" (default = {1,2,3}, i.e.,
           the Cardan angle sequence) around the angles used as potential states.
           For example, the default is to rotate the x-axis of the world frame
           around angles[1], the new y-axis around angles[2] and the new z-axis
           around angles[3], arriving at frame_a.
       </li>
      </ul>
      <p>
      The quaternions have the slight disadvantage that there is a
      non-linear constraint equation between the 4 quaternions.
      Therefore, at least one non-linear equation has to be solved
      during simulation. A tool might, however, analytically solve this
      simple constraint equation. Using the 3 angles as states has the
      disadvantage that there is a singular configuration in which a
      division by zero will occur. If it is possible to determine in advance
      for an application class that this singular configuration is outside
      of the operating region, the 3 angles might be used as potential
      states by setting <strong>useQuaternions</strong> = <strong>false</strong>.
      </p>
      <p>
      In text books about 3-dimensional mechanics often 3 angles and the
      angular velocity are used as states. This is not the case here, since
      3 angles and their derivatives are used as potential states
      (if useQuaternions = false). The reason
      is that for real-time simulation the discretization formula of the
      integrator might be \"inlined\" and solved together with the body equations.
      By appropriate symbolic transformation the performance is
      drastically increased if angles and their
      derivatives are used as states, instead of angles and the angular
      velocity.
      </p>
      <p>
      Whether or not variables of the body are used as states is usually
      automatically selected by the Modelica translator. If parameter
      <strong>enforceStates</strong> is set to <strong>true</strong> in the \"Advanced\" menu,
      then body variables are forced to be used as states according
      to the setting of parameters \"useQuaternions\" and
      \"sequence_angleStates\".
      </p>
      </html>"));
      

      end Body_addedMass;
    
    end Bodies;

    record FilePath
    
       parameter String FileName = "C:/Users/thogan1/Documents/GitHub/OET_6DoF/hydroCoeff_6DoF.mat" "File path to data structure" annotation(
        Dialog(group = "File Path"));
        
    end FilePath;

    model HydrodynamicBodySensorOutput
    
      // Inheritance
      extends Hydrodynamic.Connector.inputOutput_con;
      //extends Hydrodynamic.HydroDataImport.massData;
      /* This should be removed from here and included in the definition of the body in HydrodynamicBody, but is okay in the interim */
      // BodyShape parameters
      parameter String FileName;
      
      /* Removing mass definition here and adding it to a custom bodyShape model
      parameter Modelica.Units.SI.Mass m = M + Ainf[3, 3] "Mass of the body" annotation(
        Dialog(group = "Body")); /*
      /* The mass is only valid when motion is constrained in heave. This line is also repeated in the PTO force code base to determine the control gain */
      parameter Modelica.Units.SI.Position r[3] = {0, 0, 0} "Position vector" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Position r_CM[3] = {0, 0, 0} "Center of mass position vector" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_11 = 0.001 "Element (1,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_22 = 0.001 "Element (2,2) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_33 = 0.001 "Element (3,3) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_21 = 0 "Element (2,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_31 = 0 "Element (3,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Modelica.Units.SI.Inertia I_32 = 0 "Element (3,2) of inertia tensor" annotation(
        Dialog(group = "Body"));
      Hydrodynamic.Forces.BodyShape bodyShape(r = r, r_CM = {0, 0, -0.72}, /*m = m,*/ I_11 = I_11, I_22 = I_22, I_33 = I_33, I_21 = I_21, I_31 = I_31, I_32 = I_32,fileName=FileName) annotation(
        Placement(transformation(origin = {10, -84}, extent = {{-10, -10}, {10, 10}})));
      // Hydrostatic force parameters
      parameter Boolean enableHydrostaticForce = true "Switch to enable/disable hydrostatic force calculation" annotation(
        Dialog(group = "Hydrostatic Force Parameters"));
      Hydrodynamic.Forces.HydrostaticForce hydrostaticForce(enableHydrostaticForce = enableHydrostaticForce,fileName=FileName) "Hydrostatic force calculation" annotation(
        Placement(transformation(origin = {16, -20}, extent = {{-10, -10}, {10, 10}})));
      // Radiation force paramters
      parameter Boolean enableRadiationForce = true "Switch to enable/disable 6D radiation force calculation" annotation(
        Dialog(group = "Radiation Force Parameters"));
      Hydrodynamic.Forces.RadiationForce radiationForce(fileName=FileName) annotation(
        Placement(transformation(origin = {18, 64}, extent = {{-10, -10}, {10, 10}})));
      // PTO force parameters
      parameter Boolean enablePTOForce = true "Switch to enable/disable PTO force calculation" annotation(
        Dialog(group = "PTO Force Parameters"));
      parameter String controllerSelect = "reactive" "Controller type select" annotation(
        Dialog(group = "PTO Force Parameters"));
      Hydrodynamic.Forces.PTOForce ptoForce( /*omega_peak = omega_peak, Kpx = Kpx, Kpy = Kpy, Kprx = Kprx, Kpry = Kpry, Kprz = Kprz, Kix = Kix, Kiy = Kiy, Kirx = Kirx, Kiry = Kiry, Kirz = Kirz, */enablePTOForce = enablePTOForce, controllerSelect = controllerSelect,fileName=FileName) "PTO force calculation" annotation(
        Placement(transformation(origin = {16, -46}, extent = {{-10, -10}, {10, 10}})));
      /* 
            parameter Real Kpx = 0.0 "Proportional gain for x-axis translation" annotation(
              Dialog(group = "PTO Parameters"));
            parameter Real Kpy = 0.0 "Proportional gain for y-axis translation" annotation(
              Dialog(group = "PTO Parameters"));
            parameter Real Kprx = 0.0 "Proportional gain for x-axis rotation" annotation(
              Dialog(group = "PTO Parameters"));
            parameter Real Kpry = 0.0 "Proportional gain for y-axis rotation" annotation(
              Dialog(group = "PTO Parameters"));
            parameter Real Kprz = 0.0 "Proportional gain for z-axis rotation" annotation(
              Dialog(group = "PTO Parameters"));
            parameter TranslationalSpringConstant Kix = 0.0 "Integral gain for x-axis translation" annotation(
              Dialog(group = "PTO Parameters"));
            parameter TranslationalSpringConstant Kiy = 0.0 "Integral gain for y-axis translation" annotation(
              Dialog(group = "PTO Parameters"));
            parameter RotationalSpringConstant Kirx = 0.0 "Integral gain for x-axis rotation" annotation(
              Dialog(group = "PTO Parameters"));
            parameter RotationalSpringConstant Kiry = 0.0 "Integral gain for y-axis rotation" annotation(
              Dialog(group = "PTO Parameters"));
            parameter RotationalSpringConstant Kirz = 0.0 "Integral gain for z-axis rotation" annotation(
              Dialog(group = "PTO Parameters"));
          */
      // Drag force parameters
      parameter Boolean enableDampingDragForce = false "Switch to enable/disable drag force calculation" annotation(
        Dialog(group = "Damping and Drag Force Parameters"));
      parameter Modelica.Units.SI.Area Ac = 1 "Reference area" annotation(
        Dialog(group = "Damping and Drag Force Parameters"));
      parameter Real Cdx = 100 "Translational drag coefficient for x-axis" annotation(
        Dialog(group = "Damping and Drag Force Parameters"));
      parameter Real Cdy = 0.01 "Translational drag coefficient for y-axis" annotation(
        Dialog(group = "Damping and Drag Force Parameters"));
      parameter Real Cdz = 100 "Translational drag coefficient for z-axis" annotation(
        Dialog(group = "Damping and Drag Force Parameters"));
      parameter Real Crx = 100 "Rotational drag coefficient for x-axis" annotation(
        Dialog(group = "Damping and Drag Force Parameters"));
      parameter Real Cry = 0.01 "Rotational drag coefficient for y-axis" annotation(
        Dialog(group = "Damping and Drag Force Parameters"));
      parameter Real Crz = 100 "Rotational drag coefficient for z-axis" annotation(
        Dialog(group = "Damping and Drag Force Parameters"));
      Hydrodynamic.Forces.DampingDragForce dampingDragForce(Ac = Ac, Cdx = Cdx, Cdy = Cdy, Cdz = Cdz, Crx = Crx, Cry = Cry, Crz = Crz, enableDampingDragForce = enableDampingDragForce,fileName=FileName) "Drag force calculation" annotation(
        Placement(transformation(origin = {16, 24}, extent = {{-10, -10}, {10, 10}})));
      // Force and torque blocks
      ForceToqueSum forceToqueSum annotation(
        Placement(transformation(origin = {50, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque forceAndTorque annotation(
        Placement(transformation(origin = {82, 0}, extent = {{-10, 10}, {10, -10}}, rotation = -0)));
      // Absolute sensor
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteSensor absoluteSensor(get_r = true, get_v = true, get_a = true, get_z = true, get_angles = true, get_w = true) annotation(
        Placement(transformation(origin = {-61, 1}, extent = {{-11, -11}, {11, 11}})));
    equation
    //Conections
      connect(bodyShape.frame_a, frame_a) annotation(
        Line(points = {{0, -84}, {-102, -84}, {-102, 0}}, color = {95, 95, 95}));
      connect(bodyShape.frame_b, frame_b) annotation(
        Line(points = {{20, -84}, {102, -84}, {102, 0}}, color = {95, 95, 95}));
      connect(forceAndTorque.frame_b, bodyShape.frame_b) annotation(
        Line(points = {{92, 0}, {92, -84}, {20, -84}}, color = {95, 95, 95}));
      connect(forceToqueSum.F, forceAndTorque.force) annotation(
        Line(points = {{61, 5}, {64, 5}, {64, 6}, {70, 6}}, color = {0, 0, 127}, thickness = 0.5));
      connect(forceToqueSum.T, forceAndTorque.torque) annotation(
        Line(points = {{61, -5}, {70, -5}, {70, -6}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.w, dampingDragForce.omega_abs) annotation(
        Line(points = {{-54, -11}, {-72, -11}, {-72, 16}, {4, 16}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.w, ptoForce.omega_abs) annotation(
        Line(points = {{-54, -12}, {-72, -12}, {-72, -54}, {4, -54}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.r, ptoForce.u_abs) annotation(
        Line(points = {{-72, -12}, {-72, -38}, {4, -38}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.angles, ptoForce.theta_abs) annotation(
        Line(points = {{-58, -12}, {-72, -12}, {-72, -44}, {4, -44}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.v, ptoForce.v_abs) annotation(
        Line(points = {{-68, -12}, {-72, -12}, {-72, -48}, {4, -48}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.v, dampingDragForce.v_abs) annotation(
        Line(points = {{-68, -12}, {-72, -12}, {-72, 22}, {4, 22}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.r, hydrostaticForce.u_abs) annotation(
        Line(points = {{-72, -12}, {4, -12}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.angles, hydrostaticForce.theta_abs) annotation(
        Line(points = {{-58, -12}, {-4, -12}, {-4, -18}, {4, -18}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.frame_a, bodyShape.frame_b) annotation(
        Line(points = {{-72, 2}, {-86, 2}, {-86, -68}, {20, -68}, {20, -84}}, color = {95, 95, 95}));
      connect(dampingDragForce.F, forceToqueSum.Fd) annotation(
        Line(points = {{27, 24}, {30, 24}, {30, -2}, {38, -2}}, color = {0, 0, 127}, thickness = 0.5));
      connect(ptoForce.F, forceToqueSum.Fpto) annotation(
        Line(points = {{28, -46}, {30, -46}, {30, -8}, {38, -8}}, color = {0, 0, 127}, thickness = 0.5));
      connect(hydrostaticForce.F, forceToqueSum.Fhs) annotation(
        Line(points = {{28, -20}, {30, -20}, {30, 2}, {38, 2}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.v, radiationForce.v_abs) annotation(
        Line(points = {{-68, -12}, {-70, -12}, {-70, 62}, {6, 62}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.w, radiationForce.omega_abs) annotation(
        Line(points = {{-54, -12}, {-48, -12}, {-48, 56}, {6, 56}}, color = {0, 0, 127}, thickness = 0.5));
      connect(radiationForce.F, forceToqueSum.Fr) annotation(
        Line(points = {{30, 64}, {38, 64}, {38, 8}}, color = {0, 0, 127}, thickness = 0.5));
      annotation(
        Diagram,
        Documentation(info = "<html>
        <p>This model calculates and applies 6-dimensional hydrodynamic forces and moments to a multibody system.</p>
        <p>It incorporates the following hydrodynamic effects:</p>
        <ul>
          <li>Drag forces and torques</li>
          <li>Power Take-Off (PTO) forces and torques</li>
          <li>Hydrostatic forces and torques</li>
          <li>Radiation forces</li>
        </ul>
        <p>The model uses absolute position, velocity, and angular sensors to determine the body's state, 
        calculates the various hydrodynamic forces, and applies them to the body.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>frame_a</code>: Input frame for body state</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>frame_b</code>: Output frame with applied hydrodynamic forces and torques</li>
        </ul>
        <p>Note: Some force components (e.g., drag and PTO) are disabled by default and can be enabled by modifying the respective parameters.</p>
      </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "HD Block 6D", fontName = "Arial")}));
    
    

    end HydrodynamicBodySensorOutput;
    annotation(
      Documentation(info = "<html>
      <h4>Forces Package for Hydrodynamic Systems</h4>
      <p>This package contains various force models used in hydrodynamic systems simulations, particularly for marine and offshore applications.</p>
      <p>Included models:</p>
      <ul>
        <li><b>HydrostaticForce6D:</b> Calculates 6-dimensional hydrostatic force and torque, including both translational and rotational components.</li>
        <li><b>RadiationF1D:</b> Calculates 1-dimensional radiation force using a state-space representation for hydrodynamic systems.</li>
        <li><b>DragForce6D:</b> Computes 6-dimensional drag force and torque, taking into account both translational and rotational drag.</li>
        <li><b>PTO6D:</b> Models a 6-dimensional Power Take-Off (PTO) system using reactive and passive control for both translational and rotational motion.</li>
        <li><b>HydrodynamicBlock6D:</b> Calculates and applies 6-dimensional hydrodynamic forces and moments to a multibody system.</li>
      </ul>
      <p>Each model is thoroughly documented and includes customizable parameters to adapt to various scenarios and environmental conditions.</p>
    </html>"),
      Icon(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics = {Polygon(origin = {23.3333, 0.0}, fillColor = {0, 0, 0}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, points = {{-23.333, 30.0}, {46.667, 0.0}, {-23.333, -30.0}}), Rectangle(fillColor = {0, 0, 0}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{-70, -4.5}, {0, 4.5}})}));
  end Forces;

  package WaveProfile
    extends Modelica.Icons.Package;

    package RegularWave
      /* Package for regular wave elevation profile and excitation force calculations */
      extends Modelica.Icons.Package;

      model LinearWave "Implementation of linear Airy wave model"
        // Inherit from waveParameters class, modifying the number of frequency components
        extends Hydrodynamic.WaveProfile.waveParameters(n_omega = 1, epsilon = fill(0, n_omega));
      equation
// Calculate wave amplityde
        zeta[n_omega] = Hs/2 "Wave amplitude [m]";
// Assign peak amplitude to the scalar frequency
        omega[n_omega] = omega_peak;
        annotation(
          Documentation(info = "<html>
            <p>This model implements the linear Airy wave theory to calculate wave elevation profiles and associated excitation forces.</p>
            <p>Key features:</p>
            <ul>
              <li>Calculates sea surface elevation (SSE) based on wave parameters</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
          </html>"),
          Icon(graphics = {Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = "Linear Wave", fontName = "Arial")}),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end LinearWave;
      annotation(
        Documentation(info = "<html>
          <p>This package contains models for generating regular wave profiles and calculating associated excitation forces.</p>
          <p>The package currently includes:</p>
          <ul>
            <li>LinearWave: A model implementing the linear Airy wave theory</li>
          </ul>
        </html>"),
        Icon(graphics = {Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-90, -70}, {90, -90}}, lineColor = {0, 0, 255}, fillColor = {0, 0, 255}, fillPattern = FillPattern.Solid, textString = "Regular Wave")}));
    end RegularWave;

    package IrregularWave
      /* Package for irregular wave elevation profile and excitation force calculations */
      extends Modelica.Icons.Package;

      model BretschneiderWave "Implementation of Bretschneider wave spectrum for irregular wave generation"
        extends Hydrodynamic.WaveProfile.IrregularWave.IrregularWaveParameters;
      equation
        if frequencySelection == "equalEnergy" then
          S_int = Hydrodynamic.WaveProfile.WaveFunctions.SpectrumFunctions.spectrumGenerator_BRT(Hs, omega_int, omega_peak) "Spectral values for frequency components [m^2-s/rad]";
        elseif frequencySelection == "random" then
          S = Hydrodynamic.WaveProfile.WaveFunctions.SpectrumFunctions.spectrumGenerator_BRT(Hs, omega, omega_peak) "Spectral values for frequency components [m^2-s/rad]";
        end if;
        annotation(
          Documentation(info = "<html>
            <h4>Pierson-Moskowitz Wave Spectrum Model</h4>
            <p>This model implements the Pierson-Moskowitz (PM) wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p>Key features:</p>
            <ul>
              <li>Generates a wave spectrum based on the PM formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <h4>Usage Notes:</h4>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " Pierson Moskowitz ", fontName = "Arial")}, coordinateSystem(initialScale = 0.1)),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end BretschneiderWave;

      model PiersonMoskowitzWave "Implementation of Pierson-Moskowitz (PM) wave spectrum for irregular wave generation"
        extends Hydrodynamic.WaveProfile.IrregularWave.IrregularWaveParameters;
      equation
        if frequencySelection == "equalEnergy" then
          S_int = Hydrodynamic.WaveProfile.WaveFunctions.SpectrumFunctions.spectrumGenerator_PM(Hs, omega_int) "Spectral values for frequency components [m^2-s/rad]";
        elseif frequencySelection == "random" then
          S = Hydrodynamic.WaveProfile.WaveFunctions.SpectrumFunctions.spectrumGenerator_PM(Hs, omega) "Spectral values for frequency components [m^2-s/rad]";
        end if;
        annotation(
          Documentation(info = "<html>
            <h4>Pierson-Moskowitz Wave Spectrum Model</h4>
            <p>This model implements the Pierson-Moskowitz (PM) wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p>Key features:</p>
            <ul>
              <li>Generates a wave spectrum based on the PM formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <h4>Usage Notes:</h4>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " Pierson Moskowitz ", fontName = "Arial")}, coordinateSystem(initialScale = 0.1)),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end PiersonMoskowitzWave;

      model JONSWAPWave "Implementation of JONSWAP wave spectrum for irregular wave generation"
        extends Hydrodynamic.WaveProfile.IrregularWave.IrregularWaveParameters;
        // JONSWAP parameters
        parameter Real spectralWidth_min = 0.07 "Lower spectral bound for JONSWAP" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Real spectralWidth_max = 0.09 "Upper spectral bound for JONSWAP" annotation(
          Dialog(group = "Spectrum Parameters"));
      equation
        if frequencySelection == "equalEnergy" then
          S_int = Hydrodynamic.WaveProfile.WaveFunctions.SpectrumFunctions.spectrumGenerator_JONSWAP(Hs, omega_int, omega_peak, spectralWidth_min, spectralWidth_max) "Spectral values for frequency components [m^2-s/rad]";
        elseif frequencySelection == "random" then
          S = Hydrodynamic.WaveProfile.WaveFunctions.SpectrumFunctions.spectrumGenerator_JONSWAP(Hs, omega, omega_peak, spectralWidth_min, spectralWidth_max) "Spectral values for frequency components [m^2-s/rad]";
        end if;
        annotation(
          Documentation(info = "<html>
            <h4>JONSWAP Wave Spectrum Model</h4>
            <p>This model implements the JONSWAP (Joint North Sea Wave Project) wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p>Key features:</p>
            <ul>
              <li>Generates a wave spectrum based on the JONSWAP formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <h4>Usage Notes:</h4>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
              <li>JONSWAP spectrum is particularly suitable for modeling developing seas and storm conditions</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " JONSWAP ", fontName = "Arial")}),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end JONSWAPWave;

      partial model IrregularWaveParameters "Irregular wave parameter class"
        // Inhertiance from the top-level wave parameter class, modifying the phase shift components
        extends Hydrodynamic.WaveProfile.waveParameters(epsilon = Hydrodynamic.WaveProfile.WaveFunctions.RandomFrequencyFunctions.randomNumberGen(localSeed1, globalSeed1, n_omega));
        // Irregular wave spectrum parameters
        parameter String frequencySelection = "random" annotation(
          Dialog(group = "Wave Spectrum Parameters"),
          choices(choice = "random", choice = "equalEnergy"));
        parameter Modelica.Units.SI.AngularFrequency omega_min = 0.03141 "Lowest frequency component [rad/s]" annotation(
          Dialog(group = "Wave Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_max = 3.141 "Highest frequency component [rad/s]" annotation(
          Dialog(group = "Wave Spectrum Parameters"));
        // Random freqeuncy selection paramters (will be disabled if user opts to use equal energy method)
        parameter Integer localSeed = 614657 "Local random seed for frequency selection" annotation(
          Dialog(group = "Random Frequency Selection", enable = frequencySelection == "random"));
        parameter Integer globalSeed = 30020 "Global random seed for frequency selection" annotation(
          Dialog(group = "Random Frequency Selection", enable = frequencySelection == "random"));
        parameter Integer localSeed1 = 614757 "Local random seed for phase shifts" annotation(
          Dialog(group = "Random Frequency Selection", enable = frequencySelection == "random"));
        parameter Integer globalSeed1 = 40020 "Global random seed for phase shifts" annotation(
          Dialog(group = "Random Frequency Selection", enable = frequencySelection == "random"));
        // Equal Energy Parameters
        parameter Integer n_omega_int = 500 "Number of frequency components for spectrum generation and integration (equal energy only)" annotation(
          Dialog(group = "Equal Energy Frequency Selection", enable = frequencySelection == "equalEnergy"));
      protected
        // Random phase shift
        parameter Real rnd_shft[n_omega] = Hydrodynamic.WaveProfile.WaveFunctions.RandomFrequencyFunctions.randomNumberGen(localSeed, globalSeed, n_omega) "Random shifts for frequency selection";
        // Frequency selection and wave spectrum
        Modelica.Units.SI.AngularFrequency domega[n_omega] "Frequency step size [rad/s]";
        Hydrodynamic.Units.SpectrumEnergyDensity S[n_omega] "Wave energy spectrum [m^2 s/rad]";
        Modelica.Units.SI.AngularFrequency omega_int[n_omega_int] "Integration frequency step size (equal energy only) [rad/s]";
        Hydrodynamic.Units.SpectrumEnergyDensity S_int[n_omega_int] "Integratation wave energy spectrum [m^2 s/rad]";
      equation
// Calculate wave parameter
        domega = Hydrodynamic.WaveProfile.WaveFunctions.SpectrumFunctions.Calculations.frequencyStepGen(omega, S, n_omega);
        zeta = sqrt(2*S.*domega);
// Select equal energy or random frequency selection
        if frequencySelection == "equalEnergy" then
          omega_int = Hydrodynamic.WaveProfile.WaveFunctions.SpectrumFunctions.Calculations.integrationFrequencyGen(omega_min, omega_max, n_omega_int);
          (omega, S) = Hydrodynamic.WaveProfile.WaveFunctions.EqualEnergyFrequencyFunctions.equalEnergyFrequencySelector(omega_min, omega_max, n_omega, n_omega_int, omega_int, S_int);
        elseif frequencySelection == "random" then
          omega = Hydrodynamic.WaveProfile.WaveFunctions.RandomFrequencyFunctions.randomFrequencySelector(omega_min, omega_max, rnd_shft) "Selected frequency components [rad/s]";
          omega_int = zeros(n_omega_int);
          S_int = zeros(n_omega_int);
        end if;
        annotation(
          Documentation(info = "<html>
            <p><b>Bretschneider Wave Spectrum Model</b></p>
            <p>This model implements the Bretschneider wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p><b>Key features:</b></p>
            <ul>
              <li>Generates a wave spectrum based on the Bretschneider formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <p><b>Usage Notes:</b></p>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " Bretschneider ", fontName = "Arial")}, coordinateSystem(initialScale = 0.1)),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end IrregularWaveParameters;

      model Bus_PiersonMoskowitzWave "Implementation of Pierson-Moskowitz (PM) wave spectrum for irregular wave generation"
        extends Hydrodynamic.WaveProfile.IrregularWave.Bus_IrregularWaveParameters;
      equation
        if frequencySelection == "equalEnergy" then
          S_int = Hydrodynamic.WaveProfile.WaveFunctions.SpectrumFunctions.spectrumGenerator_PM(Hs, omega_int) "Spectral values for frequency components [m^2-s/rad]";
        elseif frequencySelection == "random" then
          S = Hydrodynamic.WaveProfile.WaveFunctions.SpectrumFunctions.spectrumGenerator_PM(Hs, omega) "Spectral values for frequency components [m^2-s/rad]";
        end if;
        annotation(
          Documentation(info = "<html>
            <h4>Pierson-Moskowitz Wave Spectrum Model</h4>
            <p>This model implements the Pierson-Moskowitz (PM) wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p>Key features:</p>
            <ul>
              <li>Generates a wave spectrum based on the PM formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <h4>Usage Notes:</h4>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " Pierson Moskowitz ", fontName = "Arial")}, coordinateSystem(initialScale = 0.1)),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end Bus_PiersonMoskowitzWave;

      partial model Bus_IrregularWaveParameters "Irregular wave parameter class"
        // Inhertiance from the top-level wave parameter class, modifying the phase shift components
        extends Hydrodynamic.WaveProfile.Bus_waveParameters(epsilon = Hydrodynamic.WaveProfile.WaveFunctions.RandomFrequencyFunctions.randomNumberGen(localSeed1, globalSeed1, n_omega));
        // Irregular wave spectrum parameters
        parameter String frequencySelection = "random" annotation(
          Dialog(group = "Wave Spectrum Parameters"),
          choices(choice = "random", choice = "equalEnergy"));
        parameter Modelica.Units.SI.AngularFrequency omega_min = 0.03141 "Lowest frequency component [rad/s]" annotation(
          Dialog(group = "Wave Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_max = 3.141 "Highest frequency component [rad/s]" annotation(
          Dialog(group = "Wave Spectrum Parameters"));
        // Random freqeuncy selection paramters (will be disabled if user opts to use equal energy method)
        parameter Integer localSeed = 614657 "Local random seed for frequency selection" annotation(
          Dialog(group = "Random Frequency Selection", enable = frequencySelection == "random"));
        parameter Integer globalSeed = 30020 "Global random seed for frequency selection" annotation(
          Dialog(group = "Random Frequency Selection", enable = frequencySelection == "random"));
        parameter Integer localSeed1 = 614757 "Local random seed for phase shifts" annotation(
          Dialog(group = "Random Frequency Selection", enable = frequencySelection == "random"));
        parameter Integer globalSeed1 = 40020 "Global random seed for phase shifts" annotation(
          Dialog(group = "Random Frequency Selection", enable = frequencySelection == "random"));
        // Equal Energy Parameters
        parameter Integer n_omega_int = 500 "Number of frequency components for spectrum generation and integration (equal energy only)" annotation(
          Dialog(group = "Equal Energy Frequency Selection", enable = frequencySelection == "equalEnergy"));
      protected
        // Random phase shift
        parameter Real rnd_shft[n_omega] = Hydrodynamic.WaveProfile.WaveFunctions.RandomFrequencyFunctions.randomNumberGen(localSeed, globalSeed, n_omega) "Random shifts for frequency selection";
        // Frequency selection and wave spectrum
        Modelica.Units.SI.AngularFrequency domega[n_omega] "Frequency step size [rad/s]";
        Hydrodynamic.Units.SpectrumEnergyDensity S[n_omega] "Wave energy spectrum [m^2 s/rad]";
        Modelica.Units.SI.AngularFrequency omega_int[n_omega_int] "Integration frequency step size (equal energy only) [rad/s]";
        Hydrodynamic.Units.SpectrumEnergyDensity S_int[n_omega_int] "Integratation wave energy spectrum [m^2 s/rad]";
      equation
// Calculate wave parameter
        domega = Hydrodynamic.WaveProfile.WaveFunctions.SpectrumFunctions.Calculations.frequencyStepGen(omega, S, n_omega);
        zeta = sqrt(2*S.*domega);
// Select equal energy or random frequency selection
        if frequencySelection == "equalEnergy" then
          omega_int = Hydrodynamic.WaveProfile.WaveFunctions.SpectrumFunctions.Calculations.integrationFrequencyGen(omega_min, omega_max, n_omega_int);
          (omega, S) = Hydrodynamic.WaveProfile.WaveFunctions.EqualEnergyFrequencyFunctions.equalEnergyFrequencySelector(omega_min, omega_max, n_omega, n_omega_int, omega_int, S_int);
        elseif frequencySelection == "random" then
          omega = Hydrodynamic.WaveProfile.WaveFunctions.RandomFrequencyFunctions.randomFrequencySelector(omega_min, omega_max, rnd_shft) "Selected frequency components [rad/s]";
          omega_int = zeros(n_omega_int);
          S_int = zeros(n_omega_int);
        end if;
        annotation(
          Documentation(info = "<html>
            <p><b>Bretschneider Wave Spectrum Model</b></p>
            <p>This model implements the Bretschneider wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p><b>Key features:</b></p>
            <ul>
              <li>Generates a wave spectrum based on the Bretschneider formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <p><b>Usage Notes:</b></p>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " Bretschneider ", fontName = "Arial")}, coordinateSystem(initialScale = 0.1)),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end Bus_IrregularWaveParameters;
      annotation(
        Documentation(info = "<html>
      <p><strong>IrregularWave Package</strong></p>
      <p>This package provides models for generating irregular wave profiles and calculating associated excitation forces using various wave spectra commonly used in ocean engineering and naval architecture.</p>
      <p><em>Included Models:</em></p>
      <ul>
        <p><strong>PiersonMoskowitzWave:</strong> Implements the Pierson-Moskowitz spectrum, suitable for fully developed seas.</p>
        <p><strong>BretschneiderWave:</strong> Implements the Bretschneider spectrum, a two-parameter spectrum also known as the modified Pierson-Moskowitz spectrum.</p>
        <p><strong>JonswapWave:</strong> Implements the JONSWAP (Joint North Sea Wave Project) spectrum, particularly useful for modeling developing seas and storm conditions.</p>
      </ul>
      <p>Each model provides options for customizing sea state parameters and offers both wave elevation profiles and excitation force calculations.</p>
    </html>"),
        Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-90, -70}, {90, -90}}, lineColor = {0, 0, 255}, fillColor = {0, 0, 255}, fillPattern = FillPattern.Solid, textString = "Irregular Wave")}));
    end IrregularWave;

    partial model waveParameters "Top-level wave parameter class"
      // Inheritance
      extends Hydrodynamic.HydroDataImport.physicalConstantData;
      extends Hydrodynamic.HydroDataImport.excitationData;
      extends Hydrodynamic.Connector.forceandTorque_con;
      extends Hydrodynamic.Models.physicalConstants;
      extends Hydrodynamic.Models.forceTorque;
      // Wave and environmental parameters
      parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
        Dialog(group = "Wave Spectrum Parameters"));
      parameter Modelica.Units.SI.AngularFrequency omega_peak = 0.9423 "Peak spectral frequency [rad/s]" annotation(
        Dialog(group = "Wave Spectrum Parameters"));
      parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
        Dialog(group = "Wave Spectrum Parameters"));
      // Simulation parameters
      parameter Integer n_omega = 100 "Number of frequency components" annotation(
        Dialog(group = "Simulation Parameters"));
      parameter Modelica.Units.SI.Time Trmp = 200 "Interval for ramping up of waves during start phase [s]" annotation(
        Dialog(group = "Simulation Parameters"));
      Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
    protected
      // Derived parameters
      Modelica.Units.SI.AngularFrequency omega[n_omega] "Frequency components selected for simulation [rad/s]";
      Modelica.Units.SI.Length zeta[n_omega] "Wave amplitude component [m]";
      Modelica.Units.SI.Time Tp[n_omega] "Wave period components [s]";
      Modelica.Units.SI.WaveNumber k[n_omega] "Wave number component [1/m]";
      Real ExcCoeffRe[nDoF, n_omega] "Real component of excitation coefficient for frequency components";
      Real ExcCoeffIm[nDoF, n_omega] "Imaginary component of excitation coefficient for frequency components";
      //Real F_exc[nDoF] "6D excitation force [N]";
      parameter Real epsilon[n_omega] "Wave components phase shift";
    equation
// Calculate wave parameters
      Tp = 2*pi./omega;
      k = Hydrodynamic.WaveProfile.WaveFunctions.WaveParameterFunctions.waveNumber(d, omega);
// Interpolate excitation coefficients (Re & Im) for each frequency component and for each DoF
      for i in 1:nDoF loop
        for j in 1:n_omega loop
          ExcCoeffRe[i, j] = Modelica.Math.Vectors.interpolate(w, F_excRe[i, :], omega[j])*rho*g;
          ExcCoeffIm[i, j] = Modelica.Math.Vectors.interpolate(w, F_excIm[i, :], omega[j])*rho*g;
        end for;
      end for;
// Calculate sea surface elevation (SSE) as the sum of all wave components
      SSE = sum(zeta.*cos(omega*time - 2*pi*epsilon));
// Calculate the excitation force
      for i in 1:nDoF loop
// Calculate and apply ramping to the excitation force
        if time < Trmp then
// Ramp up the excitation force during the initial phase
          f[i] = 0.5*(1 + cos(pi + (pi*time/Trmp)))*sum((ExcCoeffRe[i].*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm[i].*zeta.*sin(omega*time - 2*pi*epsilon)));
        else
// Apply full excitation force after the ramping period
          f[i] = sum((ExcCoeffRe[i].*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm[i].*zeta.*sin(omega*time - 2*pi*epsilon)));
        end if;
      end for;
// Assign excitation force to output
      F = f[1:3];
      T = f[4:6];
      annotation(
        Documentation(info = "<html>
          <p>This model implements the linear Airy wave theory to calculate wave elevation profiles and associated excitation forces.</p>
          <p>Key features:</p>
          <ul>
            <li>Calculates sea surface elevation (SSE) based on wave parameters</li>
            <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
            <li>Applies a ramping function to the excitation force during the initial phase</li>
            <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
          </ul>
          <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
        </html>"),
        Icon(graphics = {Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " Linear Wave 2 ", fontName = "Arial")}),
        experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
    end waveParameters;

    package WaveFunctions
      package EqualEnergyFrequencyFunctions
        function equalEnergyFrequencySelector
          // Can lead to errors if n_omega and n_omega_int are not selected properly, need to make more rubust
          input Real omega_min "Minimum frequency [rad/s]";
          input Real omega_max "Maximum frequency [rad/s]";
          constant input Integer n_omega "Number of frequency compenents defining the spectrum";
          constant input Integer n_omega_int "Number of steps for integrating the spectrum";
          input Real omega_int[n_omega_int] "Integration frquencies";
          input Real S_int[n_omega_int] "Energy Spectrum";
          output Real omega[n_omega] "Output vector of selected frequency components [rad/s]";
          output Real S[n_omega];
          //output Real Cum_energy[n_omega_int] "Vector of cumulative spectrum interval areas";
          //output Real eng_check[n_omega];
          //output Real energy_sum;
          //output Real mean_energy;
          //output Real new_energy;
        protected
          Real domega = (omega_max - omega_min)/(n_omega_int - 1) "Omega int frequency step";
          Real Cum_energy[n_omega_int] "Vector of cumulative spectrum interval areas";
          Real tot_energy "Total energy in the spectrum";
          Real energy "Element to iterate current area off of";
          //Real mean_energy;
          Real tolerance "Tolerance for area";
          //Real current_energy_diff, next_energy_diff;
          //Integer k = 1;
          Real mean_energy;
          Real new_energy;
        algorithm
//energy_sum := 0;
          new_energy := 0;
          Cum_energy[1] := 0;
          omega[1] := omega_min;
          omega[n_omega] := omega_max;
          S[1] := S_int[1];
          S[n_omega] := S_int[n_omega_int];
          for i in 2:n_omega_int loop
            energy := Hydrodynamic.Internal.Functions.trapIntegration(S_int[i - 1], S_int[i], domega);
            Cum_energy[i] := Cum_energy[i - 1] + energy;
          end for;
          tot_energy := Cum_energy[end];
          mean_energy := tot_energy/(n_omega - 1);
          tolerance := mean_energy/5;
          for i in 2:(n_omega - 1) loop
// This is really sensitive to integration step size, need to make more robust
/* for j in k:(n_omega_int-1) loop
                current_energy_diff := abs(Cum_energy[j] - Cum_energy[k] - mean_energy);
                next_energy_diff := abs(Cum_energy[j+1] - Cum_energy[k] - mean_energy);
              
                if  Cum_energy[j] - Cum_energy[k] >= mean_energy or current_energy_diff <= tolerance then 
                  omega[i] := omega_int[j];
                  S[i] := S_int[j];
                  eng_check[i] := Cum_energy[j] - Cum_energy[k];
                  energy_sum := energy_sum + eng_check[i];
                  k := j;
                  break;
                end if;
                
              end for; */
//for j in k:(n_omega_int-1) loop
            new_energy := new_energy + mean_energy;
            omega[i] := Modelica.Math.Vectors.interpolate(Cum_energy, omega_int, new_energy);
            S[i] := Modelica.Math.Vectors.interpolate(omega_int, S_int, omega[i]);
//end for; */
          end for;
        end equalEnergyFrequencySelector;
      end EqualEnergyFrequencyFunctions;

      package RandomFrequencyFunctions
        function randomNumberGen "Function to generate random numbers using XOR shift algorithm"
          /* Produces a vector of random numbers based on local and global seeds
                                                             This function utilizes the Xorshift64star algorithm for efficient random number generation */
          input Integer ls = 614657 "Local seed for random number generation";
          input Integer gs = 30020 "Global seed for random number generation";
          constant input Integer n = 100 "Number of random numbers to generate";
          output Real r64[n] "Vector of generated random numbers";
        protected
          Integer state64[2](each start = 0, each fixed = true) "State vector for XOR shift algorithm";
        algorithm
          state64[1] := 0;
          state64[2] := 0;
          for i in 1:n loop
            if i == 1 then
              state64 := Modelica.Math.Random.Generators.Xorshift64star.initialState(ls, gs);
              r64[i] := 0;
            else
              (r64[i], state64) := Modelica.Math.Random.Generators.Xorshift64star.random((state64));
            end if;
          end for;
          annotation(
            Documentation(info = "<html>
            <p>Syntax: r64 = randomNumberGen(ls, gs, n)</p>
            <p>Description: This function generates a vector of random numbers using the Xorshift64star algorithm, which is known for its efficiency and good statistical properties.</p>
            <p>Inputs:</p>
            <ul>
              <li><code>ls</code>: Local seed for random number generation (default: 614657)</li>
              <li><code>gs</code>: Global seed for random number generation (default: 30020)</li>
              <li><code>n</code>: Number of random numbers to generate (default: 100)</li>
            </ul>
            <p>Outputs:</p>
            <ul>
              <li><code>r64</code>: Vector of generated random numbers</li>
            </ul>
            <p>Algorithm: The function uses the Xorshift64star algorithm to generate random numbers based on the provided seeds.</p>
          </html>"),
            Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "RNG", textStyle = {TextStyle.Bold})}));
        end randomNumberGen;

        function randomFrequencySelector "Function to randomly select frequency components within a specified range"
          /* Uses a random phase vector to perturb frequencies
                                                             This function ensures a good distribution of frequencies for irregular wave generation */
          constant input Real omega_min "Minimum frequency [rad/s]";
          constant input Real omega_max "Maximum frequency [rad/s]";
          constant input Real epsilon[:] "Random phase vector for frequency perturbation";
          output Real omega[size(epsilon, 1)] "Output vector of selected frequency components [rad/s]";
        protected
          parameter Real ref_omega[size(epsilon, 1)] = omega_min:(omega_max - omega_min)/(size(epsilon, 1) - 1):omega_max "Reference frequency vector [rad/s]";
        algorithm
          omega[1] := omega_min;
          for i in 2:size(epsilon, 1) - 1 loop
            omega[i] := ref_omega[i] + epsilon[i]*omega_min;
          end for;
          omega[size(epsilon, 1)] := omega_max;
          annotation(
            Documentation(info = "<html>
            <p>Syntax: omega = frequencySelector(omega_min, omega_max, epsilon)</p>
            <p>Description: This function selects frequency components within a specified range, using a random phase vector to perturb the frequencies. This ensures a good distribution of frequencies for irregular wave generation.</p>
            <p>Inputs:</p>
            <ul>
              <li><code>omega_min</code>: Minimum frequency [rad/s]</li>
              <li><code>omega_max</code>: Maximum frequency [rad/s]</li>
              <li><code>epsilon</code>: Random phase vector for frequency perturbation</li>
            </ul>
            <p>Outputs:</p>
            <ul>
              <li><code>omega</code>: Output vector of selected frequency components [rad/s]</li>
            </ul>
            <p>Algorithm: The function creates a reference frequency vector and then perturbs it using the random phase vector, ensuring the first and last frequencies are exactly omega_min and omega_max.</p>
          </html>"),
            Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "ω(ε)", textStyle = {TextStyle.Bold})}));
        end randomFrequencySelector;
      end RandomFrequencyFunctions;

      package SpectrumFunctions
        function spectrumGenerator_PM "Function to generate Pierson-Moskowitz spectrum"
          /* Calculates spectral values for given frequencies based on significant wave height
                                                             This function implements the Pierson-Moskowitz spectrum, suitable for fully developed seas */
          input Real Hs = 1 "Significant wave height [m]";
          input Real omega[:] "Array of frequency components [rad/s]";
          output Real spec[size(omega, 1)] "Array of spectral values for input frequencies [m^2s]";
        protected
          constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
          constant Real g = Modelica.Constants.g_n "Gravitational acceleration [m/s^2]";
        algorithm
          for i in 1:size(omega, 1) loop
            spec[i] := 0.0081*g^2/omega[i]^5*exp(-0.0358*(g/(Hs*omega[i]^2))^2);
          end for;
          annotation(
            Documentation(info = "<html>
            <p>Syntax: spec = spectrumGenerator_PM(Hs, omega)</p>
            <p>Description: This function generates the Pierson-Moskowitz spectrum, which is suitable for fully developed seas. It calculates spectral values for given frequencies based on the significant wave height.</p>
            <p>Inputs:</p>
            <ul>
              <li><code>Hs</code>: Significant wave height [m] (default: 1)</li>
              <li><code>omega</code>: Array of frequency components [rad/s]</li>
            </ul>
            <p>Outputs:</p>
            <ul>
              <li><code>spec</code>: Array of spectral values for input frequencies [m^2s]</li>
            </ul>
            <p>Algorithm: The function calculates spectral values using the Pierson-Moskowitz formula: S(ω) = 0.0081*g^2/ω^5 * exp(-0.0358*(g/(Hs*ω^2))^2)</p>
          </html>"),
            Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "PM", textStyle = {TextStyle.Bold})}));
        end spectrumGenerator_PM;

        function spectrumGenerator_BRT "Function to generate Bretschneider spectrum"
          /* Calculates spectral values based on significant wave height and peak frequency
                                                             This function implements the Bretschneider spectrum, a two-parameter spectrum for fetch-limited seas */
          input Real Hs = 1 "Significant wave height [m]";
          input Real omega[:] "Array of frequency components [rad/s]";
          input Real omega_peak = 0.9423 "Peak spectral frequency [rad/s]";
          output Real spec[size(omega, 1)] "Array of spectral values for input frequencies [m^2s]";
        protected
          constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
          constant Real g = Modelica.Constants.g_n "Gravitational acceleration [m/s^2]";
        algorithm
          for i in 1:size(omega, 1) loop
            spec[i] := 1.9635*Hs^2*omega_peak^4/omega[i]^5*exp(-1.25*((omega_peak/omega[i])^4));
          end for;
          annotation(
            Documentation(info = "<html>
            <p>Syntax: spec = spectrumGenerator_BRT(Hs, omega, omega_peak)</p>
            <p>Description: This function generates the Bretschneider spectrum, which is a two-parameter spectrum suitable for fetch-limited seas. It calculates spectral values based on significant wave height and peak frequency.</p>
            <p>Inputs:</p>
            <ul>
              <li><code>Hs</code>: Significant wave height [m] (default: 1)</li>
              <li><code>omega</code>: Array of frequency components [rad/s]</li>
              <li><code>omega_peak</code>: Peak spectral frequency [rad/s] (default: 0.9423)</li>
            </ul>
            <p>Outputs:</p>
            <ul>
              <li><code>spec</code>: Array of spectral values for input frequencies [m^2s]</li>
            </ul>
            <p>Algorithm: The function calculates spectral values using the Bretschneider formula: S(ω) = 1.9635*Hs^2*ω_peak^4/ω^5 * exp(-1.25*((ω_peak/ω)^4))</p>
          </html>"),
            Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "BRT", textStyle = {TextStyle.Bold})}));
        end spectrumGenerator_BRT;

        function spectrumGenerator_JONSWAP "Function to generate JONSWAP (Joint North Sea Wave Project) spectrum"
          /* Calculates spectral values based on significant wave height, peak frequency, and spectral width parameters
                                                             This function implements the JONSWAP spectrum, suitable for developing seas with fetch limitations */
          input Real Hs = 1 "Significant wave height [m]";
          input Real omega[:] "Array of frequency components [rad/s]";
          input Real omega_peak = 0.9423 "Peak spectral frequency [rad/s]";
          input Real spectralWidth_min "Minimum spectral width parameter";
          input Real spectralWidth_max "Maximum spectral width parameter";
          output Real spec[size(omega, 1)] "Array of spectral values for input frequencies [m^2s]";
        protected
          constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
          constant Real g = Modelica.Constants.g_n "Gravitational acceleration [m/s^2]";
          constant Real gamma = 3.3 "Peak enhancement factor for JONSWAP spectrum";
          Real sigma "Spectral width parameter";
          Real b "Exponent for peak enhancement factor";
        algorithm
          for i in 1:size(omega, 1) loop
            if omega[i] > omega_peak then
              sigma := spectralWidth_max;
            else
              sigma := spectralWidth_min;
            end if;
            b := exp(-0.5*(((omega[i] - omega_peak)/(sigma*omega_peak))^2));
            spec[i] := 0.0081*g^2/omega[i]^5*exp(-1.25*((omega_peak/omega[i])^4))*gamma^b;
          end for;
          annotation(
            Documentation(info = "<html>
            <p>Syntax: spec = spectrumGenerator_JONSWAP(Hs, omega, omega_peak, spectralWidth_min, spectralWidth_max)</p>
            <p>Description: This function generates the JONSWAP (Joint North Sea Wave Project) spectrum, which is suitable for developing seas with fetch limitations. It calculates spectral values based on significant wave height, peak frequency, and spectral width parameters.</p>
            <p>Inputs:</p>
            <ul>
              <li><code>Hs</code>: Significant wave height [m] (default: 1)</li>
              <li><code>omega</code>: Array of frequency components [rad/s]</li>
              <li><code>omega_peak</code>: Peak spectral frequency [rad/s] (default: 0.9423)</li>
              <li><code>spectralWidth_min</code>: Minimum spectral width parameter</li>
              <li><code>spectralWidth_max</code>: Maximum spectral width parameter</li>
            </ul>
            <p>Outputs:</p>
            <ul>
              <li><code>spec</code>: Array of spectral values for input frequencies [m^2s]</li>
            </ul>
            <p>Algorithm: The function calculates spectral values using the JONSWAP formula, which is an extension of the Pierson-Moskowitz spectrum with additional parameters to account for fetch-limited seas.</p>
          </html>"),
            Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "JONSWAP", textStyle = {TextStyle.Bold})}));
        end spectrumGenerator_JONSWAP;

        package Calculations
          function frequencyStepGen
            input Real omega[n_omega];
            input Real S[n_omega];
            constant input Integer n_omega;
            output Real domega[n_omega];
          protected
            Real omega_mean;
          algorithm
            for i in 2:n_omega loop
              domega[i] := omega[i] - omega[i - 1];
            end for;
            omega_mean := sum(domega)/n_omega;
            domega[1] := omega_mean;
          end frequencyStepGen;

          function integrationFrequencyGen
            input Real omega_min "Minimum frequency [rad/s]";
            input Real omega_max "Maximum frequency [rad/s]";
            constant input Integer n_omega_int "Number of frequency compenents defining the spectrum";
            output Real omega_int[n_omega_int];
            // = omega_min:domega_int:omega_max "Frequencies for spectrum generation and integration";
          protected
            Real domega_int = (omega_max - omega_min)/(n_omega_int - 1) "Frequency step size";
          algorithm
            for i in 1:n_omega_int loop
              omega_int[i] := omega_min + (i - 1)*(omega_max - omega_min)/(n_omega_int - 1);
            end for;
          end integrationFrequencyGen;

          function trapezoidalIntegration
            input Real y1;
            input Real y2;
            input Real domega;
            output Real Area;
          algorithm
            Area := 0.5*domega*(y1 + y2);
          end trapezoidalIntegration;
        end Calculations;
      end SpectrumFunctions;

      package WaveParameterFunctions
        function waveNumber "Function to iteratively compute the wave number from frequency components"
          /* Uses the dispersion relationship for water waves to calculate wave numbers
                                                               This function implements an iterative method to solve the implicit dispersion equation */
          input Real d "Water depth [m]";
          input Real omega[:] "Array of wave frequency components [rad/s]";
          output Real k[size(omega, 1)] "Array of wave number components [rad/m]";
        protected
          constant Real g = Modelica.Constants.g_n "Gravitational acceleration [m/s^2]";
          constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
          parameter Integer n = size(omega, 1) "Number of frequency components";
          Real T[size(omega, 1)] "Array of wave period components [s]";
          Real L0[size(omega, 1)] "Array of deepwater wavelength components [m]";
          Real L1(start = 0, fixed = true) "Temporary variable for wavelength iteration [m]";
          Real L1c(start = 0, fixed = true) "Temporary variable for wavelength iteration comparison [m]";
          Real L[size(omega, 1)] "Array of iterated wavelength components [m]";
        algorithm
          T := 2*pi./omega;
          L0 := g*T.^2/(2*pi);
          for i in 1:size(omega, 1) loop
            L1 := L0[i];
            L1c := 0;
            while abs(L1c - L1) > 0.001 loop
              L1c := L1;
              L[i] := g*T[i]^2/(2*pi)*tanh(2*pi/L1*d);
              L1 := L[i];
            end while;
          end for;
          k := 2*pi./L;
          annotation(
            Documentation(info = "<html>
              <p>Syntax: k = waveNumber(d, omega)</p>
              <p>Description: This function calculates wave numbers for given frequencies and water depth using the dispersion relationship for water waves. It employs an iterative method to solve the implicit dispersion equation.</p>
              <p>Inputs:</p>
              <ul>
                <li><code>d</code>: Water depth [m]</li>
                <li><code>omega</code>: Array of wave frequency components [rad/s]</li>
              </ul>
              <p>Outputs:</p>
              <ul>
                <li><code>k</code>: Array of wave number components [rad/m]</li>
              </ul>
              <p>Algorithm:</p>
              <ol>
                <li>Calculate wave periods from frequencies</li>
                <li>Calculate deepwater wavelengths</li>
                <li>Iterate to solve the dispersion equation for each frequency component</li>
                <li>Convert wavelengths to wave numbers</li>
              </ol>
            </html>"),
            Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "k(ω)", textStyle = {TextStyle.Bold}), Line(points = {{-80, -80}, {80, 80}}, color = {0, 0, 255}, thickness = 0.5)}),
            Diagram(graphics = {Text(extent = {{-100, 80}, {100, 40}}, textString = "Wave Number Calculation"), Line(points = {{-80, 0}, {80, 0}}, color = {0, 0, 255}), Line(points = {{0, -80}, {0, 80}}, color = {0, 0, 255}), Text(extent = {{-60, -20}, {60, -60}}, textString = "k = 2π/L")}),
            experiment(StopTime = 1.0, Tolerance = 1e-06));
        end waveNumber;
      end WaveParameterFunctions;
    end WaveFunctions;

    model WaveAndCurrentBus
      extends Hydrodynamic.Connector.forceandTorque_con;
      //Output
      extends Hydrodynamic.Connector.WaveforceTorqueSum_con;
      //Input
      Real f[6];
    equation
      f = Fw;
      F = f[1:3];
      T = f[4:6];
    end WaveAndCurrentBus;

    partial model Bus_waveParameters "Top-level wave parameter class"
      // Inheritance
      extends Hydrodynamic.HydroDataImport.physicalConstantData;
      extends Hydrodynamic.HydroDataImport.excitationData;
      extends Hydrodynamic.Models.physicalConstants;
      extends Hydrodynamic.Models.forceTorque;
      // Wave and environmental parameters
      parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
        Dialog(group = "Wave Spectrum Parameters"));
      parameter Modelica.Units.SI.AngularFrequency omega_peak = 0.9423 "Peak spectral frequency [rad/s]" annotation(
        Dialog(group = "Wave Spectrum Parameters"));
      parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
        Dialog(group = "Wave Spectrum Parameters"));
      // Simulation parameters
      parameter Integer n_omega = 100 "Number of frequency components" annotation(
        Dialog(group = "Simulation Parameters"));
      parameter Modelica.Units.SI.Time Trmp = 200 "Interval for ramping up of waves during start phase [s]" annotation(
        Dialog(group = "Simulation Parameters"));
      Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
    protected
      // Derived parameters
      Modelica.Units.SI.AngularFrequency omega[n_omega] "Frequency components selected for simulation [rad/s]";
      Modelica.Units.SI.Length zeta[n_omega] "Wave amplitude component [m]";
      Modelica.Units.SI.Time Tp[n_omega] "Wave period components [s]";
      Modelica.Units.SI.WaveNumber k[n_omega] "Wave number component [1/m]";
      Real ExcCoeffRe[nDoF, n_omega] "Real component of excitation coefficient for frequency components";
      Real ExcCoeffIm[nDoF, n_omega] "Imaginary component of excitation coefficient for frequency components";
      //Real F_exc[nDoF] "6D excitation force [N]";
      parameter Real epsilon[n_omega] "Wave components phase shift";
    equation
// Calculate wave parameters
      Tp = 2*pi./omega;
      k = Hydrodynamic.WaveProfile.WaveFunctions.WaveParameterFunctions.waveNumber(d, omega);
// Interpolate excitation coefficients (Re & Im) for each frequency component and for each DoF
      for i in 1:nDoF loop
        for j in 1:n_omega loop
          ExcCoeffRe[i, j] = Modelica.Math.Vectors.interpolate(w, F_excRe[i, :], omega[j])*rho*g;
          ExcCoeffIm[i, j] = Modelica.Math.Vectors.interpolate(w, F_excIm[i, :], omega[j])*rho*g;
        end for;
      end for;
// Calculate sea surface elevation (SSE) as the sum of all wave components
      SSE = sum(zeta.*cos(omega*time - 2*pi*epsilon));
// Calculate the excitation force
      for i in 1:nDoF loop
// Calculate and apply ramping to the excitation force
        if time < Trmp then
// Ramp up the excitation force during the initial phase
          f[i] = 0.5*(1 + cos(pi + (pi*time/Trmp)))*sum((ExcCoeffRe[i].*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm[i].*zeta.*sin(omega*time - 2*pi*epsilon)));
        else
// Apply full excitation force after the ramping period
          f[i] = sum((ExcCoeffRe[i].*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm[i].*zeta.*sin(omega*time - 2*pi*epsilon)));
        end if;
      end for;
// Assign excitation force to output
      F = f;
      annotation(
        Documentation(info = "<html>
          <p>This model implements the linear Airy wave theory to calculate wave elevation profiles and associated excitation forces.</p>
          <p>Key features:</p>
          <ul>
            <li>Calculates sea surface elevation (SSE) based on wave parameters</li>
            <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
            <li>Applies a ramping function to the excitation force during the initial phase</li>
            <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
          </ul>
          <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
        </html>"),
        Icon(graphics = {Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " Linear Wave 2 ", fontName = "Arial")}),
        experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
    end Bus_waveParameters;
    annotation(
      Documentation(info = "<html>
      <p><strong>WaveProfile Package</strong></p>
      <p>This package provides comprehensive models for generating wave profiles and calculating associated excitation forces for both regular and irregular waves. It is designed for use in ocean engineering, naval architecture, and offshore structure analysis.</p>
      
      <p><strong>Package Contents:</strong></p>
      <p><strong>1. RegularWave</strong></p>
      <ul>
        <li><strong>LinearWave:</strong> Implements the linear Airy wave theory for regular waves.</li>
      </ul>
      
      <p><strong>2. IrregularWave</strong></p>
      <ul>
        <li><strong>PiersonMoskowitzWave:</strong> Generates irregular waves using the Pierson-Moskowitz spectrum, suitable for fully developed seas.</li>
        <li><strong>BretschneiderWave:</strong> Implements the Bretschneider (modified Pierson-Moskowitz) spectrum for more flexible sea state modeling.</li>
        <li><strong>JonswapWave:</strong> Uses the JONSWAP spectrum, ideal for modeling developing seas and storm conditions.</li>
      </ul>
      
      <p><strong>Key Features:</strong></p>
      <ul>
        <li>Calculation of wave elevation profiles</li>
        <li>Computation of wave-induced excitation forces</li>
        <li>Customizable sea state parameters</li>
        <li>Support for both deterministic (regular) and stochastic (irregular) wave modeling</li>
      </ul>
      
      <p>This package is essential for various marine engineering applications, including offshore structure design, wave energy converter analysis, ship motion studies, and coastal engineering projects.</p>
    </html>"),
      Icon(graphics = {Line(points = {{-90, 20}, {-60, 40}, {-30, 0}, {0, 40}, {30, 0}, {60, 40}, {90, 20}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), // Irregular wave representation
      Line(points = {{-90, -20}, {-75, 0}, {-60, -30}, {-45, -10}, {-30, -40}, {-15, -5}, {0, -35}, {15, -15}, {30, -45}, {45, 0}, {60, -30}, {75, -20}, {90, -40}}, color = {0, 100, 255}, thickness = 2, smooth = Smooth.Bezier)}));
  end WaveProfile;

  package Connector
    extends Modelica.Icons.Package;

    connector absolutePosition_con
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput u_abs[3] "Linear displacement vector [m]" annotation(
        Dialog(unit = "m", quantity = "Position"),
        Placement(transformation(origin = {-120, 84}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-118, 82}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealInput theta_abs[3] "Angular displacement vector [rad]" annotation(
        Dialog(unit = "rad", quantity = "Angle"),
        Placement(transformation(origin = {-120, 36}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-118, 28}, extent = {{-20, -20}, {20, 20}})));
      annotation(
        Documentation(info = "<html>
        <p><strong>absolutePosition_con Connector</strong></p>
        <p>This connector is used to specify the absolute position and orientation of a component in a 3-dimensional space. It provides input ports for defining linear and angular displacements.</p>
        <p><strong>Ports:</strong></p>
        <ul>
          <li><strong>u_abs:</strong> A 3-dimensional vector representing linear displacement in meters. This vector describes the position of the component in space relative to a reference point.</li>
          <li><strong>theta_abs:</strong> A 3-dimensional vector representing angular displacement in radians. This vector describes the orientation of the component around each axis.</li>
        </ul>
        <p><strong>Usage:</strong></p>
        <p>Utilize this connector in models where precise positioning and orientation of components are required, such as in robotic arms, mechanical linkages, or spatial transformations.</p>
        </html>"));
    end absolutePosition_con;

    connector absoluteVelocity_con
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput v_abs[3] "Absolute linear velocity vector [m/s]" annotation(
        Dialog(unit = "m/s", quantity = "Velocity"),
        Placement(transformation(origin = {-120, -42}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-120, -22}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealInput omega_abs[3] "Absolute angular velocity vector [rad/s]" annotation(
        Dialog(unit = "rad/s", quantity = "AngularVelocity"),
        Placement(transformation(origin = {-120, -82}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-120, -76}, extent = {{-20, -20}, {20, 20}})));
      annotation(
        Documentation(info = "<html>
        <p><strong>absoluteVelocity_con Connector</strong></p>
        <p>This connector is designed to provide input ports for absolute velocity vectors. It includes components for both linear and angular velocities.</p>
        <p><strong>Ports:</strong></p>
        <ul>
          <li><strong>v_abs:</strong> A 3-dimensional vector representing absolute linear velocity in meters per second. This vector describes how quickly the component is moving in each spatial direction.</li>
          <li><strong>omega_abs:</strong> A 3-dimensional vector representing absolute angular velocity in radians per second. This vector describes the rate of rotation of the component around each axis.</li>
        </ul>
        <p><strong>Usage:</strong></p>
        <p>Use this connector in systems that require the modeling of velocity effects, such as in dynamic simulations, motion analysis, or control systems for mechanical components.</p>
        </html>"));
    end absoluteVelocity_con;

    connector forceTorque_con
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealOutput F[6] "Force/Torque vector [N, N*m]" annotation(
        Placement(transformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}})));
      annotation(
        Documentation(info = "<html>
        <p><strong>forceTorque_con Connector</strong></p>
        <p>This connector provides an output port for the force and torque vector. It represents the combined forces and torques applied to or exerted by a component in a 6-dimensional space.</p>
        <p><strong>Ports:</strong></p>
        <ul>
          <li><strong>F:</strong> A 6-dimensional vector representing force and torque in Newtons (N) and Newton-meters (N*m), respectively. This vector includes forces in the 3 spatial directions and torques around the 3 axes.</li>
        </ul>
        <p><strong>Usage:</strong></p>
        <p>Employ this connector in models where it is necessary to output or monitor forces and torques, such as in force measurement systems, structural analysis, or mechanical interactions.</p>
        </html>"));
    end forceTorque_con;

    connector inputOutput_con
      extends Modelica.Blocks.Icons.Block;
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a "Input frame" annotation(
        Placement(transformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_b "Output frame" annotation(
        Placement(transformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}})));
      annotation(
        Documentation(info = "<html>
        <p><strong>inputOutput_con Connector</strong></p>
        <p>This connector defines frames for input and output connections in mechanical systems. It is used to link components that interact through these frames.</p>
        <p><strong>Ports:</strong></p>
        <ul>
          <li><strong>frame_a:</strong> Input frame used to connect with another component’s output frame. It provides the reference frame for incoming connections.</li>
          <li><strong>frame_b:</strong> Output frame used to connect with another component’s input frame. It provides the reference frame for outgoing connections.</li>
        </ul>
        <p><strong>Usage:</strong></p>
        <p>Utilize this connector for interfacing between components in mechanical systems where multiple frames of reference are involved, such as in kinematic chains or multi-body simulations.</p>
        </html>"));
    end inputOutput_con;

    connector input_con
      extends Modelica.Blocks.Icons.Block;
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a "Input frame" annotation(
        Placement(transformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}})));
      annotation(
        Documentation(info = "<html>
        <p><strong>input_con Connector</strong></p>
        <p>This connector provides an input frame for connecting components in a mechanical system. It serves as the receiving end of a connection for data or signals.</p>
        <p><strong>Ports:</strong></p>
        <ul>
          <li><strong>frame_a:</strong> Input frame used for connection with other components’ output frames. It defines the reference frame for incoming interactions.</li>
        </ul>
        <p><strong>Usage:</strong></p>
        <p>Use this connector when you need to receive input from other components or systems, such as in data acquisition systems or signal processing modules.</p>
        </html>"));
    end input_con;

    connector forceTorqueSum_con
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput Fr[6] "Radiation Force [N]" annotation(
        Placement(transformation(origin = {-120, 84}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-118, 82}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealInput Fhs[6] "Hydrostatic force [N]" annotation(
        Placement(transformation(origin = {-120, 36}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-118, 28}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealInput Fd[6] "Drag force [N]" annotation(
        Placement(transformation(origin = {-120, -42}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-120, -22}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealInput Fpto[6] "PTO force [N]" annotation(
        Placement(transformation(origin = {-120, -82}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-120, -76}, extent = {{-20, -20}, {20, 20}})));
      annotation(
        Documentation(info = "<html>
        <p><strong>forceTorqueSum_con Connector</strong></p>
        <p>This connector aggregates various components of forces and torques acting on a system. It includes inputs for radiation forces, hydrostatic forces, drag forces, and PTO (Power Take-Off) forces. This comprehensive connector is crucial for summing the effects of different force sources in a mechanical or marine system.</p>
        <p><strong>Ports:</strong></p>
        <ul>
          <li><strong>Fr:</strong> A 6-dimensional vector representing radiation forces in Newtons (N). These forces result from the interaction of a component with radiative waves or fields.</li>
          <li><strong>Fhs:</strong> A 6-dimensional vector representing hydrostatic forces in Newtons (N). These forces arise from the pressure difference in the fluid surrounding the component.</li>
          <li><strong>Fd:</strong> A 6-dimensional vector representing drag forces in Newtons (N). These forces are due to the resistance encountered by the component as it moves through a fluid.</li>
          <li><strong>Fpto:</strong> A 6-dimensional vector representing PTO forces in Newtons (N). These forces are associated with the energy conversion or dissipation mechanisms in wave energy converters or similar systems.</li>
        </ul>
        <p><strong>Usage:</strong></p>
        <p>Employ this connector in models where the cumulative effect of multiple force sources needs to be accounted for. It is particularly useful in simulations involving marine structures, energy converters, or complex mechanical systems with multiple interacting forces.</p>
        </html>"));
    end forceTorqueSum_con;

    connector forceandTorque_con
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealOutput F[3] "Translational drag force vector [N]" annotation(
        Placement(transformation(origin = {108, 50}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {110, 50}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Blocks.Interfaces.RealOutput T[3] "Rotational drag torque vector [N*m]" annotation(
        Placement(transformation(origin = {108, -50}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {108, -50}, extent = {{-10, -10}, {10, 10}})));
      annotation(
        Documentation(info = "<html>
        <p><strong>forceandTorque_con Connector</strong></p>
        <p>This connector provides output ports for drag forces and torques experienced by a component. It specifically measures translational drag forces and rotational drag torques, essential for evaluating the effects of drag on a system.</p>
        <p><strong>Ports:</strong></p>
        <ul>
          <li><strong>F:</strong> A 3-dimensional vector representing translational drag forces in Newtons (N). This vector captures the resistance encountered by the component in each spatial direction.</li>
          <li><strong>T:</strong> A 3-dimensional vector representing rotational drag torques in Newton-meters (N*m). This vector captures the resistance to rotation experienced by the component around each axis.</li>
        </ul>
        <p><strong>Usage:</strong></p>
        <p>Use this connector to monitor or analyze the drag effects on components, which is vital for performance assessments in fluid dynamics, aerodynamics, and other drag-related simulations.</p>
        </html>"));
    end forceandTorque_con;

    connector WaveforceTorqueSum_con
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput Fw[6] "Wave Force [N]" annotation(
        Placement(transformation(origin = {-120, 84}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-118, 82}, extent = {{-20, -20}, {20, 20}})));
      annotation(
        Documentation(info = "<html>
        <p><strong>forceTorqueSum_con Connector</strong></p>
        <p>This connector aggregates various components of forces and torques acting on a system. It includes inputs for radiation forces, hydrostatic forces, drag forces, and PTO (Power Take-Off) forces. This comprehensive connector is crucial for summing the effects of different force sources in a mechanical or marine system.</p>
        <p><strong>Ports:</strong></p>
        <ul>
          <li><strong>Fr:</strong> A 6-dimensional vector representing radiation forces in Newtons (N). These forces result from the interaction of a component with radiative waves or fields.</li>
          <li><strong>Fhs:</strong> A 6-dimensional vector representing hydrostatic forces in Newtons (N). These forces arise from the pressure difference in the fluid surrounding the component.</li>
          <li><strong>Fd:</strong> A 6-dimensional vector representing drag forces in Newtons (N). These forces are due to the resistance encountered by the component as it moves through a fluid.</li>
          <li><strong>Fpto:</strong> A 6-dimensional vector representing PTO forces in Newtons (N). These forces are associated with the energy conversion or dissipation mechanisms in wave energy converters or similar systems.</li>
        </ul>
        <p><strong>Usage:</strong></p>
        <p>Employ this connector in models where the cumulative effect of multiple force sources needs to be accounted for. It is particularly useful in simulations involving marine structures, energy converters, or complex mechanical systems with multiple interacting forces.</p>
        </html>"));
    end WaveforceTorqueSum_con;

    connector absoluteAcceleration_con
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput a_abs[3] "Absolute linear velocity vector [m/s^2]" annotation(
        Dialog(unit = "m/s^2", quantity = "Acceleration"),
        Placement(transformation(origin = {-120, -42}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-120, -22}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealInput alpha_abs[3] "Absolute angular acceleration vector [rad/s^2]" annotation(
        Dialog(unit = "rad/s^2", quantity = "AngularScceleration"),
        Placement(transformation(origin = {-120, -82}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-120, -76}, extent = {{-20, -20}, {20, 20}})));
      annotation(
        Documentation(info = "<html>
        <p><strong>absoluteVelocity_con Connector</strong></p>
        <p>This connector is designed to provide input ports for absolute velocity vectors. It includes components for both linear and angular velocities.</p>
        <p><strong>Ports:</strong></p>
        <ul>
          <li><strong>v_abs:</strong> A 3-dimensional vector representing absolute linear velocity in meters per second. This vector describes how quickly the component is moving in each spatial direction.</li>
          <li><strong>omega_abs:</strong> A 3-dimensional vector representing absolute angular velocity in radians per second. This vector describes the rate of rotation of the component around each axis.</li>
        </ul>
        <p><strong>Usage:</strong></p>
        <p>Use this connector in systems that require the modeling of velocity effects, such as in dynamic simulations, motion analysis, or control systems for mechanical components.</p>
        </html>"));
    end absoluteAcceleration_con;
    annotation(
      Documentation(info = "<html>
      <h4>Connector Package Overview</h4>
      <p>The Connector package provides a set of connectors designed for integrating various force and motion models within a mechanical or marine system simulation. It includes connectors for handling position, velocity, force, torque, and frame interactions.</p>
      <p><strong>Connectors Included:</strong></p>
      <ul>
        <li><strong>absolutePosition_con:</strong> Handles linear and angular displacement vectors, providing inputs for the absolute position of a component. Taking input from the AbsoluteSensor</li>
        <li><strong>absoluteVelocity_con:</strong> Manages absolute linear and angular velocity vectors, offering inputs for the velocities of a component. Taking input from the AbsoluteSensor</li>
        <li><strong>forceTorque_con:</strong> Outputs a combined force and torque vector, essential for systems where forces and torques need to be monitored or applied.</li>
        <li><strong>inputOutput_con:</strong> Connects two frames, representing the input and output frames for mechanical interactions, such as joints or actuators.</li>
        <li><strong>input_con:</strong> Provides a single input frame for applications where only one frame is needed.</li>
        <li><strong>forceTorqueSum_con:</strong> Aggregates various force types (radiation, hydrostatic, drag, PTO) into a single output.</li>
        <li><strong>forceandTorque_con:</strong> Outputs translational drag forces and rotational drag torques, focused on drag-related effects in the system.</li>
      </ul>
      <p><strong>Applications:</strong></p>
      <ul>
        <li>Integration of position and velocity sensors in mechanical systems.</li>
        <li>Combining and analyzing multiple force sources in marine and mechanical simulations.</li>
        <li>Defining and connecting mechanical frames for accurate modeling of interactions.</li>
      </ul>
      <p>This package is essential for creating detailed and accurate simulations of mechanical and marine systems, allowing for comprehensive analysis and system integration. Separates torque and force outputs so they can be past to the worldforceandtorque block</p>
      </html>"));
  end Connector;

  model ForceToqueSum
    extends Modelica.Blocks.Icons.Block;
    extends Hydrodynamic.Connector.forceandTorque_con;
    extends Hydrodynamic.Connector.forceTorqueSum_con;
    Real f[6];
  equation
    f = Fr + Fpto + Fd + Fhs;
    F = f[1:3];
    T = f[4:6];
  end ForceToqueSum;

  model readHydroParam
    extends Modelica.Units.SI;
    extends Modelica.Icons.Package;
    parameter String fileName = "C:/Users/Thomas/Documents/GitHub/OET_Sys-MoDEL_TH/hydroCoeff.mat" "Path to the hydroCoeff.mat file" annotation(
      Dialog(group = "PTO Parameters"));
    parameter Real A[2, 2] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad33.A", 2, 2) "State matrix" annotation(
      Dialog(group = "Radiation Force Parameters"));
    parameter Real B[2, 1] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad33.B", 2, 1) "Input matrix" annotation(
      Dialog(group = "Radiation Force Parameters"));
    parameter Real C[1, 2] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad33.C", 1, 2) "Output matrix" annotation(
      Dialog(group = "Radiation Force Parameters"));
    parameter Real D = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad33.D", 1, 1)) "Feed matrix" annotation(
      Dialog(group = "Radiation Force Parameters"));
    parameter Mass m = M + Ainf "Mass of the body" annotation(
      Dialog(group = "Body"));
    parameter TranslationalSpringConstant G3 = Khs "Hydrostatic restoring coefficient for z-axis translation" annotation(
      Dialog(group = "Hydrostatic Stiffness Parameters"));
    parameter Modelica.Units.SI.Mass M = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.m33", 1, 1)) "Total mass of the body (including ballast)";
    parameter Modelica.Units.SI.Mass Ainf = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.Ainf33", 1, 1)) "Added mass at maximum (cut-off) frequency";
    parameter Modelica.Units.SI.TranslationalSpringConstant Khs = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.Khs33", 1, 1)) "Hydrostatic stiffness";
    parameter Integer wDims[:] = Modelica.Utilities.Streams.readMatrixSize(fileName, "hydroCoeff.w") "Dimensions of the frequency vector";
    parameter Integer wSize = wDims[2] "Size of the frequency vector";
    parameter Real F_excRe[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.FexcRe", 1, wSize)) "Real part of excitation force coefficients";
    parameter Real F_excIm[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.FexcIm", 1, wSize)) "Imaginary part of excitation force coefficients";
    parameter Real w[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.w", 1, wSize)) "Angular frequency vector [rad/s]";
    parameter Real Adep[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.added_mass", wSize, 1)) "Frequency dependent added mass";
    parameter Real Rdamp[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.radiation_damping", wSize, 1)) "Radiation damping";
  equation

    annotation(
      Documentation(info = "<html>
      <p><strong>readHydroParam Model</strong></p>
      <p>This model is designed to read and store hydrodynamic parameters from a MATLAB .mat file. These parameters are crucial for accurate modeling of radiation forces and other hydrodynamic effects in marine and offshore engineering applications. This is also used to store parameters and extend to other blocks. </p>
      
      <p><strong>Parameters:</strong></p>
      <ul>
        <li><strong>fileName:</strong> Path to the MATLAB .mat file containing hydrodynamic coefficients and matrices.</li>
        <li><strong>A:</strong> State matrix of the system, read from the .mat file.</li>
        <li><strong>B:</strong> Input matrix for the system, read from the .mat file.</li>
        <li><strong>C:</strong> Output matrix for the system, read from the .mat file.</li>
        <li><strong>D:</strong> Feed matrix for the system, read from the .mat file.</li>
        <li><strong>m:</strong> Total mass of the body, including added mass.</li>
        <li><strong>G3:</strong> Hydrostatic restoring coefficient for z-axis translation.</li>
        <li><strong>M:</strong> Total mass of the body (including ballast).</li>
        <li><strong>Ainf:</strong> Added mass at maximum (cut-off) frequency.</li>
        <li><strong>Khs:</strong> Hydrostatic stiffness.</li>
        <li><strong>wDims:</strong> Dimensions of the frequency vector.</li>
        <li><strong>wSize:</strong> Size of the frequency vector.</li>
        <li><strong>F_excRe:</strong> Real part of excitation force coefficients.</li>
        <li><strong>F_excIm:</strong> Imaginary part of excitation force coefficients.</li>
        <li><strong>w:</strong> Angular frequency vector [rad/s].</li>
      </ul>
      
      <p><strong>Usage:</strong></p>
      <p>This model is essential for integrating empirical data into hydrodynamic simulations, enabling accurate modeling of radiation forces and system responses based on real-world measurements.</p>
      <p><strong>Applications:</strong></p>
      <ul>
        <li>Marine engineering and offshore structure design.</li>
        <li>Dynamic response analysis of marine systems under wave loads.</li>
        <li>Hydrodynamic modeling for wave energy converters and coastal engineering projects.</li>
      </ul>
    </html>"));
  end readHydroParam;

  package Internal
    /* Internal library of core functions and connectors for ocean engineering applications
                               This package contains essential components for wave modeling and structure interactions */

    package Functions
      /* Package defining explicit library functions for wave calculations and random number generation
                                             This package contains a collection of functions essential for ocean engineering simulations,
                                             including wave number calculations, random number generation, and various wave spectrum generators. */
      extends Modelica.Icons.Package;

      function waveNumber "Function to iteratively compute the wave number from frequency components"
        /* Uses the dispersion relationship for water waves to calculate wave numbers
                                                           This function implements an iterative method to solve the implicit dispersion equation */
        input Real d "Water depth [m]";
        input Real omega[:] "Array of wave frequency components [rad/s]";
        output Real k[size(omega, 1)] "Array of wave number components [rad/m]";
      protected
        constant Real g = Modelica.Constants.g_n "Gravitational acceleration [m/s^2]";
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        parameter Integer n = size(omega, 1) "Number of frequency components";
        Real T[size(omega, 1)] "Array of wave period components [s]";
        Real L0[size(omega, 1)] "Array of deepwater wavelength components [m]";
        Real L1(start = 0, fixed = true) "Temporary variable for wavelength iteration [m]";
        Real L1c(start = 0, fixed = true) "Temporary variable for wavelength iteration comparison [m]";
        Real L[size(omega, 1)] "Array of iterated wavelength components [m]";
      algorithm
        T := 2*pi./omega;
        L0 := g*T.^2/(2*pi);
        for i in 1:size(omega, 1) loop
          L1 := L0[i];
          L1c := 0;
          while abs(L1c - L1) > 0.001 loop
            L1c := L1;
            L[i] := g*T[i]^2/(2*pi)*tanh(2*pi/L1*d);
            L1 := L[i];
          end while;
        end for;
        k := 2*pi./L;
        annotation(
          Documentation(info = "<html>
            <p>Syntax: k = waveNumber(d, omega)</p>
            <p>Description: This function calculates wave numbers for given frequencies and water depth using the dispersion relationship for water waves. It employs an iterative method to solve the implicit dispersion equation.</p>
            <p>Inputs:</p>
            <ul>
              <li><code>d</code>: Water depth [m]</li>
              <li><code>omega</code>: Array of wave frequency components [rad/s]</li>
            </ul>
            <p>Outputs:</p>
            <ul>
              <li><code>k</code>: Array of wave number components [rad/m]</li>
            </ul>
            <p>Algorithm:</p>
            <ol>
              <li>Calculate wave periods from frequencies</li>
              <li>Calculate deepwater wavelengths</li>
              <li>Iterate to solve the dispersion equation for each frequency component</li>
              <li>Convert wavelengths to wave numbers</li>
            </ol>
          </html>"),
          Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "k(ω)", textStyle = {TextStyle.Bold}), Line(points = {{-80, -80}, {80, 80}}, color = {0, 0, 255}, thickness = 0.5)}),
          Diagram(graphics = {Text(extent = {{-100, 80}, {100, 40}}, textString = "Wave Number Calculation"), Line(points = {{-80, 0}, {80, 0}}, color = {0, 0, 255}), Line(points = {{0, -80}, {0, 80}}, color = {0, 0, 255}), Text(extent = {{-60, -20}, {60, -60}}, textString = "k = 2π/L")}),
          experiment(StopTime = 1.0, Tolerance = 1e-06));
      end waveNumber;

      function randomNumberGen "Function to generate random numbers using XOR shift algorithm"
        /* Produces a vector of random numbers based on local and global seeds
                                                         This function utilizes the Xorshift64star algorithm for efficient random number generation */
        input Integer ls = 614657 "Local seed for random number generation";
        input Integer gs = 30020 "Global seed for random number generation";
        constant input Integer n = 100 "Number of random numbers to generate";
        output Real r64[n] "Vector of generated random numbers";
      protected
        Integer state64[2](each start = 0, each fixed = true) "State vector for XOR shift algorithm";
      algorithm
        state64[1] := 0;
        state64[2] := 0;
        for i in 1:n loop
          if i == 1 then
            state64 := Modelica.Math.Random.Generators.Xorshift64star.initialState(ls, gs);
            r64[i] := 0;
          else
            (r64[i], state64) := Modelica.Math.Random.Generators.Xorshift64star.random((state64));
          end if;
        end for;
        annotation(
          Documentation(info = "<html>
          <p>Syntax: r64 = randomNumberGen(ls, gs, n)</p>
          <p>Description: This function generates a vector of random numbers using the Xorshift64star algorithm, which is known for its efficiency and good statistical properties.</p>
          <p>Inputs:</p>
          <ul>
            <li><code>ls</code>: Local seed for random number generation (default: 614657)</li>
            <li><code>gs</code>: Global seed for random number generation (default: 30020)</li>
            <li><code>n</code>: Number of random numbers to generate (default: 100)</li>
          </ul>
          <p>Outputs:</p>
          <ul>
            <li><code>r64</code>: Vector of generated random numbers</li>
          </ul>
          <p>Algorithm: The function uses the Xorshift64star algorithm to generate random numbers based on the provided seeds.</p>
        </html>"),
          Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "RNG", textStyle = {TextStyle.Bold})}));
      end randomNumberGen;

      function randomFrequencySelector "Function to randomly select frequency components within a specified range"
        /* Uses a random phase vector to perturb frequencies
                                                         This function ensures a good distribution of frequencies for irregular wave generation */
        constant input Real omega_min "Minimum frequency [rad/s]";
        constant input Real omega_max "Maximum frequency [rad/s]";
        constant input Real epsilon[:] "Random phase vector for frequency perturbation";
        output Real omega[size(epsilon, 1)] "Output vector of selected frequency components [rad/s]";
      protected
        parameter Real ref_omega[size(epsilon, 1)] = omega_min:(omega_max - omega_min)/(size(epsilon, 1) - 1):omega_max "Reference frequency vector [rad/s]";
      algorithm
        omega[1] := omega_min;
        for i in 2:size(epsilon, 1) - 1 loop
          omega[i] := ref_omega[i] + epsilon[i]*omega_min;
        end for;
        omega[size(epsilon, 1)] := omega_max;
        annotation(
          Documentation(info = "<html>
          <p>Syntax: omega = frequencySelector(omega_min, omega_max, epsilon)</p>
          <p>Description: This function selects frequency components within a specified range, using a random phase vector to perturb the frequencies. This ensures a good distribution of frequencies for irregular wave generation.</p>
          <p>Inputs:</p>
          <ul>
            <li><code>omega_min</code>: Minimum frequency [rad/s]</li>
            <li><code>omega_max</code>: Maximum frequency [rad/s]</li>
            <li><code>epsilon</code>: Random phase vector for frequency perturbation</li>
          </ul>
          <p>Outputs:</p>
          <ul>
            <li><code>omega</code>: Output vector of selected frequency components [rad/s]</li>
          </ul>
          <p>Algorithm: The function creates a reference frequency vector and then perturbs it using the random phase vector, ensuring the first and last frequencies are exactly omega_min and omega_max.</p>
        </html>"),
          Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "ω(ε)", textStyle = {TextStyle.Bold})}));
      end randomFrequencySelector;

      function spectrumGenerator_PM "Function to generate Pierson-Moskowitz spectrum"
        /* Calculates spectral values for given frequencies based on significant wave height
                                                         This function implements the Pierson-Moskowitz spectrum, suitable for fully developed seas */
        input Real Hs = 1 "Significant wave height [m]";
        input Real omega[:] "Array of frequency components [rad/s]";
        output Real spec[size(omega, 1)] "Array of spectral values for input frequencies [m^2s]";
      protected
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Gravitational acceleration [m/s^2]";
      algorithm
        for i in 1:size(omega, 1) loop
          spec[i] := 0.0081*g^2/omega[i]^5*exp(-0.0358*(g/(Hs*omega[i]^2))^2);
        end for;
        annotation(
          Documentation(info = "<html>
          <p>Syntax: spec = spectrumGenerator_PM(Hs, omega)</p>
          <p>Description: This function generates the Pierson-Moskowitz spectrum, which is suitable for fully developed seas. It calculates spectral values for given frequencies based on the significant wave height.</p>
          <p>Inputs:</p>
          <ul>
            <li><code>Hs</code>: Significant wave height [m] (default: 1)</li>
            <li><code>omega</code>: Array of frequency components [rad/s]</li>
          </ul>
          <p>Outputs:</p>
          <ul>
            <li><code>spec</code>: Array of spectral values for input frequencies [m^2s]</li>
          </ul>
          <p>Algorithm: The function calculates spectral values using the Pierson-Moskowitz formula: S(ω) = 0.0081*g^2/ω^5 * exp(-0.0358*(g/(Hs*ω^2))^2)</p>
        </html>"),
          Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "PM", textStyle = {TextStyle.Bold})}));
      end spectrumGenerator_PM;

      function spectrumGenerator_BRT "Function to generate Bretschneider spectrum"
        /* Calculates spectral values based on significant wave height and peak frequency
                                                         This function implements the Bretschneider spectrum, a two-parameter spectrum for fetch-limited seas */
        input Real Hs = 1 "Significant wave height [m]";
        input Real omega[:] "Array of frequency components [rad/s]";
        input Real omega_peak = 0.9423 "Peak spectral frequency [rad/s]";
        output Real spec[size(omega, 1)] "Array of spectral values for input frequencies [m^2s]";
      protected
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Gravitational acceleration [m/s^2]";
      algorithm
        for i in 1:size(omega, 1) loop
          spec[i] := 1.9635*Hs^2*omega_peak^4/omega[i]^5*exp(-1.25*((omega_peak/omega[i])^4));
        end for;
        annotation(
          Documentation(info = "<html>
          <p>Syntax: spec = spectrumGenerator_BRT(Hs, omega, omega_peak)</p>
          <p>Description: This function generates the Bretschneider spectrum, which is a two-parameter spectrum suitable for fetch-limited seas. It calculates spectral values based on significant wave height and peak frequency.</p>
          <p>Inputs:</p>
          <ul>
            <li><code>Hs</code>: Significant wave height [m] (default: 1)</li>
            <li><code>omega</code>: Array of frequency components [rad/s]</li>
            <li><code>omega_peak</code>: Peak spectral frequency [rad/s] (default: 0.9423)</li>
          </ul>
          <p>Outputs:</p>
          <ul>
            <li><code>spec</code>: Array of spectral values for input frequencies [m^2s]</li>
          </ul>
          <p>Algorithm: The function calculates spectral values using the Bretschneider formula: S(ω) = 1.9635*Hs^2*ω_peak^4/ω^5 * exp(-1.25*((ω_peak/ω)^4))</p>
        </html>"),
          Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "BRT", textStyle = {TextStyle.Bold})}));
      end spectrumGenerator_BRT;

      function spectrumGenerator_JONSWAP "Function to generate JONSWAP (Joint North Sea Wave Project) spectrum"
        /* Calculates spectral values based on significant wave height, peak frequency, and spectral width parameters
                                                         This function implements the JONSWAP spectrum, suitable for developing seas with fetch limitations */
        input Real Hs = 1 "Significant wave height [m]";
        input Real omega[:] "Array of frequency components [rad/s]";
        input Real omega_peak = 0.9423 "Peak spectral frequency [rad/s]";
        input Real spectralWidth_min "Minimum spectral width parameter";
        input Real spectralWidth_max "Maximum spectral width parameter";
        output Real spec[size(omega, 1)] "Array of spectral values for input frequencies [m^2s]";
      protected
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Gravitational acceleration [m/s^2]";
        constant Real gamma = 3.3 "Peak enhancement factor for JONSWAP spectrum";
        Real sigma "Spectral width parameter";
        Real b "Exponent for peak enhancement factor";
      algorithm
        for i in 1:size(omega, 1) loop
          if omega[i] > omega_peak then
            sigma := spectralWidth_max;
          else
            sigma := spectralWidth_min;
          end if;
          b := exp(-0.5*(((omega[i] - omega_peak)/(sigma*omega_peak))^2));
          spec[i] := 0.0081*g^2/omega[i]^5*exp(-1.25*((omega_peak/omega[i])^4))*gamma^b;
        end for;
        annotation(
          Documentation(info = "<html>
          <p>Syntax: spec = spectrumGenerator_JONSWAP(Hs, omega, omega_peak, spectralWidth_min, spectralWidth_max)</p>
          <p>Description: This function generates the JONSWAP (Joint North Sea Wave Project) spectrum, which is suitable for developing seas with fetch limitations. It calculates spectral values based on significant wave height, peak frequency, and spectral width parameters.</p>
          <p>Inputs:</p>
          <ul>
            <li><code>Hs</code>: Significant wave height [m] (default: 1)</li>
            <li><code>omega</code>: Array of frequency components [rad/s]</li>
            <li><code>omega_peak</code>: Peak spectral frequency [rad/s] (default: 0.9423)</li>
            <li><code>spectralWidth_min</code>: Minimum spectral width parameter</li>
            <li><code>spectralWidth_max</code>: Maximum spectral width parameter</li>
          </ul>
          <p>Outputs:</p>
          <ul>
            <li><code>spec</code>: Array of spectral values for input frequencies [m^2s]</li>
          </ul>
          <p>Algorithm: The function calculates spectral values using the JONSWAP formula, which is an extension of the Pierson-Moskowitz spectrum with additional parameters to account for fetch-limited seas.</p>
        </html>"),
          Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "JONSWAP", textStyle = {TextStyle.Bold})}));
      end spectrumGenerator_JONSWAP;

      function equalEnergyFrequencySelector
        // Can lead to errors if n_omega and n_omega_int are not selected properly, need to make more rubust
        input Real omega_min "Minimum frequency [rad/s]";
        input Real omega_max "Maximum frequency [rad/s]";
        constant input Integer n_omega "Number of frequency compenents defining the spectrum";
        constant input Integer n_omega_int "Number of steps for integrating the spectrum";
        input Real omega_int[n_omega_int] "Integration frquencies";
        input Real S_int[n_omega_int] "Energy Spectrum";
        output Real omega[n_omega] "Output vector of selected frequency components [rad/s]";
        output Real S[n_omega];
        //output Real Cum_energy[n_omega_int] "Vector of cumulative spectrum interval areas";
        //output Real eng_check[n_omega];
        //output Real energy_sum;
        //output Real mean_energy;
        //output Real new_energy;
      protected
        Real domega = (omega_max - omega_min)/(n_omega_int - 1) "Omega int frequency step";
        Real Cum_energy[n_omega_int] "Vector of cumulative spectrum interval areas";
        Real tot_energy "Total energy in the spectrum";
        Real energy "Element to iterate current area off of";
        //Real mean_energy;
        Real tolerance "Tolerance for area";
        //Real current_energy_diff, next_energy_diff;
        //Integer k = 1;
        Real mean_energy;
        Real new_energy;
      algorithm
//energy_sum := 0;
        Cum_energy[1] := 0;
        omega[1] := omega_min;
        omega[n_omega] := omega_max;
        S[1] := S_int[1];
        S[n_omega] := S_int[n_omega_int];
        for i in 2:n_omega_int loop
          energy := Hydrodynamic.Internal.Functions.trapIntegration(S_int[i - 1], S_int[i], domega);
          Cum_energy[i] := Cum_energy[i - 1] + energy;
        end for;
        tot_energy := Cum_energy[end];
        mean_energy := tot_energy/(n_omega - 1);
        tolerance := mean_energy/5;
        for i in 2:(n_omega - 1) loop
// This is really sensitive to integration step size, need to make more robust
/* for j in k:(n_omega_int-1) loop
              current_energy_diff := abs(Cum_energy[j] - Cum_energy[k] - mean_energy);
              next_energy_diff := abs(Cum_energy[j+1] - Cum_energy[k] - mean_energy);
            
              if  Cum_energy[j] - Cum_energy[k] >= mean_energy or current_energy_diff <= tolerance then 
                omega[i] := omega_int[j];
                S[i] := S_int[j];
                eng_check[i] := Cum_energy[j] - Cum_energy[k];
                energy_sum := energy_sum + eng_check[i];
                k := j;
                break;
              end if;
              
            end for; */
//for j in k:(n_omega_int-1) loop
          new_energy := new_energy + mean_energy;
          omega[i] := Modelica.Math.Vectors.interpolate(Cum_energy, omega_int, new_energy);
          S[i] := Modelica.Math.Vectors.interpolate(omega_int, S_int, omega[i]);
//end for; */
        end for;
      end equalEnergyFrequencySelector;

      function trapIntegration
        input Real y1;
        input Real y2;
        input Real domega;
        output Real Area;
      algorithm
        Area := 0.5*domega*(y1 + y2);
      end trapIntegration;

      function integrationFrequencyGen
        input Real omega_min "Minimum frequency [rad/s]";
        input Real omega_max "Maximum frequency [rad/s]";
        constant input Integer n_omega_int "Number of frequency compenents defining the spectrum";
        output Real omega_int[n_omega_int];
        // = omega_min:domega_int:omega_max "Frequencies for spectrum generation and integration";
      protected
        Real domega_int = (omega_max - omega_min)/(n_omega_int - 1) "Frequency step size";
      algorithm
        for i in 1:n_omega_int loop
          omega_int[i] := omega_min + (i - 1)*(omega_max - omega_min)/(n_omega_int - 1);
        end for;
      end integrationFrequencyGen;

      function dfrequencyGen
        input Real omega[n_omega];
        input Real S[n_omega];
        constant input Integer n_omega;
        output Real domega[n_omega];
      protected
        Real omega_mean;
      algorithm
        for i in 2:n_omega loop
          domega[i] := omega[i] - omega[i - 1];
        end for;
        omega_mean := sum(domega)/n_omega;
        domega[1] := omega_mean;
      end dfrequencyGen;
      annotation(
        Documentation(info = "<html>
          <p>This package contains a set of functions essential for ocean engineering simulations:</p>
          <ul>
            <li><b>waveNumber:</b> Calculates wave numbers using the dispersion relationship</li>
            <li><b>randomNumberGen:</b> Generates random numbers using the XOR shift algorithm</li>
            <li><b>frequencySelector:</b> Selects frequency components for irregular wave generation</li>
            <li><b>spectrumGenerator_PM:</b> Generates Pierson-Moskowitz spectrum</li>
            <li><b>spectrumGenerator_BRT:</b> Generates Bretschneider spectrum</li>
            <li><b>spectrumGenerator_JONSWAP:</b> Generates JONSWAP spectrum</li>
          </ul>
          <p>These functions provide the core calculations needed for wave modeling and analysis in ocean engineering applications.</p>
        </html>"),
        Icon(graphics = {Text(extent = {{-90, 90}, {90, 50}}, lineColor = {0, 0, 0}, textString = "f(x)"), Line(points = {{-80, -20}, {-60, 20}, {-40, -40}, {-20, 40}, {0, -20}, {20, 60}, {40, -60}, {60, 20}, {80, -40}}, color = {0, 0, 255}, smooth = Smooth.Bezier), Text(extent = {{-90, -50}, {90, -90}}, lineColor = {0, 0, 0}, textString = "Functions")}));
    end Functions;

    package Connectors
      /* Package defining library connectors for data exchange between components */

      connector WaveOutConn "Output connector for wave data"
        Modelica.Blocks.Interfaces.RealOutput F_exc "Excitation force [N]";
      end WaveOutConn;

      connector WaveInConn "Input connector for wave data"
        Modelica.Blocks.Interfaces.RealInput F_exc "Excitation force [N]";
      end WaveInConn;

      connector DataCollector "Output connector for collecting simulation data"
        Modelica.Blocks.Interfaces.RealOutput F_rad "Radiation force [N]";
        Modelica.Blocks.Interfaces.RealOutput v_z "Vertical velocity [m/s]";
      end DataCollector;
    end Connectors;

    model TestDevelopment "Model to test all wave components and WEC rigid body interactions"
      /* Demonstrates the use of different wave types and their connections to rigid body models */
      parameter String filePath = "C:/Users/Duke/SysModel2024/DragSystem/hydroCoeff.mat" "File path for hydrodynamic coefficients";
      // Wave models
      Hydrodynamic.WaveProfile.RegularWave.LinearWave Reg1(fileName = filePath, Hs = 2.5, Trmp = 50) "Regular linear wave model";
      Hydrodynamic.WaveProfile.IrregularWave.PiersonMoskowitzWave Irr1(fileName = filePath, Hs = 2.5, n_omega = 100, Trmp = 50) "Irregular Pierson-Moskowitz wave model";
      Hydrodynamic.WaveProfile.IrregularWave.BretschneiderWave Irr2(fileName = filePath, Hs = 2.5, n_omega = 100, Trmp = 50) "Irregular Bretschneider wave model";
      Hydrodynamic.WaveProfile.IrregularWave.JonswapWave Irr3(fileName = filePath, Hs = 2.5, n_omega = 100, Trmp = 50) "Irregular JONSWAP wave model";
      // Rigid body models
      Hydrodynamic.Structures.RigidBody Body1(fileName = filePath) "Rigid body for regular wave interaction";
      Hydrodynamic.Structures.RigidBody Body2(fileName = filePath) "Rigid body for Pierson-Moskowitz wave interaction";
      Hydrodynamic.Structures.RigidBody Body3(fileName = filePath) "Rigid body for Bretschneider wave interaction";
      Hydrodynamic.Structures.RigidBody Body4(fileName = filePath) "Rigid body for JONSWAP wave interaction";
    equation
// Connect wave models to corresponding rigid bodies
      connect(Reg1.wconn.F_exc, Body1.wconn.F_exc) "Connection for regular wave excitation";
      connect(Irr1.wconn.F_exc, Body2.wconn.F_exc) "Connection for Pierson-Moskowitz wave excitation";
      connect(Irr2.wconn.F_exc, Body3.wconn.F_exc) "Connection for Bretschneider wave excitation";
      connect(Irr3.wconn.F_exc, Body4.wconn.F_exc) "Connection for JONSWAP wave excitation";
      annotation(
        experiment(StartTime = 0, StopTime = 200, Tolerance = 1e-06, Interval = 0.1),
        Documentation(info = "<html>
          <p>This model demonstrates the interaction between different wave types and rigid body structures.</p>
          <p>It includes regular and irregular wave models connected to corresponding rigid body models for simulation.</p>
        </html>"));
    end TestDevelopment;

    type spectrumEnergyDensity = Real(final quantity = "spectrumEnergyDensity", final unit = "m^2 s/rad");
    annotation(
      Documentation(info = "<html>
        <p>This package contains internal functions, connectors, and test models for the Ocean Engineering Toolbox.</p>
        <p>Key components:</p>
        <ul>
          <li>Functions: Wave calculations and spectrum generation</li>
          <li>Connectors: Data exchange interfaces for wave and structure interactions</li>
          <li>TestDevelopment: Model for testing wave-structure interactions</li>
        </ul>
      </html>"),
      Icon(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics = {Rectangle(lineColor = {215, 215, 215}, fillColor = {255, 255, 255}, fillPattern = FillPattern.HorizontalCylinder, extent = {{-100, -100}, {100, 100}}, radius = 25), Rectangle(lineColor = {215, 215, 215}, extent = {{-100, -100}, {100, 100}}, radius = 25), Ellipse(extent = {{-80, 80}, {80, -80}}, lineColor = {215, 215, 215}, fillColor = {215, 215, 215}, fillPattern = FillPattern.Solid), Ellipse(extent = {{-55, 55}, {55, -55}}, lineColor = {255, 255, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Rectangle(extent = {{-60, 14}, {60, -14}}, lineColor = {215, 215, 215}, fillColor = {215, 215, 215}, fillPattern = FillPattern.Solid, rotation = 45)}));
  end Internal;

  package Archive
    extends Modelica.Icons.Package;

    model DragSimple
      inner Modelica.Mechanics.MultiBody.World world annotation(
        Placement(transformation(origin = {-64, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Blocks.Sources.Constant const[3](k = {-100, 0, 0}) annotation(
        Placement(transformation(origin = {166, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
      Modelica.Mechanics.MultiBody.Parts.PointMass pointMass(m = 1) annotation(
        Placement(transformation(origin = {74, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Parts.FixedTranslation fixedTranslation(r = {1, 0, 0}) annotation(
        Placement(transformation(origin = {48, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force annotation(
        Placement(transformation(origin = {112, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
      Modelica.Blocks.Sources.Constant const2[3](k = {100, 0, 0}) annotation(
        Placement(transformation(origin = {-30, 28}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force1 annotation(
        Placement(transformation(origin = {12, 28}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic(useAxisFlange = false) annotation(
        Placement(transformation(origin = {18, 0}, extent = {{-10, -10}, {10, 10}})));
    equation
      connect(const.y, force.force) annotation(
        Line(points = {{155, 0}, {124, 0}}, color = {0, 0, 127}, thickness = 0.5));
      connect(prismatic.frame_b, fixedTranslation.frame_a) annotation(
        Line(points = {{28, 0}, {38, 0}}, color = {95, 95, 95}));
      connect(fixedTranslation.frame_b, pointMass.frame_a) annotation(
        Line(points = {{58, 0}, {74, 0}}, color = {95, 95, 95}));
      connect(force.frame_b, pointMass.frame_a) annotation(
        Line(points = {{102, 0}, {74, 0}}, color = {95, 95, 95}));
      connect(const2.y, force1.force) annotation(
        Line(points = {{-19, 28}, {-1, 28}}, color = {0, 0, 127}, thickness = 0.5));
      connect(force1.frame_b, prismatic.frame_b) annotation(
        Line(points = {{22, 28}, {28, 28}, {28, 0}}, color = {95, 95, 95}));
      connect(world.frame_b, prismatic.frame_a) annotation(
        Line(points = {{-54, 0}, {8, 0}}, color = {95, 95, 95}));
      annotation(
        Diagram(coordinateSystem(extent = {{-80, 40}, {180, -20}})));
    end DragSimple;

    model DragSystem
      inner Modelica.Mechanics.MultiBody.World world(gravityType = Modelica.Mechanics.MultiBody.Types.GravityTypes.NoGravity) annotation(
        Placement(transformation(origin = {-82, -82}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Parts.Fixed fixed annotation(
        Placement(transformation(origin = {-2, 74}, extent = {{-10, -10}, {10, 10}}, rotation = -90)));
      Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic(n = {0, 1, 0}) annotation(
        Placement(transformation(origin = {-2, 44}, extent = {{-10, -10}, {10, 10}}, rotation = -90)));
      Modelica.Mechanics.MultiBody.Parts.PointMass pointMass(m = 10) annotation(
        Placement(transformation(origin = {-2, 8}, extent = {{-10, -10}, {10, 10}}, rotation = -90)));
      Modelica.Blocks.Sources.Constant const1[3](k = {0, -100, 0}) annotation(
        Placement(transformation(origin = {64, 34}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteVelocity absoluteVelocity annotation(
        Placement(transformation(origin = {30, 8}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force annotation(
        Placement(transformation(origin = {-2, -22}, extent = {{-10, -10}, {10, 10}}, rotation = 90)));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force1 annotation(
        Placement(transformation(origin = {28, 34}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
      DragForce dragForce annotation(
        Placement(transformation(origin = {26, -40}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
    equation
      connect(prismatic.frame_a, fixed.frame_b) annotation(
        Line(points = {{-2, 54}, {-2, 64}}, color = {95, 95, 95}));
      connect(prismatic.frame_b, pointMass.frame_a) annotation(
        Line(points = {{-2, 34}, {-2, 8}}, color = {95, 95, 95}));
      connect(force.frame_b, pointMass.frame_a) annotation(
        Line(points = {{-2, -12}, {-2, 8}}, color = {95, 95, 95}));
      connect(const1.y, force1.force) annotation(
        Line(points = {{53, 34}, {40, 34}}, color = {0, 0, 127}));
      connect(force1.frame_b, prismatic.frame_b) annotation(
        Line(points = {{18, 34}, {-2, 34}}, color = {95, 95, 95}));
      connect(absoluteVelocity.frame_a, pointMass.frame_a) annotation(
        Line(points = {{20, 8}, {-2, 8}}, color = {95, 95, 95}));
      connect(dragForce.y, force.force) annotation(
        Line(points = {{16, -40}, {-1.8, -40}, {-1.8, -33.8}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteVelocity.v, dragForce.u) annotation(
        Line(points = {{42, 8}, {44, 8}, {44, -40}, {37, -40}}, color = {0, 0, 127}, thickness = 0.5));
      annotation(
        Diagram);
    end DragSystem;

    block DragForce
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput u[3] "Input Signals (velocity vector)" annotation(
        Placement(transformation(origin = {-106, 0}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-106, 0}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealOutput y[3] "Output Signals (drag force vector)" annotation(
        Placement(transformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {102, 2}, extent = {{-10, -10}, {10, 10}})));
      parameter Real rho_w = 1.25 "Density of sea water [kg/m^3]";
      parameter Real Cd = 1 "Normal drag coefficient";
      parameter Real A = 1 "Cross-sectional Area of object [m^2]";
      Real Fd[3];
    equation
      Fd = -0.5*rho_w*Cd*A*(u.*abs(u));
      y = Fd;
    end DragForce;

    block DragForce3D
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput u[3] "Input Signals (velocity vector)" annotation(
        Placement(transformation(origin = {-106, 0}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealOutput y[3] "Output Signals (3D drag force vector)" annotation(
        Placement(transformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}})));
      parameter Real rho = 1.25 "Density of fluid [kg/m^3]";
      parameter Real A = 1 "Reference area [m^2]";
      parameter Real Cdx = 1 "Drag coefficient for x-axis";
      parameter Real Cdy = 1 "Drag coefficient for y-axis";
      parameter Real Cdz = 1 "Drag coefficient for z-axis";
      parameter Real Cd[3, 3] = diagonal({Cdx, Cdy, Cdz});
      Real c "Combined constant term";
      Real Fd[3] "3D drag force vector";
    equation
      c = 0.5*rho*A;
      Fd = -c*Cd*(u.*abs(u));
      y = Fd;
    end DragForce3D;

    block PTO3D
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput u[3] annotation(
        Placement(transformation(origin = {-106, 50}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-98, 50}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealInput s[3] annotation(
        Placement(transformation(origin = {-106, -50}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-98, -50}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealOutput y[3] "Output Signals (3D drag force vector)" annotation(
        Placement(transformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}})));
      parameter Real Kpx = 0.1 "Proportional gain for x-axis";
      parameter Real Kpy = 0.1 "Proportional gain for y-axis";
      parameter Real Kpz = 0.1 "Proportional gain for z-axis";
      parameter Real Kp[3, 3] = diagonal({Kpx, Kpy, Kpz});
      parameter Real Kix = 0.1 "Integral gain for x-axis";
      parameter Real Kiy = 0.1 "Integral gain for y-axis";
      parameter Real Kiz = 0.1 "Integral gain for z-axis";
      parameter Real Ki[3, 3] = diagonal({Kix, Kiy, Kiz});
      Real Fp[3] "PTO";
    equation
      Fp = Kp*u + Ki*s;
      y = -Fp;
    end PTO3D;

    block HydrostaticForce3D
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput u[3] annotation(
        Placement(transformation(origin = {-106, 0}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-96, 0}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealOutput y[3] "Output Signals (drag force vector)" annotation(
        Placement(transformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {102, 2}, extent = {{-10, -10}, {10, 10}})));
      parameter Real G1 = 0 "hydrostatic restoring coefficients for x-axis";
      parameter Real G2 = 0 "hydrostatic restoring coefficients for y-axis";
      parameter Real G3 = 1 "hydrostatic restoring coefficients for z-axis";
      parameter Real G[3, 3] = diagonal({G1, G2, G3});
    equation
      y = -G*u;
    end HydrostaticForce3D;

    model HydrodynamicBlock3D
      extends Modelica.Blocks.Icons.Block;
      Modelica.Mechanics.MultiBody.Sensors.AbsolutePosition absolutePosition annotation(
        Placement(transformation(origin = {-50, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteVelocity absoluteVelocity annotation(
        Placement(transformation(origin = {-50, 30}, extent = {{-10, -10}, {10, 10}})));
      DragForce3D dragForce3D(Cdx = 0.01, Cdy = 0.01, Cdz = 0.01, rho = 10) annotation(
        Placement(transformation(origin = {-8, 30}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force annotation(
        Placement(transformation(origin = {36, 30}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force1 annotation(
        Placement(transformation(origin = {36, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force2 annotation(
        Placement(transformation(origin = {36, -30}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a annotation(
        Placement(transformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_b annotation(
        Placement(transformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}})));
      PTO3D pto3d annotation(
        Placement(transformation(origin = {-8, -30}, extent = {{-10, -10}, {10, 10}})));
      HydrostaticForce3D hydrostaticForce3D annotation(
        Placement(transformation(origin = {-8, 0}, extent = {{-10, -10}, {10, 10}})));
    equation
      connect(absoluteVelocity.v, dragForce3D.u) annotation(
        Line(points = {{-39, 30}, {-19, 30}}, color = {0, 0, 127}, thickness = 0.5));
      connect(dragForce3D.y, force.force) annotation(
        Line(points = {{2.8, 30}, {24.8, 30}}, color = {0, 0, 127}, thickness = 0.5));
      connect(frame_a, absolutePosition.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}}));
      connect(frame_a, absoluteVelocity.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}, {-60, 30}}));
      connect(force1.frame_b, frame_b) annotation(
        Line(points = {{46, 0}, {102, 0}}, color = {95, 95, 95}));
      connect(force.frame_b, frame_b) annotation(
        Line(points = {{46, 30}, {80, 30}, {80, 0}, {102, 0}}, color = {95, 95, 95}));
      connect(force2.frame_b, frame_b) annotation(
        Line(points = {{46, -30}, {80, -30}, {80, 0}, {102, 0}}, color = {95, 95, 95}));
      connect(pto3d.y, force2.force) annotation(
        Line(points = {{2, -30}, {24, -30}}, color = {0, 0, 127}, thickness = 0.5));
      connect(hydrostaticForce3D.y, force1.force) annotation(
        Line(points = {{2, 0}, {24, 0}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absolutePosition.r, hydrostaticForce3D.u) annotation(
        Line(points = {{-38, 0}, {-18, 0}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteVelocity.v, pto3d.u) annotation(
        Line(points = {{-38, 30}, {-30, 30}, {-30, -24}, {-18, -24}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absolutePosition.r, pto3d.s) annotation(
        Line(points = {{-38, 0}, {-34, 0}, {-34, -34}, {-18, -34}}, color = {0, 0, 127}, thickness = 0.5));
    end HydrodynamicBlock3D;

    model HydrodynamicBlock6DUPD
      extends Modelica.Blocks.Icons.Block;
      Modelica.Mechanics.MultiBody.Sensors.AbsolutePosition absolutePosition annotation(
        Placement(transformation(origin = {-50, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteVelocity absoluteVelocity annotation(
        Placement(transformation(origin = {-50, 40}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a annotation(
        Placement(transformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_b annotation(
        Placement(transformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}})));
      HydrostaticForce6D hydrostaticForce6D(enableHydrostaticForce = true) annotation(
        Placement(transformation(origin = {18, -38}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque forceAndTorque2 annotation(
        Placement(transformation(origin = {60, -40}, extent = {{-10, 10}, {10, -10}}, rotation = -0)));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteAngularVelocity absoluteAngularVelocity annotation(
        Placement(transformation(origin = {-50, -32}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteAngles absoluteAngles annotation(
        Placement(transformation(origin = {-50, -60}, extent = {{-10, -10}, {10, 10}})));
      RadiationF radiationF(enableRadiationForce = true) annotation(
        Placement(transformation(origin = {18, 68}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force annotation(
        Placement(transformation(origin = {56, 68}, extent = {{-10, -10}, {10, 10}})));
    equation
      connect(frame_a, absolutePosition.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}}));
      connect(absolutePosition.r, hydrostaticForce6D.u) annotation(
        Line(points = {{-38, 0}, {-32, 0}, {-32, -33}, {8, -33}}, color = {0, 0, 127}, thickness = 0.5));
      connect(hydrostaticForce6D.y, forceAndTorque2.force) annotation(
        Line(points = {{28, -32}, {48, -32}, {48, -34}}, color = {0, 0, 127}, thickness = 0.5));
      connect(hydrostaticForce6D.y1, forceAndTorque2.torque) annotation(
        Line(points = {{28, -42}, {48, -42}, {48, -46}}, color = {0, 0, 127}, thickness = 0.5));
      connect(forceAndTorque2.frame_b, frame_b) annotation(
        Line(points = {{70, -40}, {78, -40}, {78, 0}, {102, 0}}, color = {95, 95, 95}));
      connect(frame_a, absoluteVelocity.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}, {-60, 40}}));
      connect(frame_a, absoluteAngularVelocity.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}, {-60, -32}}));
      connect(absoluteAngularVelocity.w, hydrostaticForce6D.theta) annotation(
        Line(points = {{-38, -32}, {-32, -32}, {-32, -42}, {8, -42}}, color = {0, 0, 127}, thickness = 0.5));
      connect(frame_a, absoluteAngles.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}, {-60, -60}}));
      connect(absoluteVelocity.v, radiationF.v) annotation(
        Line(points = {{-38, 40}, {-38, 72}, {6, 72}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absolutePosition.r, radiationF.z) annotation(
        Line(points = {{-38, 0}, {-10, 0}, {-10, 64}, {6, 64}}, color = {0, 0, 127}, thickness = 0.5));
      connect(radiationF.y, force.force) annotation(
        Line(points = {{30, 68}, {44, 68}}, color = {0, 0, 127}, thickness = 0.5));
      connect(force.frame_b, frame_b) annotation(
        Line(points = {{66, 68}, {78, 68}, {78, 0}, {102, 0}}, color = {95, 95, 95}));
    end HydrodynamicBlock6DUPD;

    block HydrostaticForce6DUPD
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput u[3] "Linear displacement" annotation(
        Placement(transformation(origin = {-106, 50}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-96, 50}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealInput theta[3] "Angular displacement" annotation(
        Placement(transformation(origin = {-106, -50}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-96, -50}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealOutput y[3] "Translational hydrostatic force" annotation(
        Placement(transformation(origin = {108, 50}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {102, 50}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Blocks.Interfaces.RealOutput y1[3] "Rotational hydrostatic torque" annotation(
        Placement(transformation(origin = {108, -50}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {102, -50}, extent = {{-10, -10}, {10, 10}})));
      parameter Real G1 = 0 "Hydrostatic restoring coefficient for x-axis translation";
      parameter Real G2 = 0 "Hydrostatic restoring coefficient for y-axis translation";
      parameter Real G3 = 1958672 "Hydrostatic restoring coefficient for z-axis translation";
      parameter Real G4 = 0 "Hydrostatic restoring coefficient for x-axis rotation";
      parameter Real G5 = 0 "Hydrostatic restoring coefficient for y-axis rotation";
      parameter Real G6 = 0 "Hydrostatic restoring coefficient for z-axis rotation";
      parameter Real G[6, 6] = diagonal({G1, G2, G3, G4, G5, G6});
      // Add a switch parameter
      parameter Boolean enableHydrostaticForce = true "Switch to enable/disable hydrostatic force";
      Real F[6] "Hydrostatic force/torque vector";
      Real u_theta[6] "Combined linear and angular displacements";
    equation
// Combine u and theta into a 6x1 matrix
      u_theta[1:3] = u;
      u_theta[4:6] = theta;
      F = -G*u_theta;
// Use the switch to conditionally output the force
      if enableHydrostaticForce then
        y = F[1:3];
        y1 = F[4:6];
      else
        y = zeros(3);
        y1 = zeros(3);
      end if;
    end HydrostaticForce6DUPD;

    model BodyHD6D "6-Dimensional Hydrodynamic Body Model"
      extends Modelica.Blocks.Icons.Block;
      // MultiBody connectors
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a "Input frame" annotation(
        Placement(transformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_b "Output frame" annotation(
        Placement(transformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}})));
      // Body components
      Modelica.Mechanics.MultiBody.Parts.BodyShape bodyShape(height = 0.1, length = 0.1, m = 1958671, width = 0.1, r_CM = {0, 0, 0}, r = {0, 0, 0}) "Main body with mass and inertia" annotation(
        Placement(transformation(origin = {-50, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Parts.FixedTranslation fixedTranslation(r = {0, 0, 0}, animation = false) "Fixed translation to adjust body position" annotation(
        Placement(transformation(origin = {-20, 0}, extent = {{-10, -10}, {10, 10}})));
      // Parameters for DragForce6D (now part of BodyHD6D)
      parameter Real rho(unit = "kg/m^3") = 1000 "Density of fluid";
      parameter Real A(unit = "m^2") = 1 "Reference area";
      parameter Real Cdx = 100 "Translational drag coefficient for x-axis";
      parameter Real Cdy = 0.01 "Translational drag coefficient for y-axis";
      parameter Real Cdz = 100 "Translational drag coefficient for z-axis";
      parameter Real Crx = 100 "Rotational drag coefficient for x-axis";
      parameter Real Cry = 0.01 "Rotational drag coefficient for y-axis";
      parameter Real Crz = 100 "Rotational drag coefficient for z-axis";
      parameter Boolean enableDragForce = false "Switch to enable/disable drag force calculation";
      // Hydrodynamic forces component
      HydrodynamicBlock6D hydrodynamicBlock6D(rho = rho, A = A, Cdx = Cdx, Cdy = Cdy, Cdz = Cdz, Crx = Crx, Cry = Cry, Crz = Crz, enableDragForce = enableDragForce) "Calculation of hydrodynamic forces and moments" annotation(
        Placement(transformation(origin = {24, 34}, extent = {{-10, -10}, {10, 10}})));
    equation
// Connect input frame to body
      connect(frame_a, bodyShape.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}}));
// Connect body to fixed translation
      connect(bodyShape.frame_b, fixedTranslation.frame_a) annotation(
        Line(points = {{-40, 0}, {-30, 0}}, color = {95, 95, 95}));
// Connect fixed translation to output frame
      connect(fixedTranslation.frame_b, frame_b) annotation(
        Line(points = {{-10, 0}, {102, 0}}, color = {95, 95, 95}));
// Connect hydrodynamic block to body
      connect(hydrodynamicBlock6D.frame_a, fixedTranslation.frame_b) annotation(
        Line(points = {{14, 34}, {-10, 34}, {-10, 0}}, color = {95, 95, 95}));
      connect(hydrodynamicBlock6D.frame_b, fixedTranslation.frame_b) annotation(
        Line(points = {{34, 34}, {46, 34}, {46, 0}, {-10, 0}}, color = {95, 95, 95}));
      annotation(
        Documentation(info = "<html>
    <p>This model represents a 6-dimensional hydrodynamic body, incorporating both rigid body dynamics and hydrodynamic forces.</p>
    <p>The model consists of:</p>
    <ul>
      <li>A main body with specified mass and inertia</li>
      <li>A fixed translation component to adjust the body's position</li>
      <li>A hydrodynamic block that calculates and applies various hydrodynamic forces and moments</li>
    </ul>
    <p>Inputs:</p>
    <ul>
      <li><code>frame_a</code>: Input frame for external connections</li>
    </ul>
    <p>Outputs:</p>
    <ul>
      <li><code>frame_b</code>: Output frame for external connections</li>
    </ul>
    <p>The hydrodynamic forces are applied to the body through the HydrodynamicBlock6D component, 
    which calculates drag, power take-off, hydrostatic, and radiation forces based on the body's motion.</p>
    <p>Note: The body's shape parameters (height, length, width) and mass can be adjusted as needed for specific applications.</p>
  </html>"),
        Icon(graphics = {Text(origin = {-2, -95}, extent = {{-58, 15}, {62, -5}}, textString = "Rigid Body 6D"), Rectangle(origin = {3, -10}, fillColor = {211, 215, 207}, fillPattern = FillPattern.Solid, extent = {{-95, 50}, {89, -50}}), Text(origin = {0, 54}, extent = {{-100, 16}, {100, -24}}, textString = "%name")}));
    end BodyHD6D;

    model ExcitationForce "1D Excitation Force Model for Hydrodynamic Systems"
      extends Modelica.Blocks.Icons.Block;
      // Output connector
      Modelica.Blocks.Interfaces.RealOutput y[3] "Excitation force vector [N] (only vertical component non-zero)" annotation(
        Placement(transformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}})));
      // Import the CombiTimeTable for data input
      import Modelica.Blocks.Sources.CombiTimeTable;
      // Excitation force data input
      CombiTimeTable excitationData(tableOnFile = true, fileName = "C:/Users/Duke/SysModel2024/DragSystem/ExcF9.csv", tableName = "excitation", columns = {2}, extrapolation = Modelica.Blocks.Types.Extrapolation.HoldLastPoint) "Time series data for vertical excitation force";
    equation
// Apply excitation force only in the vertical direction (third element)
      y = {0, 0, excitationData.y[1]};
      annotation(
        Documentation(info = "<html>
    <h4>1D Excitation Force Model for Hydrodynamic Systems</h4>
    <p>This model represents the excitation force for hydrodynamic systems, 
    considering only the vertical direction (1D model).</p>
    
    <p>Model Description:</p>
    <p>The excitation force is applied solely in the vertical direction (third element of the output vector). 
    The force magnitude is obtained from a time series data file, allowing for the representation of 
    time-varying excitation forces such as those caused by waves in marine applications.</p>
    
    <p>Inputs:</p>
    <ul>
      <li>No direct inputs. The excitation force is read from an external CSV file.</li>
    </ul>
    
    <p>Outputs:</p>
    <ul>
      <li><code>y[3]</code>: Excitation force vector [N] (force applied only in the vertical direction, third element)</li>
    </ul>
    
    <p>Key Components:</p>
    <ul>
      <li><code>excitationData</code>: CombiTimeTable that reads the excitation force data from a CSV file</li>
    </ul>
    
    <p>File Input:</p>
    <ul>
      <li>File path: C:/Users/Duke/SysModel2024/DragSystem/ExcF6.csv</li>
      <li>Table name: 'excitation'</li>
      <li>Only the second column of the CSV file is used (assumed to contain force values)</li>
    </ul>
    
    <p>Notes:</p>
    <ul>
      <li>The model assumes that the excitation force acts only in the vertical direction, simplifying the calculations for many marine applications.</li>
      <li>The excitation force data is held at its last value if the simulation time exceeds the data in the input file.</li>
      <li>Ensure that the CSV file path is correct and the file is accessible for successful simulation.</li>
    </ul>
  </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "1D Exc F", fontName = "Arial")}));
    end ExcitationForce;

    model RadiationF3D "1D Radiation Force Calculation for Hydrodynamic Systems"
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.absolutePosition_con;
      extends Hydrodynamic.Connector.absoluteVelocity_con;
      extends Hydrodynamic.Connector.forceTorque_con;
      // State-space model parameters for 3D radiation force
      parameter Real A11[2, 2] = [0, 1; -1.01116567551434, -0.936555983964093] "State matrix for 3D model";
      parameter Real A12[2, 2] = [0, 1; -1.01116567551434, -0.936555983964093] "State matrix for 3D model";
      parameter Real A13[2, 2] = [0, 1; -1.01116567551434, -0.936555983964093] "State matrix for 3D model";
      parameter Real A21[2, 2] = [0, 1; -1.01116567551434, -0.936555983964093] "State matrix for 3D model";
      parameter Real A22[2, 2] = [0, 1; -1.01116567551434, -0.936555983964093] "State matrix for 3D model";
      parameter Real A23[2, 2] = [0, 1; -1.01116567551434, -0.936555983964093] "State matrix for 3D model";
      parameter Real A31[2, 2] = [0, 1; -1.01116567551434, -0.936555983964093] "State matrix for 3D model";
      parameter Real A32[2, 2] = [0, 1; -1.01116567551434, -0.936555983964093] "State matrix for 3D model";
      parameter Real A33[2, 2] = [0, 1; -1.01116567551434, -0.936555983964093] "State matrix for 3D model";
      parameter Real B11[2] = {683236.706073938, -585411.342188539} "Input vector for 3D model";
      parameter Real B12[2] = {683236.706073938, -585411.342188539} "Input vector for 3D model";
      parameter Real B13[2] = {683236.706073938, -585411.342188539} "Input vector for 3D model";
      parameter Real B21[2] = {683236.706073938, -585411.342188539} "Input vector for 3D model";
      parameter Real B22[2] = {683236.706073938, -585411.342188539} "Input vector for 3D model";
      parameter Real B23[2] = {683236.706073938, -585411.342188539} "Input vector for 3D model";
      parameter Real B31[2] = {683236.706073938, -585411.342188539} "Input vector for 3D model";
      parameter Real B32[2] = {683236.706073938, -585411.342188539} "Input vector for 3D model";
      parameter Real B33[2] = {683236.706073938, -585411.342188539} "Input vector for 3D model";
      parameter Real C11[2] = {1, 0} "Output vector for 3D model";
      parameter Real C12[2] = {1, 0} "Output vector for 3D model";
      parameter Real C13[2] = {1, 0} "Output vector for 3D model";
      parameter Real C21[2] = {1, 0} "Output vector for 3D model";
      parameter Real C22[2] = {1, 0} "Output vector for 3D model";
      parameter Real C23[2] = {1, 0} "Output vector for 3D model";
      parameter Real C31[2] = {1, 0} "Output vector for 3D model";
      parameter Real C32[2] = {1, 0} "Output vector for 3D model";
      parameter Real C33[2] = {1, 0} "Output vector for 3D model";
      parameter Real D11 = 0 "Feed-through scalar for 3D model";
      parameter Real D12 = 0 "Feed-through scalar for 3D model";
      parameter Real D13 = 0 "Feed-through scalar for 3D model";
      parameter Real D21 = 0 "Feed-through scalar for 3D model";
      parameter Real D22 = 0 "Feed-through scalar for 3D model";
      parameter Real D23 = 0 "Feed-through scalar for 3D model";
      parameter Real D31 = 0 "Feed-through scalar for 3D model";
      parameter Real D32 = 0 "Feed-through scalar for 3D model";
      parameter Real D33 = 0 "Feed-through scalar for 3D model";
      parameter Real A[3, 3, 2, 2] = {{A11, A12, A13}, {A21, A22, A23}, {A31, A32, A33}} "State matrix for 3D model";
      parameter Real B[3, 3, 2] = {{B11, B12, B13}, {B21, B22, B23}, {B31, B32, B33}} "Input matrix for 3D model";
      parameter Real C[3, 3, 2] = {{C11, C12, C13}, {C21, C22, C23}, {C31, C32, C33}} "Output matrix for 3D model";
      parameter Real D[3, 3] = {{D11, D12, D13}, {D21, D22, D23}, {D31, D32, D33}} "Feed-through matrix for 3D model";
      // Control parameter
      parameter Boolean enableRadiationForce = true "Switch to enable/disable 1D radiation force calculation";
      // State variables
      Real x[18] "State vector for 1D radiation force model";
      Real F_rad[3] "Calculated 1D radiation force [N]";
    initial equation
      x = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} "Initialize state vector to zero";
    equation
// 3D Radiation force state-space model
      for i in 1:3 loop
        for j in 1:3 loop
          der(x[2*i - 1:2*i]) = A[i, :, :]*x[2*i - 1:2*i] + B[i, :, :]*v_abs;
          F_rad[i] = C[i, :, :]*x[2*i - 1:2*i] + D[i, :]*v_abs;
        end for;
      end for;
// Output: 3D radiation force
      if enableRadiationForce then
        F = {F_rad[1], F_rad[2], F_rad[3], 0, 0, 0};
      else
        F = {0, 0, 0, 0, 0, 0};
      end if;
      annotation(
        Documentation(info = "<html>
            <h4>3D Radiation Force Model for Hydrodynamic Systems</h4>
            <p>This model calculates the radiation force for hydrodynamic systems using a state-space representation, 
            considering only the vertical directions (3D model).</p>
            
            <p>Model Description:</p>
            <p>The radiation force is computed solely for the vertical direction (third element of the vectors) 
            based on the vertical velocity input. This simplification allows for efficient modeling of systems 
            where the primary concern is the vertical motion, such as in wave energy converters or floating structures.</p>
            
            <p>Inputs:</p>
            <ul>
              <li><code>z[3]</code>: Position vector [m] (currently not used in calculations, included for future extensions)</li>
              <li><code>v[3]</code>: Velocity vector [m/s] (only the third element, representing vertical velocity, is used)</li>
            </ul>
            
            <p>Outputs:</p>
            <ul>
              <li><code>y[3]</code>: Radiation force vector [N] (force applied only in the vertical direction, third element)</li>
            </ul>
            
            <p>Key Parameters:</p>
            <ul>
              <li><code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>: State-space model matrices and vectors for the 1D system</li>
              <li><code>enableRadiationForce</code>: Boolean switch to enable/disable the radiation force calculation</li>
            </ul>
            
            <p>Notes:</p>
            <ul>
              <li>The state-space model parameters (A, B, C, D) should be adjusted based on the specific 1D hydrodynamic system being modeled.</li>
              <li>This model assumes that the radiation force acts only in the vertical direction, simplifying the calculations for many marine applications.</li>
              <li>The position input (z) is currently not used in the calculations but is included for potential future enhancements or compatibility with other models.</li>
            </ul>
          </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "6D Rad F", fontName = "Arial")}));
    end RadiationF3D;

    model RadiationF2D "1D Radiation Force Calculation for Hydrodynamic Systems"
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.absolutePosition_con;
      extends Hydrodynamic.Connector.absoluteVelocity_con;
      extends Hydrodynamic.Connector.forceTorque_con;
      // Control parameter
      parameter Boolean enableRadiationForce = true "Switch to enable/disable 1D radiation force calculation";
      // State variables
      Real x[18] "State vector for 1D radiation force model";
      Real F_rad[3] "Calculated 1D radiation force [N]";
    initial equation
      x = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} "Initialize state vector to zero";
    equation
// 3D Radiation force state-space model
      for i in 1:3 loop
        for j in 1:3 loop
          der(x[2*i - 1:2*i]) = A[i, :, :]*x[2*i - 1:2*i] + B[i, :, :]*v_abs;
          F_rad[i] = C[i, :, :]*x[2*i - 1:2*i] + D[i, :]*v_abs;
        end for;
      end for;
// Output: 3D radiation force
      if enableRadiationForce then
        F = {F_rad[1], F_rad[2], F_rad[3], 0, 0, 0};
      else
        F = {0, 0, 0, 0, 0, 0};
      end if;
      annotation(
        Documentation(info = "<html>
            <h4>3D Radiation Force Model for Hydrodynamic Systems</h4>
            <p>This model calculates the radiation force for hydrodynamic systems using a state-space representation, 
            considering only the vertical directions (3D model).</p>
            
            <p>Model Description:</p>
            <p>The radiation force is computed solely for the vertical direction (third element of the vectors) 
            based on the vertical velocity input. This simplification allows for efficient modeling of systems 
            where the primary concern is the vertical motion, such as in wave energy converters or floating structures.</p>
            
            <p>Inputs:</p>
            <ul>
              <li><code>z[3]</code>: Position vector [m] (currently not used in calculations, included for future extensions)</li>
              <li><code>v[3]</code>: Velocity vector [m/s] (only the third element, representing vertical velocity, is used)</li>
            </ul>
            
            <p>Outputs:</p>
            <ul>
              <li><code>y[3]</code>: Radiation force vector [N] (force applied only in the vertical direction, third element)</li>
            </ul>
            
            <p>Key Parameters:</p>
            <ul>
              <li><code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>: State-space model matrices and vectors for the 1D system</li>
              <li><code>enableRadiationForce</code>: Boolean switch to enable/disable the radiation force calculation</li>
            </ul>
            
            <p>Notes:</p>
            <ul>
              <li>The state-space model parameters (A, B, C, D) should be adjusted based on the specific 1D hydrodynamic system being modeled.</li>
              <li>This model assumes that the radiation force acts only in the vertical direction, simplifying the calculations for many marine applications.</li>
              <li>The position input (z) is currently not used in the calculations but is included for potential future enhancements or compatibility with other models.</li>
            </ul>
          </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "6D Rad F", fontName = "Arial")}));
    end RadiationF2D;

    package IrregularWave
      model PiersonMoskowitzWave "Implementation of Pierson-Moskowitz (PM) wave spectrum for irregular wave generation"
        extends Hydrodynamic.Connector.forceandTorque_con;
        extends Hydrodynamic.Forces.readHydroCoeff;
        extends Modelica.Blocks.Icons.Block;
        import Modelica.Math.Vectors;
        // Internal connector for wave properties
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Acceleration due to gravity [m/s^2]";
        // Wave and environmental parameters
        parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
          Dialog(group = "Wave Parameters"));
        //parameter Modelica.Units.SI.Density rho = 1025 "Density of seawater [kg/m^3]" annotation(
        // Dialog(group = "Environmental Parameters"));
        parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_min = 0.03141 "Lowest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_max = 3.141 "Highest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_peak = 0.9423 "Peak spectral frequency [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Real spectralWidth_min = 0.07 "Lower spectral bound for JONSWAP" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Real spectralWidth_max = 0.09 "Upper spectral bound for JONSWAP" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Integer n_omega = 100 "Number of frequency components" annotation(
          Dialog(group = "Discretization"));
        parameter Integer localSeed = 614657 "Local random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed = 30020 "Global random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Real rnd_shft[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed, globalSeed, n_omega) "Random shifts for frequency selection";
        parameter Integer localSeed1 = 614757 "Local random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed1 = 40020 "Global random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Real epsilon[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed1, globalSeed1, n_omega) "Wave components phase shift";
        parameter Real Trmp = 100 "Interval for ramping up of waves during start phase [s]" annotation(
          Dialog(group = "Simulation Parameters"));
        // Derived parameters
        parameter Real omega[n_omega] = Hydrodynamic.Internal.Functions.randomFrequencySelector(omega_min, omega_max, rnd_shft) "Selected frequency components [rad/s]";
        parameter Real S[n_omega] = Hydrodynamic.Internal.Functions.spectrumGenerator_PM(Hs, omega) "Spectral values for frequency components [m^2-s/rad]";
        parameter Modelica.Units.SI.Length zeta[n_omega] = sqrt(2*S*omega_min) "Wave amplitude components [m]";
        parameter Real Tp[n_omega] = 2*pi./omega "Wave period components [s]";
        parameter Real k[n_omega] = Hydrodynamic.Internal.Functions.waveNumber(d, omega) "Wave number components [1/m]";
        // Variables
        Real ExcCoeffRe[nDoF, n_omega] "Real component of excitation coefficient for frequency components";
        Real ExcCoeffIm[nDoF, n_omega] "Imaginary component of excitation coefficient for frequency components";
        Real F_exc[nDoF] "6D excitation force [N]";
        Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
      equation
// Interpolate excitation coefficients (Re & Im) for each frequency component
        for i in 1:nDoF loop
          for j in 1:n_omega loop
            ExcCoeffRe[i, j] = Modelica.Math.Vectors.interpolate(w, F_excRe[i, :], omega[j])*rho*g;
            ExcCoeffIm[i, j] = Modelica.Math.Vectors.interpolate(w, F_excIm[i, :], omega[j])*rho*g;
          end for;
        end for;
// Calculate sea surface elevation (SSE) as the sum of all wave components
        SSE = sum(zeta.*cos(omega*time - 2*pi*epsilon));
// Calculate and apply ramping to the excitation force
        for i in 1:nDoF loop
// could probably extend zeta and time for 6 DoF for efficiency, but loop works in the interim
          if time < Trmp then
// Ramp up the excitation force during the initial phase
            F_exc[i] = 0.5*(1 + cos(pi + (pi*time/Trmp)))*sum((ExcCoeffRe[i].*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm[i].*zeta.*sin(omega*time - 2*pi*epsilon)));
          else
// Apply full excitation force after the ramping period
            F_exc[i] = sum((ExcCoeffRe[i].*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm[i].*zeta.*sin(omega*time - 2*pi*epsilon)));
          end if;
        end for;
/*
      // Assign excitation force to output (vertical component only)
        F = {0, 0, F_exc[3]};
        T = {0, 0, 0};
      */
// Assign excitation force to output (6DoF)
        F = F_exc[1:3];
        T = F_exc[4:6];
        annotation(
          Documentation(info = "<html>
            <h4>Pierson-Moskowitz Wave Spectrum Model</h4>
            <p>This model implements the Pierson-Moskowitz (PM) wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p>Key features:</p>
            <ul>
              <li>Generates a wave spectrum based on the PM formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <h4>Usage Notes:</h4>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " Pierson Moskowitz ", fontName = "Arial")}, coordinateSystem(initialScale = 0.1)),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end PiersonMoskowitzWave;

      model JonswapWave "Implementation of JONSWAP wave spectrum for irregular wave generation"
        extends Hydrodynamic.readHydroParam;
        extends Modelica.Blocks.Icons.Block;
        import Modelica.Math.Vectors;
        extends Hydrodynamic.Connector.forceandTorque_con;
        // Internal connector for wave properties
        Hydrodynamic.Internal.Connectors.WaveOutConn wconn "Internal connector for wave properties";
        // Output connector for excitation force
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Acceleration due to gravity [m/s^2]";
        // Wave and environmental parameters
        parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.Density rho = 1025 "Density of seawater [kg/m^3]" annotation(
          Dialog(group = "Environmental Parameters"));
        parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_min = 0.03141 "Lowest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_max = 3.141 "Highest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_peak = 0.9423 "Peak spectral frequency [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Real spectralWidth_min = 0.07 "Lower spectral bound for JONSWAP" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Real spectralWidth_max = 0.09 "Upper spectral bound for JONSWAP" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Integer n_omega = 100 "Number of frequency components" annotation(
          Dialog(group = "Discretization"));
        parameter Integer localSeed = 614657 "Local random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed = 30020 "Global random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Real rnd_shft[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed, globalSeed, n_omega) "Random shifts for frequency selection";
        parameter Integer localSeed1 = 614757 "Local random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed1 = 40020 "Global random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Real epsilon[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed1, globalSeed1, n_omega) "Wave components phase shift";
        parameter Real Trmp = 200 "Interval for ramping up of waves during start phase [s]" annotation(
          Dialog(group = "Simulation Parameters"));
        // Derived parameters
        parameter Real omega[n_omega] = Hydrodynamic.Internal.Functions.frequencySelector(omega_min, omega_max, rnd_shft) "Selected frequency components [rad/s]";
        parameter Real S[n_omega] = Hydrodynamic.Internal.Functions.spectrumGenerator_JONSWAP(Hs, omega, omega_peak, spectralWidth_min, spectralWidth_max) "Spectral values for frequency components [m^2-s/rad]";
        parameter Modelica.Units.SI.Length zeta[n_omega] = sqrt(2*S*omega_min) "Wave amplitude components [m]";
        parameter Real Tp[n_omega] = 2*pi./omega "Wave period components [s]";
        parameter Real k[n_omega] = Hydrodynamic.Internal.Functions.waveNumber(d, omega) "Wave number components [1/m]";
        // Variables
        Real ExcCoeffRe[n_omega] "Real component of excitation coefficient for frequency components";
        Real ExcCoeffIm[n_omega] "Imaginary component of excitation coefficient for frequency components";
        Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
      equation
// Interpolate excitation coefficients (Re & Im) for each frequency component
        for i in 1:n_omega loop
          ExcCoeffRe[i] = Modelica.Math.Vectors.interpolate(w, F_excRe, omega[i])*rho*g;
          ExcCoeffIm[i] = Modelica.Math.Vectors.interpolate(w, F_excIm, omega[i])*rho*g;
        end for;
// Calculate sea surface elevation (SSE) as the sum of all wave components
        SSE = sum(zeta.*cos(omega*time - 2*pi*epsilon));
// Calculate and apply ramping to the excitation force
        if time < Trmp then
// Ramp up the excitation force during the initial phase
          wconn.F_exc = 0.5*(1 + cos(pi + (pi*time/Trmp)))*sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
        else
// Apply full excitation force after the ramping period
          wconn.F_exc = sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
        end if;
// Assign excitation force to output (vertical component only)
        F = {0, 0, wconn.F_exc};
        T = {0, 0, 0};
        annotation(
          Documentation(info = "<html>
            <h4>JONSWAP Wave Spectrum Model</h4>
            <p>This model implements the JONSWAP (Joint North Sea Wave Project) wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p>Key features:</p>
            <ul>
              <li>Generates a wave spectrum based on the JONSWAP formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <h4>Usage Notes:</h4>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
              <li>JONSWAP spectrum is particularly suitable for modeling developing seas and storm conditions</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " JONSWAP ", fontName = "Arial")}),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end JonswapWave;

      model BretschneiderWave "Implementation of Bretschneider wave spectrum for irregular wave generation"
        extends Hydrodynamic.readHydroParam;
        extends Modelica.Blocks.Icons.Block;
        import Modelica.Math.Vectors;
        extends Hydrodynamic.Connector.forceandTorque_con;
        // Internal connector for wave properties
        Hydrodynamic.Internal.Connectors.WaveOutConn wconn "Internal connector for wave properties";
        // Output connector for excitation force
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Acceleration due to gravity [m/s^2]";
        // Wave and environmental parameters
        parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
          Dialog(group = "Environmental Parameters"));
        parameter Modelica.Units.SI.Density rho = 1025 "Density of seawater [kg/m^3]" annotation(
          Dialog(group = "Environmental Parameters"));
        parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_min = 0.03141 "Lowest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_max = 3.141 "Highest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_peak = 0.9423 "Peak spectral frequency [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Integer n_omega = 100 "Number of frequency components" annotation(
          Dialog(group = "Discretization"));
        parameter Integer localSeed = 614657 "Local random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed = 30020 "Global random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Real rnd_shft[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed, globalSeed, n_omega) "Random shifts for frequency selection";
        parameter Integer localSeed1 = 614757 "Local random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed1 = 40020 "Global random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Real epsilon[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed1, globalSeed1, n_omega) "Wave components phase shift";
        parameter Real Trmp = 200 "Interval for ramping up of waves during start phase [s]" annotation(
          Dialog(group = "Simulation Parameters"));
        // Derived parameters
        parameter Real omega[n_omega] = Hydrodynamic.Internal.Functions.frequencySelector(omega_min, omega_max, rnd_shft) "Selected frequency components [rad/s]";
        parameter Real S[n_omega] = Hydrodynamic.Internal.Functions.spectrumGenerator_BRT(Hs, omega, omega_peak) "Spectral values for frequency components [m^2-s/rad]";
        parameter Modelica.Units.SI.Length zeta[n_omega] = sqrt(2*S*omega_min) "Wave amplitude components [m]";
        parameter Real Tp[n_omega] = 2*pi./omega "Wave period components [s]";
        parameter Real k[n_omega] = Hydrodynamic.Internal.Functions.waveNumber(d, omega) "Wave number components [1/m]";
        // Variables
        Real ExcCoeffRe[n_omega] "Real component of excitation coefficient for frequency components";
        Real ExcCoeffIm[n_omega] "Imaginary component of excitation coefficient for frequency components";
        Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
      equation
// Interpolate excitation coefficients (Re & Im) for each frequency component
        for i in 1:n_omega loop
          ExcCoeffRe[i] = Modelica.Math.Vectors.interpolate(w, F_excRe, omega[i])*rho*g;
          ExcCoeffIm[i] = Modelica.Math.Vectors.interpolate(w, F_excIm, omega[i])*rho*g;
        end for;
// Calculate sea surface elevation (SSE) as the sum of all wave components
        SSE = sum(zeta.*cos(omega*time - 2*pi*epsilon));
// Calculate and apply ramping to the excitation force
        if time < Trmp then
// Ramp up the excitation force during the initial phase
          wconn.F_exc = 0.5*(1 + cos(pi + (pi*time/Trmp)))*sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
        else
// Apply full excitation force after the ramping period
          wconn.F_exc = sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
        end if;
// Assign excitation force to output (vertical component only)
        F = {0, 0, wconn.F_exc};
        T = {0, 0, 0};
        annotation(
          Documentation(info = "<html>
            <p><b>Bretschneider Wave Spectrum Model</b></p>
            <p>This model implements the Bretschneider wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p><b>Key features:</b></p>
            <ul>
              <li>Generates a wave spectrum based on the Bretschneider formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <p><b>Usage Notes:</b></p>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " Bretschneider ", fontName = "Arial")}, coordinateSystem(initialScale = 0.1)),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end BretschneiderWave;

      partial model IrregularWaveParameters
        extends Hydrodynamic.readHydroParam;
        extends Modelica.Blocks.Icons.Block;
        import Modelica.Math.Vectors;
        extends Hydrodynamic.Connector.forceandTorque_con;
        // Internal connector for wave properties
        Hydrodynamic.Internal.Connectors.WaveOutConn wconn "Internal connector for wave properties";
        // Output connector for excitation force
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Acceleration due to gravity [m/s^2]";
        // Wave and environmental parameters
        parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
          Dialog(group = "Environmental Parameters"));
        parameter Modelica.Units.SI.Density rho = 1025 "Density of seawater [kg/m^3]" annotation(
          Dialog(group = "Environmental Parameters"));
        parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_min = 0.03141 "Lowest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_max = 3.141 "Highest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_peak = 0.9423 "Peak spectral frequency [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Integer n_omega = 100 "Number of frequency components" annotation(
          Dialog(group = "Discretization"));
        parameter Integer localSeed = 614657 "Local random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed = 30020 "Global random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Real rnd_shft[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed, globalSeed, n_omega) "Random shifts for frequency selection";
        parameter Integer localSeed1 = 614757 "Local random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed1 = 40020 "Global random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Real epsilon[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed1, globalSeed1, n_omega) "Wave components phase shift";
        parameter Real Trmp = 200 "Interval for ramping up of waves during start phase [s]" annotation(
          Dialog(group = "Simulation Parameters"));
        // Derived parameters
        Real omega[n_omega];
        Modelica.Units.SI.Length zeta[n_omega];
        Real domega[n_omega];
        Real Tp[n_omega] "Wave period components [s]";
        Real k[n_omega];
        parameter String frequencySelection = "equalEnergy";
        // or equalEnergy
        Real S[n_omega];
        // Variables
        Real ExcCoeffRe[n_omega] "Real component of excitation coefficient for frequency components";
        Real ExcCoeffIm[n_omega] "Imaginary component of excitation coefficient for frequency components";
        Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
        Real omega_int[n_omega_int];
        parameter Integer n_omega_int = 500;
        Real S_int[n_omega_int];
      equation
        Tp = 2*pi./omega "Wave period components [s]";
        k = Hydrodynamic.Internal.Functions.waveNumber(d, omega) "Wave number components [1/m]";
        if frequencySelection == "equalEnergy" then
          omega_int = Hydrodynamic.Internal.Functions.integrationFrequencyGen(omega_min, omega_max, n_omega_int);
          (omega, S) = Hydrodynamic.Internal.Functions.equalEnergyGen(omega_min, omega_max, n_omega, n_omega_int, omega_int, S_int);
        elseif frequencySelection == "random" then
          omega = Hydrodynamic.Internal.Functions.frequencySelector(omega_min, omega_max, rnd_shft) "Selected frequency components [rad/s]";
          omega_int = zeros(n_omega_int);
          S_int = zeros(n_omega_int);
        end if;
        domega = Hydrodynamic.Internal.Functions.dfrequencyGen(omega, S, n_omega);
        zeta = sqrt(2*S.*domega) "Wave amplitude components [m]";
// Interpolate excitation coefficients (Re & Im) for each frequency component
        for i in 1:n_omega loop
          ExcCoeffRe[i] = Modelica.Math.Vectors.interpolate(w, F_excRe, omega[i])*rho*g;
          ExcCoeffIm[i] = Modelica.Math.Vectors.interpolate(w, F_excIm, omega[i])*rho*g;
        end for;
// Calculate sea surface elevation (SSE) as the sum of all wave components
        SSE = sum(zeta.*cos(omega*time - 2*pi*epsilon));
// Calculate and apply ramping to the excitation force
        if time < Trmp then
// Ramp up the excitation force during the initial phase
          wconn.F_exc = 0.5*(1 + cos(pi + (pi*time/Trmp)))*sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
        else
// Apply full excitation force after the ramping period
          wconn.F_exc = sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
        end if;
// Assign excitation force to output (vertical component only)
        F = {0, 0, wconn.F_exc};
        T = {0, 0, 0};
        annotation(
          Documentation(info = "<html>
            <p><b>Bretschneider Wave Spectrum Model</b></p>
            <p>This model implements the Bretschneider wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p><b>Key features:</b></p>
            <ul>
              <li>Generates a wave spectrum based on the Bretschneider formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <p><b>Usage Notes:</b></p>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " Bretschneider ", fontName = "Arial")}, coordinateSystem(initialScale = 0.1)),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end IrregularWaveParameters;

      model LinearWave "Implementation of linear Airy wave model with excitation force calculation"
        extends Hydrodynamic.readHydroParam;
        extends Modelica.Blocks.Icons.Block;
        import Modelica.Math.Vectors;
        // Output connector for excitation force
        Modelica.Blocks.Interfaces.RealOutput y[3] "Excitation force vector [N] (only vertical component non-zero)" annotation(
          Placement(transformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}})),
          Documentation(info = "<html>
            <p>Output connector for the calculated excitation force. Only the vertical component (3rd element) is non-zero.</p>
          </html>"));
        // Internal connector for wave properties
        Hydrodynamic.Internal.Connectors.WaveOutConn wconn "Internal connector for wave properties";
        // Environmental constants
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Acceleration due to gravity [m/s^2]";
        // Wave parameters
        parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.Density rho = 1025 "Density of seawater [kg/m^3]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega = 0.9423 "Wave frequency [rad/s]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Real Trmp = 50 "Interval for ramping up of waves during start phase [s]" annotation(
          Dialog(group = "Wave Parameters"));
        // Derived parameters
        parameter Modelica.Units.SI.Length zeta = Hs/2 "Wave amplitude [m]";
        parameter Real Tp = 2*pi/omega "Wave period [s]";
        parameter Real k = 2*pi/(1.56*(Tp^2)) "Wave number [1/m]";
        // Variables
        Real ExcCoeffRe "Real component of excitation coefficient";
        Real ExcCoeffIm "Imaginary component of excitation coefficient";
        Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
      equation
// Interpolate excitation coefficients (Re & Im) for the given wave frequency
        ExcCoeffRe = Modelica.Math.Vectors.interpolate(w, F_excRe, omega);
        ExcCoeffIm = Modelica.Math.Vectors.interpolate(w, F_excIm, omega);
// Define wave elevation profile (SSE)
        SSE = zeta*cos(omega*time);
// Calculate and apply ramping to the excitation force
        if time < Trmp then
          wconn.F_exc = 0.5*(1 + cos(pi + (pi*time/Trmp)))*((ExcCoeffRe*zeta*cos(omega*time)) - (ExcCoeffIm*zeta*sin(omega*time)))*rho*g;
        else
          wconn.F_exc = ((ExcCoeffRe*zeta*cos(omega*time)) - (ExcCoeffIm*zeta*sin(omega*time)))*rho*g;
        end if;
// Assign excitation force to output (vertical component only)
        y = {0, 0, wconn.F_exc};
        annotation(
          Documentation(info = "<html>
            <p>This model implements the linear Airy wave theory to calculate wave elevation profiles and associated excitation forces.</p>
            <p>Key features:</p>
            <ul>
              <li>Calculates sea surface elevation (SSE) based on wave parameters</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
          </html>"),
          Icon(graphics = {Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = "Linear Wave", fontName = "Arial")}),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end LinearWave;

      partial model IrregularWaveParameters_6DoF
        extends Hydrodynamic.Forces.readHydroCoeff;
        extends Modelica.Blocks.Icons.Block;
        import Modelica.Math.Vectors;
        extends Hydrodynamic.Connector.forceandTorque_con;
        // Output connector for excitation force
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Acceleration due to gravity [m/s^2]";
        // Wave and environmental parameters
        parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
          Dialog(group = "Environmental Parameters"));
        parameter Modelica.Units.SI.Density rho = 1025 "Density of seawater [kg/m^3]" annotation(
          Dialog(group = "Environmental Parameters"));
        parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_min = 0.03141 "Lowest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_max = 3.141 "Highest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_peak = 0.9423 "Peak spectral frequency [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Integer n_omega = 100 "Number of frequency components" annotation(
          Dialog(group = "Discretization"));
        parameter Integer localSeed = 614657 "Local random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed = 30020 "Global random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Real rnd_shft[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed, globalSeed, n_omega) "Random shifts for frequency selection";
        parameter Integer localSeed1 = 614757 "Local random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed1 = 40020 "Global random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Real epsilon[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed1, globalSeed1, n_omega) "Wave components phase shift";
        parameter Real Trmp = 200 "Interval for ramping up of waves during start phase [s]" annotation(
          Dialog(group = "Simulation Parameters"));
        // Derived parameters
        Real omega[n_omega];
        Modelica.Units.SI.Length zeta[n_omega];
        Real domega[n_omega];
        Real Tp[n_omega] "Wave period components [s]";
        Real k[n_omega];
        parameter String frequencySelection = "random";
        // or equalEnergy
        Real S[n_omega];
        // Variables
        Real ExcCoeffRe[nDoF, n_omega] "Real component of excitation coefficient for frequency components";
        Real ExcCoeffIm[nDoF, n_omega] "Imaginary component of excitation coefficient for frequency components";
        Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
        Real omega_int[n_omega_int];
        parameter Integer n_omega_int = 500;
        Real S_int[n_omega_int];
        Real F_exc[nDoF] "6D excitation force [N]";
      equation
        Tp = 2*pi./omega "Wave period components [s]";
        k = Hydrodynamic.Internal.Functions.waveNumber(d, omega) "Wave number components [1/m]";
        if frequencySelection == "equalEnergy" then
          omega_int = Hydrodynamic.Forces1D.integrationFrequencyGen(omega_min, omega_max, n_omega_int);
          (omega, S) = Hydrodynamic.Forces1D.equalEnergyGen(omega_min, omega_max, n_omega, n_omega_int, omega_int, S_int);
        elseif frequencySelection == "random" then
          omega = Hydrodynamic.Internal.Functions.frequencySelector(omega_min, omega_max, rnd_shft) "Selected frequency components [rad/s]";
          omega_int = zeros(n_omega_int);
          S_int = zeros(n_omega_int);
        end if;
        domega = Hydrodynamic.Forces1D.dfrequencyGen(omega, S, n_omega);
        zeta = sqrt(2*S.*domega) "Wave amplitude components [m]";
// Interpolate excitation coefficients (Re & Im) for each frequency component
        for i in 1:nDoF loop
          for j in 1:n_omega loop
            ExcCoeffRe[i, j] = Modelica.Math.Vectors.interpolate(w, F_excRe[i, :], omega[i])*rho*g;
            ExcCoeffIm[i, j] = Modelica.Math.Vectors.interpolate(w, F_excIm[i, :], omega[i])*rho*g;
          end for;
        end for;
// Calculate sea surface elevation (SSE) as the sum of all wave components
        SSE = sum(zeta.*cos(omega*time - 2*pi*epsilon));
        for i in 1:nDoF loop
// Calculate and apply ramping to the excitation force
          if time < Trmp then
// Ramp up the excitation force during the initial phase
            F_exc[i] = 0.5*(1 + cos(pi + (pi*time/Trmp)))*sum((ExcCoeffRe[i].*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm[i].*zeta.*sin(omega*time - 2*pi*epsilon)));
          else
// Apply full excitation force after the ramping period
            F_exc[i] = sum((ExcCoeffRe[i].*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm[i].*zeta.*sin(omega*time - 2*pi*epsilon)));
          end if;
        end for;
// Assign excitation force to output (vertical component only)
        F = F_exc[1:3];
        T = F_exc[4:6];
        annotation(
          Documentation(info = "<html>
            <p><b>Bretschneider Wave Spectrum Model</b></p>
            <p>This model implements the Bretschneider wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p><b>Key features:</b></p>
            <ul>
              <li>Generates a wave spectrum based on the Bretschneider formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <p><b>Usage Notes:</b></p>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " Bretschneider ", fontName = "Arial")}, coordinateSystem(initialScale = 0.1)),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end IrregularWaveParameters_6DoF;
    end IrregularWave;
  end Archive;

  package Forces1D
    model HydrodynamicBlock6D_1DoFRad "6-Dimensional Hydrodynamic Forces and Moments Calculation"
      extends Hydrodynamic.Forces1D.readHydroParam1D;
      extends Modelica.Units.SI;
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.inputOutput_con;
      // Parameters for BodyShape
      parameter Position r[3] = {0, 0, 0} "Position vector" annotation(
        Dialog(group = "Body"));
      parameter Position r_CM[3] = {0, 0, 0} "Center of mass position vector" annotation(
        Dialog(group = "Body"));
      parameter Position length = 0.1 "Length of the body" annotation(
        Dialog(group = "Body"));
      parameter Position width = 0.1 "Width of the body" annotation(
        Dialog(group = "Body"));
      parameter Position height = 0.1 "Height of the body" annotation(
        Dialog(group = "Body"));
      parameter Inertia I_11 = 0.001 "Element (1,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Inertia I_22 = 0.001 "Element (2,2) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Inertia I_33 = 0.001 "Element (3,3) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Inertia I_21 = 0 "Element (2,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Inertia I_31 = 0 "Element (3,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Inertia I_32 = 0 "Element (3,2) of inertia tensor" annotation(
        Dialog(group = "Body"));
      Modelica.Mechanics.MultiBody.Parts.BodyShape bodyShape(r = r, r_CM = r_CM, m = m, length = length, width = width, height = height, I_11 = I_11, I_22 = I_22, I_33 = I_33, I_21 = I_21, I_31 = I_31, I_32 = I_32) annotation(
        Placement(transformation(origin = {10, -84}, extent = {{-10, -10}, {10, 10}})));
      // Parameters for HydrostaticForce6D
      parameter Boolean enableHydrostaticForce = true "Switch to enable/disable hydrostatic force calculation" annotation(
        Dialog(group = "Hydrostatic Stiffness Parameters"));
      parameter TranslationalSpringConstant G1 = 0 "Hydrostatic restoring coefficient for x-axis translation" annotation(
        Dialog(group = "Hydrostatic Stiffness Parameters"));
      parameter TranslationalSpringConstant G2 = 0 "Hydrostatic restoring coefficient for y-axis translation" annotation(
        Dialog(group = "Hydrostatic Stiffness Parameters"));
      parameter RotationalSpringConstant G4 = 0 "Hydrostatic restoring coefficient for x-axis rotation" annotation(
        Dialog(group = "Hydrostatic Stiffness Parameters"));
      parameter RotationalSpringConstant G5 = 0 "Hydrostatic restoring coefficient for y-axis rotation" annotation(
        Dialog(group = "Hydrostatic Stiffness Parameters"));
      parameter RotationalSpringConstant G6 = 0 "Hydrostatic restoring coefficient for z-axis rotation" annotation(
        Dialog(group = "Hydrostatic Stiffness Parameters"));
      //HydrostaticForce6D_6DoFRad hydrostaticForce6D_6DoFRad(enableHydrostaticForce = enableHydrostaticForce, G1 = G1, G2 = G2, G4 = G4, G5 = G5, G6 = G6) "Hydrostatic force calculation" annotation(
      //  Placement(transformation(origin = {16, -20}, extent = {{-10, -10}, {10, 10}})));
      // Hydrostatic Force components
      // Parameters for RadiationF
      parameter Boolean enableRadiationForce = true "Switch to enable/disable 1D radiation force calculation" annotation(
        Dialog(group = "Radiation Force Parameters"));
      // HydrodynamicBlock6D components and connections
      Radiation1D radiation1D(A = A, B = B, C = C, D = D, enableRadiationForce = enableRadiationForce) "1D Radiation Force Calculation" annotation(
        Placement(transformation(origin = {16, 56}, extent = {{-10, -10}, {10, 10}})));
      // Parameters for PTO6D
      parameter Boolean enablePTOForce = false "Switch to enable/disable PTO force calculation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter String controllerSelect = "reactive" "Controller type select" annotation(
        Dialog(group = "PTO Parameters"));
      parameter AngularFrequency omega_peak = 0.9423 "Peak spectral frequency" annotation(
        Dialog(group = "PTO Parameters"));
      parameter Real Kpx = 0.0 "Proportional gain for x-axis translation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter Real Kpy = 0.0 "Proportional gain for y-axis translation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter Real Kprx = 0.0 "Proportional gain for x-axis rotation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter Real Kpry = 0.0 "Proportional gain for y-axis rotation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter Real Kprz = 0.0 "Proportional gain for z-axis rotation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter TranslationalSpringConstant Kix = 0.0 "Integral gain for x-axis translation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter TranslationalSpringConstant Kiy = 0.0 "Integral gain for y-axis translation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter RotationalSpringConstant Kirx = 0.0 "Integral gain for x-axis rotation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter RotationalSpringConstant Kiry = 0.0 "Integral gain for y-axis rotation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter RotationalSpringConstant Kirz = 0.0 "Integral gain for z-axis rotation" annotation(
        Dialog(group = "PTO Parameters"));
      // PTO components
      PTO6D pto6d(omega_peak = omega_peak, Kpx = Kpx, Kpy = Kpy, Kprx = Kprx, Kpry = Kpry, Kprz = Kprz, Kix = Kix, Kiy = Kiy, Kirx = Kirx, Kiry = Kiry, Kirz = Kirz, enablePTOForce = enablePTOForce, controllerSelect = controllerSelect) "Power Take-Off force calculation" annotation(
        Placement(transformation(origin = {16, -46}, extent = {{-10, -10}, {10, 10}})));
      // Parameters for DragForce6D
      parameter Boolean enableDragForce = false "Switch to enable/disable drag force calculation" annotation(
        Dialog(group = "Drag Parameters"));
      parameter MassConcentration rho = 1000 "Density of fluid" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Area A1 = 1 "Reference area" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Real Cdx = 100 "Translational drag coefficient for x-axis" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Real Cdy = 0.01 "Translational drag coefficient for y-axis" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Real Cdz = 100 "Translational drag coefficient for z-axis" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Real Crx = 100 "Rotational drag coefficient for x-axis" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Real Cry = 0.01 "Rotational drag coefficient for y-axis" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Real Crz = 100 "Rotational drag coefficient for z-axis" annotation(
        Dialog(group = "Drag Parameters"));
      // Drag force components
      DragForce6D dragForce6D(rho = rho, A = A1, Cdx = Cdx, Cdy = Cdy, Cdz = Cdz, Crx = Crx, Cry = Cry, Crz = Crz, enableDragForce = enableDragForce) "Drag force calculation" annotation(
        Placement(transformation(origin = {16, 24}, extent = {{-10, -10}, {10, 10}})));
      // Force and torque application components
      ForceToqueSum forceToqueSum annotation(
        Placement(transformation(origin = {50, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque forceAndTorque annotation(
        Placement(transformation(origin = {82, 0}, extent = {{-10, 10}, {10, -10}}, rotation = -0)));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteSensor absoluteSensor(get_r = true, get_v = true, get_a = false, get_z = false, get_angles = true, get_w = true) annotation(
        Placement(transformation(origin = {-61, 1}, extent = {{-11, -11}, {11, 11}})));
      HydrostaticForce6D_1DoFRad hydrostaticForce6D_1DoFRad(enableHydrostaticForce = enableHydrostaticForce, G1 = G1, G2 = G2, G4 = G4, G5 = G5, G6 = G6) "Hydrostatic force calculation" annotation(
        Placement(transformation(origin = {-10, -12}, extent = {{-10, -10}, {10, 10}})));
    equation
      connect(bodyShape.frame_a, frame_a) annotation(
        Line(points = {{0, -84}, {-102, -84}, {-102, 0}}, color = {95, 95, 95}));
      connect(bodyShape.frame_b, frame_b) annotation(
        Line(points = {{20, -84}, {102, -84}, {102, 0}}, color = {95, 95, 95}));
      connect(forceAndTorque.frame_b, bodyShape.frame_b) annotation(
        Line(points = {{92, 0}, {92, -84}, {20, -84}}, color = {95, 95, 95}));
      connect(forceToqueSum.F, forceAndTorque.force) annotation(
        Line(points = {{61, 5}, {64, 5}, {64, 6}, {70, 6}}, color = {0, 0, 127}, thickness = 0.5));
      connect(forceToqueSum.T, forceAndTorque.torque) annotation(
        Line(points = {{61, -5}, {70, -5}, {70, -6}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.v, radiation1D.v_abs) annotation(
        Line(points = {{-68, -11}, {-72, -11}, {-72, 54}, {4, 54}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.angles, radiation1D.theta_abs) annotation(
        Line(points = {{-59, -11}, {-72, -11}, {-72, 59}, {4, 59}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.w, radiation1D.omega_abs) annotation(
        Line(points = {{-54, -11}, {-72, -11}, {-72, 48}, {4, 48}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.w, dragForce6D.omega_abs) annotation(
        Line(points = {{-54, -11}, {-72, -11}, {-72, 16}, {4, 16}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.r, radiation1D.u_abs) annotation(
        Line(points = {{-72, -11}, {-72, 64}, {4, 64}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.w, pto6d.omega_abs) annotation(
        Line(points = {{-54, -12}, {-72, -12}, {-72, -54}, {4, -54}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.r, pto6d.u_abs) annotation(
        Line(points = {{-72, -12}, {-72, -38}, {4, -38}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.angles, pto6d.theta_abs) annotation(
        Line(points = {{-58, -12}, {-72, -12}, {-72, -44}, {4, -44}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.v, pto6d.v_abs) annotation(
        Line(points = {{-68, -12}, {-72, -12}, {-72, -48}, {4, -48}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.v, dragForce6D.v_abs) annotation(
        Line(points = {{-68, -12}, {-72, -12}, {-72, 22}, {4, 22}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.frame_a, bodyShape.frame_b) annotation(
        Line(points = {{-72, 2}, {-86, 2}, {-86, -68}, {20, -68}, {20, -84}}, color = {95, 95, 95}));
      connect(radiation1D.F, forceToqueSum.Fr) annotation(
        Line(points = {{27, 56}, {30, 56}, {30, 8}, {38, 8}}, color = {0, 0, 127}, thickness = 0.5));
      connect(dragForce6D.F, forceToqueSum.Fd) annotation(
        Line(points = {{27, 24}, {30, 24}, {30, -2}, {38, -2}}, color = {0, 0, 127}, thickness = 0.5));
      connect(pto6d.F, forceToqueSum.Fpto) annotation(
        Line(points = {{28, -46}, {30, -46}, {30, -8}, {38, -8}}, color = {0, 0, 127}, thickness = 0.5));
      connect(hydrostaticForce6D_1DoFRad.F, forceToqueSum.Fhs) annotation(
        Line(points = {{2, -12}, {24, -12}, {24, 2}, {38, 2}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.r, hydrostaticForce6D_1DoFRad.u_abs) annotation(
        Line(points = {{-72, -12}, {-46, -12}, {-46, -4}, {-22, -4}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.angles, hydrostaticForce6D_1DoFRad.theta_abs) annotation(
        Line(points = {{-58, -12}, {-48, -12}, {-48, -24}, {-32, -24}, {-32, -10}, {-22, -10}}, color = {0, 0, 127}, thickness = 0.5));
    end HydrodynamicBlock6D_1DoFRad;

    block PTO6D "6-Dimensional Power Take-Off (PTO) System"
      extends Hydrodynamic.Forces1D.readHydroParam1D;
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.absolutePosition_con;
      extends Hydrodynamic.Connector.absoluteVelocity_con;
      extends Hydrodynamic.Connector.forceTorque_con;
      parameter Modelica.Units.SI.AngularFrequency omega_peak "Peak spectral frequency";
      Modelica.Units.SI.Mass amdep = Modelica.Math.Vectors.interpolate(w, Adep, omega_peak);
      Modelica.Units.SI.TranslationalDampingConstant Bpto = Modelica.Math.Vectors.interpolate(w, Rdamp, omega_peak);
      Modelica.Units.SI.TranslationalSpringConstant Kpto;
      Modelica.Units.SI.Mass Mpto;
      //Modelica.Units.SI.Force Fpto;
      //Modelica.Units.SI.Power Ppto;
      //Modelica.Blocks.Math.ContinuousMean Ppto_avg;
      // Proportional gain parameters
      parameter Real Kpx "Proportional gain for x-axis translation [N/(m/s)]";
      parameter Real Kpy "Proportional gain for y-axis translation [N/(m/s)]";
      Real Kpz "Proportional gain for z-axis translation [N/(m/s)]";
      parameter Real Kprx "Proportional gain for x-axis rotation [N*m/(rad/s)]";
      parameter Real Kpry "Proportional gain for y-axis rotation [N*m/(rad/s)]";
      parameter Real Kprz "Proportional gain for z-axis rotation [N*m/(rad/s)]";
      Real Kp[6, 6] "Combined proportional gain matrix";
      // Integral gain parameters
      parameter Real Kix "Integral gain for x-axis translation [N/m]";
      parameter Real Kiy "Integral gain for y-axis translation [N/m]";
      Real Kiz "Integral gain for z-axis translation [N/m]";
      parameter Real Kirx "Integral gain for x-axis rotation [N*m/rad]";
      parameter Real Kiry "Integral gain for y-axis rotation [N*m/rad]";
      parameter Real Kirz "Integral gain for z-axis rotation [N*m/rad]";
      Real Ki[6, 6] "Combined integral gain matrix";
      // Control parameter
      parameter Boolean enablePTOForce = true "Switch to enable/disable PTO force calculation";
      // Internal variable
      Real fpto[6] "Combined PTO force/torque vector [N, N*m]";
      Real u_theta[6] "Combined displacement vector [m, rad]";
      Real v_omega[6] "Combined linear and angular velocity vector [m/s, rad/s]";
      Real bpto;
      parameter String controllerSelect = "reactive" annotation(
        Dialog(group = "Controller type select"));
    equation
      Kiz = Kpto;
      Kp = diagonal({Kpx, Kpy, Kpz, Kprx, Kpry, Kprz});
      Kpz = bpto;
      Ki = diagonal({Kix, Kiy, Kiz, Kirx, Kiry, Kirz});
      u_theta = cat(1, u_abs, theta_abs);
      v_omega = cat(1, v_abs, omega_abs);
// Calculate the combined PTO force/torque vector
      fpto = Kp*v_omega + Ki*u_theta;
      Mpto = M + amdep;
// Use the switch to conditionally output the force and torque
      if enablePTOForce then
        F = -fpto;
      else
        F = zeros(6);
      end if;
      if controllerSelect == "passive" then
        Kpto = 0;
        bpto = (Bpto^2 + (omega_peak*(Mpto) - Khs/omega_peak)^2)^(1/2);
      elseif controllerSelect == "reactive" then
        Kpto = (Mpto)*omega_peak - Khs/omega_peak;
// no khs in here
        bpto = Bpto;
      end if;
      annotation(
        Documentation(info = "<html>
        <p>This block models a 6-dimensional Power Take-Off (PTO) system for both translational and rotational motion.</p>
        <p>The PTO force/torque is calculated using a combination of proportional and integral control based on the input velocities and displacements.</p>
        <p>The block can be enabled or disabled using the <code>enablePTOForce</code> parameter.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>u</code>: Linear velocity vector [m/s]</li>
          <li><code>s</code>: Linear displacement vector [m]</li>
          <li><code>omega</code>: Angular velocity vector [rad/s]</li>
          <li><code>theta</code>: Angular displacement vector [rad]</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>y</code>: Translational PTO force vector [N]</li>
          <li><code>y1</code>: Rotational PTO torque vector [N*m]</li>
        </ul>
      </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "PTO 6D", fontName = "Arial")}));
    end PTO6D;

    model Radiation1D "1D Radiation Force Calculation for Hydrodynamic Systems"
      extends Hydrodynamic.Forces1D.readHydroParam1D;
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.absolutePosition_con;
      extends Hydrodynamic.Connector.absoluteVelocity_con;
      extends Hydrodynamic.Connector.forceTorque_con;
      // Control parameter
      parameter Boolean enableRadiationForce = true "Switch to enable/disable 1D radiation force calculation";
      // State variables
      Real x[2] "State vector for 1D radiation force model";
      Real F_rad "Calculated 1D radiation force [N]";
    initial equation
      x = {0, 0} "Initialize state vector to zero";
    equation
// 1D Radiation force state-space model
// Note: Only the third element of the velocity vector (vertical motion) is used
      der(x) = A*x + B[:, 1]*v_abs[3];
      F_rad = scalar(C*x) + D*v_abs[3];
// Output: 1D radiation force only in the third element (vertical direction), with enable/disable switch
      if enableRadiationForce then
        F = {0, 0, -F_rad, 0, 0, 0};
      else
        F = {0, 0, 0, 0, 0, 0};
      end if;
      annotation(
        Documentation(info = "<html>
        <h4>1D Radiation Force Model for Hydrodynamic Systems</h4>
        <p>This model calculates the radiation force for hydrodynamic systems using a state-space representation, 
        considering only the vertical direction (1D model).</p>
        
        <p>Model Description:</p>
        <p>The radiation force is computed solely for the vertical direction (third element of the vectors) 
        based on the vertical velocity input. This simplification allows for efficient modeling of systems 
        where the primary concern is the vertical motion, such as in wave energy converters or floating structures.</p>
        
        <p>Inputs:</p>
        <ul>
          <li><code>z[3]</code>: Position vector [m] (currently not used in calculations, included for future extensions)</li>
          <li><code>v[3]</code>: Velocity vector [m/s] (only the third element, representing vertical velocity, is used)</li>
        </ul>
        
        <p>Outputs:</p>
        <ul>
          <li><code>y[3]</code>: Radiation force vector [N] (force applied only in the vertical direction, third element)</li>
        </ul>
        
        <p>Key Parameters:</p>
        <ul>
          <li><code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>: State-space model matrices and vectors for the 1D system</li>
          <li><code>enableRadiationForce</code>: Boolean switch to enable/disable the radiation force calculation</li>
        </ul>
        
        <p>Notes:</p>
        <ul>
          <li>The state-space model parameters (A, B, C, D) should be adjusted based on the specific 1D hydrodynamic system being modeled.</li>
          <li>This model assumes that the radiation force acts only in the vertical direction, simplifying the calculations for many marine applications.</li>
          <li>The position input (z) is currently not used in the calculations but is included for potential future enhancements or compatibility with other models.</li>
        </ul>
      </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "1D Rad F", fontName = "Arial")}));
    end Radiation1D;

    model DragForce6D "6-Dimensional Drag Force and Torque Calculation"
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.absoluteVelocity_con;
      extends Hydrodynamic.Connector.forceTorque_con;
      // Fluid and reference parameters
      parameter Real rho "Density of fluid [kg/m^3]";
      parameter Real A "Reference area [m^2]";
      // Drag coefficients
      parameter Real Cdx "Translational drag coefficient for x-axis [-]";
      parameter Real Cdy "Translational drag coefficient for y-axis [-]";
      parameter Real Cdz "Translational drag coefficient for z-axis [-]";
      parameter Real Crx "Rotational drag coefficient for x-axis [-]";
      parameter Real Cry "Rotational drag coefficient for y-axis [-]";
      parameter Real Crz "Rotational drag coefficient for z-axis [-]";
      parameter Real Cd[6, 6] = diagonal({Cdx, Cdy, Cdz, Crx, Cry, Crz}) "Combined drag coefficient matrix";
      // Control parameter
      parameter Boolean enableDragForce = true "Switch to enable/disable drag force calculation";
      // Internal variables
      Real c "Combined constant term for drag calculation";
      Real fd[6] "6D drag force/torque vector [N, N*m]";
      Real v_omega[6] "Combined linear and angular velocity vector [m/s, rad/s]";
    equation
// Calculate the combined constant term
      c = 0.5*rho*A;
// Combine linear and angular velocities into a single vector
      v_omega = cat(1, v_abs, omega_abs);
// Calculate the 6D drag force/torque vector
      fd = -c*Cd*v_omega.*abs(v_omega);
// Use the switch to conditionally output the force and torque
      if enableDragForce then
        F = fd[1:3];
      else
        F = zeros(6);
      end if;
      annotation(
        Documentation(info = "<html>
        <p>This block calculates the 6-dimensional drag force and torque for both translational and rotational motion in a fluid medium.</p>
        <p>The drag force/torque is calculated using a quadratic drag model, where the force is proportional to the square of the velocity.</p>
        <p>The block can be enabled or disabled using the <code>enableDragForce</code> parameter.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>u</code>: Linear velocity vector [m/s]</li>
          <li><code>a</code>: Angular velocity vector [rad/s]</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>y</code>: Translational drag force vector [N]</li>
          <li><code>y1</code>: Rotational drag torque vector [N*m]</li>
        </ul>
        <p>Key Parameters:</p>
        <ul>
          <li><code>rho</code>: Fluid density [kg/m^3]</li>
          <li><code>A</code>: Reference area [m^2]</li>
          <li><code>Cdx</code>, <code>Cdy</code>, <code>Cdz</code>: Translational drag coefficients [-]</li>
          <li><code>Crx</code>, <code>Cry</code>, <code>Crz</code>: Rotational drag coefficients [-]</li>
        </ul>
        <p>The drag coefficients are combined into a diagonal matrix to allow for different coefficients in each dimension.</p>
      </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "Drag F 6D", fontName = "Arial")}));
    end DragForce6D;

    model HydrostaticForce6D_1DoFRad "6-Dimensional Hydrostatic Force and Torque Calculation"
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.absolutePosition_con;
      extends Hydrodynamic.Connector.forceTorque_con;
      extends Hydrodynamic.Forces1D.readHydroParam1D;
      // Hydrostatic restoring coefficients
      parameter Real G1 "Hydrostatic restoring coefficient for x-axis translation [N/m]";
      parameter Real G2 "Hydrostatic restoring coefficient for y-axis translation [N/m]";
      parameter Real G4 "Hydrostatic restoring coefficient for x-axis rotation [N*m/rad]";
      parameter Real G5 "Hydrostatic restoring coefficient for y-axis rotation [N*m/rad]";
      parameter Real G6 "Hydrostatic restoring coefficient for z-axis rotation [N*m/rad]";
      parameter Real G[6, 6] = diagonal({G1, G2, G3, G4, G5, G6}) "Combined hydrostatic restoring coefficient matrix";
      // Enable/disable force
      parameter Boolean enableHydrostaticForce = true "Switch to enable/disable hydrostatic force calculation";
      // Internal variables
      Real u_theta[6] "Combined displacement vector [m, rad]";
      Real fhs[6] "Hydrostatic force/torque vector [N, N*m]";
    equation
// Combine linear and angular displacements into a single vector
      u_theta = cat(1, u_abs, theta_abs);
// Calculate the 6D hydrostatic force/torque vector
      fhs = -G*u_theta;
// Use the switch to conditionally output the force and torque
      if enableHydrostaticForce then
        F = fhs;
      else
        F = zeros(6);
      end if;
      annotation(
        Documentation(info = "<html>
            <p>This block calculates the 6-dimensional hydrostatic force and torque for both translational and rotational motion in a fluid medium.</p>
            <p>The hydrostatic force/torque is calculated using linear restoring coefficients, where the force is proportional to the displacement from the equilibrium position.</p>
            <p>The block can be enabled or disabled using the <code>enableHydrostaticForce</code> parameter.</p>
            <p>Inputs:</p>
            <ul>
              <li><code>u</code>: Linear displacement vector [m]</li>
              <li><code>theta</code>: Angular displacement vector [rad]</li>
            </ul>
            <p>Outputs:</p>
            <ul>
              <li><code>y</code>: Translational hydrostatic force vector [N]</li>
              <li><code>y1</code>: Rotational hydrostatic torque vector [N*m]</li>
            </ul>
            <p>Key Parameters:</p>
            <ul>
              <li><code>G1</code>, <code>G2</code>, <code>G3</code>: Translational hydrostatic restoring coefficients [N/m]</li>
              <li><code>G4</code>, <code>G5</code>, <code>G6</code>: Rotational hydrostatic restoring coefficients [N*m/rad]</li>
            </ul>
            <p>The hydrostatic restoring coefficients are combined into a diagonal matrix to allow for different coefficients in each dimension.</p>
            <p>Note: By default, only the z-axis translation (heave) has a non-zero restoring coefficient, which is typical for floating bodies.</p>
          </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "HS 6D", fontName = "Arial")}));
    end HydrostaticForce6D_1DoFRad;

    model readHydroParam1D
      extends Modelica.Units.SI;
      extends Modelica.Icons.Package;
      parameter String fileName = "C:/Users/Thomas/Documents/GitHub/OET_6DoF/hydroCoeff_1DoF.mat" "Path to the hydroCoeff.mat file" annotation(
        Dialog(group = "PTO Parameters"));
      parameter Real A[2, 2] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad33.A", 2, 2) "State matrix" annotation(
        Dialog(group = "Radiation Force Parameters"));
      parameter Real B[2, 1] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad33.B", 2, 1) "Input matrix" annotation(
        Dialog(group = "Radiation Force Parameters"));
      parameter Real C[1, 2] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad33.C", 1, 2) "Output matrix" annotation(
        Dialog(group = "Radiation Force Parameters"));
      parameter Real D = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad33.D", 1, 1)) "Feed matrix" annotation(
        Dialog(group = "Radiation Force Parameters"));
      parameter Mass m = M + Ainf "Mass of the body" annotation(
        Dialog(group = "Body"));
      parameter TranslationalSpringConstant G3 = Khs "Hydrostatic restoring coefficient for z-axis translation" annotation(
        Dialog(group = "Hydrostatic Stiffness Parameters"));
      parameter Modelica.Units.SI.Mass M = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.m33", 1, 1)) "Total mass of the body (including ballast)";
      parameter Modelica.Units.SI.Mass Ainf = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.Ainf33", 1, 1)) "Added mass at maximum (cut-off) frequency";
      parameter Modelica.Units.SI.TranslationalSpringConstant Khs = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.Khs33", 1, 1)) "Hydrostatic stiffness";
      parameter Integer wDims[:] = Modelica.Utilities.Streams.readMatrixSize(fileName, "hydroCoeff.w") "Dimensions of the frequency vector";
      parameter Integer wSize = wDims[2] "Size of the frequency vector";
      parameter Real F_excRe[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.FexcRe", 1, wSize)) "Real part of excitation force coefficients";
      parameter Real F_excIm[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.FexcIm", 1, wSize)) "Imaginary part of excitation force coefficients";
      parameter Real w[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.w", 1, wSize)) "Angular frequency vector [rad/s]";
      parameter Real Adep[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.added_mass", wSize, 1)) "Frequency dependent added mass";
      parameter Real Rdamp[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.radiation_damping", wSize, 1)) "Radiation damping";
    equation

      annotation(
        Documentation(info = "<html>
        <p><strong>readHydroParam Model</strong></p>
        <p>This model is designed to read and store hydrodynamic parameters from a MATLAB .mat file. These parameters are crucial for accurate modeling of radiation forces and other hydrodynamic effects in marine and offshore engineering applications. This is also used to store parameters and extend to other blocks. </p>
        
        <p><strong>Parameters:</strong></p>
        <ul>
          <li><strong>fileName:</strong> Path to the MATLAB .mat file containing hydrodynamic coefficients and matrices.</li>
          <li><strong>A:</strong> State matrix of the system, read from the .mat file.</li>
          <li><strong>B:</strong> Input matrix for the system, read from the .mat file.</li>
          <li><strong>C:</strong> Output matrix for the system, read from the .mat file.</li>
          <li><strong>D:</strong> Feed matrix for the system, read from the .mat file.</li>
          <li><strong>m:</strong> Total mass of the body, including added mass.</li>
          <li><strong>G3:</strong> Hydrostatic restoring coefficient for z-axis translation.</li>
          <li><strong>M:</strong> Total mass of the body (including ballast).</li>
          <li><strong>Ainf:</strong> Added mass at maximum (cut-off) frequency.</li>
          <li><strong>Khs:</strong> Hydrostatic stiffness.</li>
          <li><strong>wDims:</strong> Dimensions of the frequency vector.</li>
          <li><strong>wSize:</strong> Size of the frequency vector.</li>
          <li><strong>F_excRe:</strong> Real part of excitation force coefficients.</li>
          <li><strong>F_excIm:</strong> Imaginary part of excitation force coefficients.</li>
          <li><strong>w:</strong> Angular frequency vector [rad/s].</li>
        </ul>
        
        <p><strong>Usage:</strong></p>
        <p>This model is essential for integrating empirical data into hydrodynamic simulations, enabling accurate modeling of radiation forces and system responses based on real-world measurements.</p>
        <p><strong>Applications:</strong></p>
        <ul>
          <li>Marine engineering and offshore structure design.</li>
          <li>Dynamic response analysis of marine systems under wave loads.</li>
          <li>Hydrodynamic modeling for wave energy converters and coastal engineering projects.</li>
        </ul>
      </html>"));
    end readHydroParam1D;

    model PiersonMoskowitzWave1D "Implementation of Pierson-Moskowitz (PM) wave spectrum for irregular wave generation"
      extends Hydrodynamic.readHydroParam;
      extends Modelica.Blocks.Icons.Block;
      import Modelica.Math.Vectors;
      extends Hydrodynamic.Connector.forceandTorque_con;
      // Internal connector for wave properties
      Hydrodynamic.Internal.Connectors.WaveOutConn wconn "Internal connector for wave properties";
      constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
      constant Real g = Modelica.Constants.g_n "Acceleration due to gravity [m/s^2]";
      // Wave and environmental parameters
      parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
        Dialog(group = "Wave Parameters"));
      parameter Modelica.Units.SI.Density rho = 1025 "Density of seawater [kg/m^3]" annotation(
        Dialog(group = "Environmental Parameters"));
      parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
        Dialog(group = "Wave Parameters"));
      parameter Modelica.Units.SI.AngularFrequency omega_min = 0.03141 "Lowest frequency component [rad/s]" annotation(
        Dialog(group = "Spectrum Parameters"));
      parameter Modelica.Units.SI.AngularFrequency omega_max = 3.141 "Highest frequency component [rad/s]" annotation(
        Dialog(group = "Spectrum Parameters"));
      parameter Modelica.Units.SI.AngularFrequency omega_peak = 0.9423 "Peak spectral frequency [rad/s]" annotation(
        Dialog(group = "Spectrum Parameters"));
      parameter Real spectralWidth_min = 0.07 "Lower spectral bound for JONSWAP" annotation(
        Dialog(group = "Spectrum Parameters"));
      parameter Real spectralWidth_max = 0.09 "Upper spectral bound for JONSWAP" annotation(
        Dialog(group = "Spectrum Parameters"));
      parameter Integer n_omega = 500 "Number of frequency components" annotation(
        Dialog(group = "Discretization"));
      parameter Integer localSeed = 614657 "Local random seed for frequency selection" annotation(
        Dialog(group = "Random Generation"));
      parameter Integer globalSeed = 30020 "Global random seed for frequency selection" annotation(
        Dialog(group = "Random Generation"));
      parameter Real rnd_shft[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed, globalSeed, n_omega) "Random shifts for frequency selection";
      parameter Integer localSeed1 = 614757 "Local random seed for phase shifts" annotation(
        Dialog(group = "Random Generation"));
      parameter Integer globalSeed1 = 40020 "Global random seed for phase shifts" annotation(
        Dialog(group = "Random Generation"));
      parameter Real epsilon[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed1, globalSeed1, n_omega) "Wave components phase shift";
      parameter Real Trmp = 100 "Interval for ramping up of waves during start phase [s]" annotation(
        Dialog(group = "Simulation Parameters"));
      // Derived parameters
      parameter Real omega[n_omega] = Hydrodynamic.Internal.Functions.frequencySelector(omega_min, omega_max, rnd_shft) "Selected frequency components [rad/s]";
      parameter Real S[n_omega] = Hydrodynamic.Internal.Functions.spectrumGenerator_PM(Hs, omega) "Spectral values for frequency components [m^2-s/rad]";
      parameter Modelica.Units.SI.Length zeta[n_omega] = sqrt(2*S*omega_min) "Wave amplitude components [m]";
      parameter Real Tp[n_omega] = 2*pi./omega "Wave period components [s]";
      parameter Real k[n_omega] = Hydrodynamic.Internal.Functions.waveNumber(d, omega) "Wave number components [1/m]";
      // Variables
      Real ExcCoeffRe[n_omega] "Real component of excitation coefficient for frequency components";
      Real ExcCoeffIm[n_omega] "Imaginary component of excitation coefficient for frequency components";
      Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
    equation
// Interpolate excitation coefficients (Re & Im) for each frequency component
      for i in 1:n_omega loop
        ExcCoeffRe[i] = Modelica.Math.Vectors.interpolate(w, F_excRe, omega[i])*rho*g;
        ExcCoeffIm[i] = Modelica.Math.Vectors.interpolate(w, F_excIm, omega[i])*rho*g;
      end for;
// Calculate sea surface elevation (SSE) as the sum of all wave components
      SSE = sum(zeta.*cos(omega*time - 2*pi*epsilon));
// Calculate and apply ramping to the excitation force
      if time < Trmp then
// Ramp up the excitation force during the initial phase
        wconn.F_exc = 0.5*(1 + cos(pi + (pi*time/Trmp)))*sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
      else
// Apply full excitation force after the ramping period
        wconn.F_exc = sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
      end if;
// Assign excitation force to output (vertical component only)
      F = {0, 0, wconn.F_exc};
      T = {0, 0, 0};
      annotation(
        Documentation(info = "<html>
          <h4>Pierson-Moskowitz Wave Spectrum Model</h4>
          <p>This model implements the Pierson-Moskowitz (PM) wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
          <p>Key features:</p>
          <ul>
            <li>Generates a wave spectrum based on the PM formulation</li>
            <li>Discretizes the spectrum into multiple frequency components</li>
            <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
            <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
            <li>Applies a ramping function to the excitation force during the initial phase</li>
            <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
          </ul>
          <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
          <h4>Usage Notes:</h4>
          <ul>
            <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
            <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
            <li>Random seeds can be changed to generate different realizations of the same sea state</li>
          </ul>
        </html>"),
        Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " Pierson Moskowitz ", fontName = "Arial")}, coordinateSystem(initialScale = 0.1)),
        experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
    end PiersonMoskowitzWave1D;

    model EqualEnergy_PiersonMoskowitzWave1D "Implementation of Pierson-Moskowitz (PM) wave spectrum for irregular wave generation"
      extends Hydrodynamic.readHydroParam;
      extends Modelica.Blocks.Icons.Block;
      import Modelica.Math.Vectors;
      extends Hydrodynamic.Connector.forceandTorque_con;
      // Internal connector for wave properties
      Hydrodynamic.Internal.Connectors.WaveOutConn wconn "Internal connector for wave properties";
      constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
      constant Real g = Modelica.Constants.g_n "Acceleration due to gravity [m/s^2]";
      // Wave and environmental parameters
      parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
        Dialog(group = "Wave Parameters"));
      parameter Modelica.Units.SI.Density rho = 1025 "Density of seawater [kg/m^3]" annotation(
        Dialog(group = "Environmental Parameters"));
      parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
        Dialog(group = "Wave Parameters"));
      parameter Modelica.Units.SI.AngularFrequency omega_min = 0.03141 "Lowest frequency component [rad/s]" annotation(
        Dialog(group = "Spectrum Parameters"));
      parameter Modelica.Units.SI.AngularFrequency omega_max = 3.141 "Highest frequency component [rad/s]" annotation(
        Dialog(group = "Spectrum Parameters"));
      parameter Modelica.Units.SI.AngularFrequency omega_peak = 0.9423 "Peak spectral frequency [rad/s]" annotation(
        Dialog(group = "Spectrum Parameters"));
      parameter Real spectralWidth_min = 0.07 "Lower spectral bound for JONSWAP" annotation(
        Dialog(group = "Spectrum Parameters"));
      parameter Real spectralWidth_max = 0.09 "Upper spectral bound for JONSWAP" annotation(
        Dialog(group = "Spectrum Parameters"));
      parameter Integer n_omega = 50 "Number of frequency components" annotation(
        Dialog(group = "Discretization"));
      parameter Integer localSeed = 614657 "Local random seed for frequency selection" annotation(
        Dialog(group = "Random Generation"));
      parameter Integer globalSeed = 30020 "Global random seed for frequency selection" annotation(
        Dialog(group = "Random Generation"));
      parameter Real rnd_shft[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed, globalSeed, n_omega) "Random shifts for frequency selection";
      parameter Integer localSeed1 = 614757 "Local random seed for phase shifts" annotation(
        Dialog(group = "Random Generation"));
      parameter Integer globalSeed1 = 40020 "Global random seed for phase shifts" annotation(
        Dialog(group = "Random Generation"));
      parameter Real epsilon[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed1, globalSeed1, n_omega) "Wave components phase shift";
      parameter Real Trmp = 100 "Interval for ramping up of waves during start phase [s]" annotation(
        Dialog(group = "Simulation Parameters"));
      // Derived parameters
      /*parameter Real omega[n_omega] = Hydrodynamic.Internal.Functions.frequencySelector(omega_min, omega_max, rnd_shft) "Selected frequency components [rad/s]"; 
                  
                  parameter Real omega_int[n_omega_int] = Hydrodynamic.Forces1D.integrationFrequencyGen(omega_min, omega_max, n_omega_int);
                  parameter Integer n_omega_int = 500;
                  Real omega[n_omega];
                  Real S[n_omega];
                  // These all (except for S, need to go back to removing _int
                  parameter Real S_int[n_omega_int] = Hydrodynamic.Internal.Functions.spectrumGenerator_PM(Hs, omega_int) "Spectral values for frequency components [m^2-s/rad]";
                  */
      Modelica.Units.SI.Length zeta[n_omega] "Wave amplitude components [m]";
      Real Tp[n_omega] "Wave period components [s]";
      Real k[n_omega] "Wave number components [1/m]";
      // Variables
      Real ExcCoeffRe[n_omega] "Real component of excitation coefficient for frequency components";
      Real ExcCoeffIm[n_omega] "Imaginary component of excitation coefficient for frequency components";
      Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
      //Real mean, new;
      //Real cum[n_omega_int];
      Real domega[n_omega];
    equation
      domega = Hydrodynamic.Forces1D.dfrequencyGen(omega, S, n_omega);
      zeta = sqrt(2*S.*domega);
      Tp = 2*pi./omega;
      k = Hydrodynamic.Internal.Functions.waveNumber(d, omega);
// Can be issues when selecting n_int and n_omega, need to make more robust
      (omega, S) = Hydrodynamic.Forces1D.equalEnergyGen(omega_min, omega_max, n_omega, n_omega_int, omega_int, S_int);
// Interpolate excitation coefficients (Re & Im) for each frequency component
      for i in 1:n_omega loop
        ExcCoeffRe[i] = Modelica.Math.Vectors.interpolate(w, F_excRe, omega[i])*rho*g;
        ExcCoeffIm[i] = Modelica.Math.Vectors.interpolate(w, F_excIm, omega[i])*rho*g;
      end for;
// Calculate sea surface elevation (SSE) as the sum of all wave components
      SSE = sum(zeta.*cos(omega*time - 2*pi*epsilon));
// Calculate and apply ramping to the excitation force
      if time < Trmp then
// Ramp up the excitation force during the initial phase
        wconn.F_exc = 0.5*(1 + cos(pi + (pi*time/Trmp)))*sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
      else
// Apply full excitation force after the ramping period
        wconn.F_exc = sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
      end if;
// Assign excitation force to output (vertical component only)
      F = {0, 0, wconn.F_exc};
      T = {0, 0, 0};
      annotation(
        Documentation(info = "<html>
          <h4>Pierson-Moskowitz Wave Spectrum Model</h4>
          <p>This model implements the Pierson-Moskowitz (PM) wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
          <p>Key features:</p>
          <ul>
            <li>Generates a wave spectrum based on the PM formulation</li>
            <li>Discretizes the spectrum into multiple frequency components</li>
            <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
            <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
            <li>Applies a ramping function to the excitation force during the initial phase</li>
            <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
          </ul>
          <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
          <h4>Usage Notes:</h4>
          <ul>
            <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
            <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
            <li>Random seeds can be changed to generate different realizations of the same sea state</li>
          </ul>
        </html>"),
        Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " Pierson Moskowitz ", fontName = "Arial")}, coordinateSystem(initialScale = 0.1)),
        experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
    end EqualEnergy_PiersonMoskowitzWave1D;

    function equalEnergyGen
      // Can lead to errors if n_omega and n_omega_int are not selected properly, need to make more rubust
      input Real omega_min "Minimum frequency [rad/s]";
      input Real omega_max "Maximum frequency [rad/s]";
      constant input Integer n_omega "Number of frequency compenents defining the spectrum";
      constant input Integer n_omega_int "Number of steps for integrating the spectrum";
      input Real omega_int[n_omega_int] "Integration frquencies";
      input Real S_int[n_omega_int] "Energy Spectrum";
      output Real omega[n_omega] "Output vector of selected frequency components [rad/s]";
      output Real S[n_omega];
      //output Real Cum_energy[n_omega_int] "Vector of cumulative spectrum interval areas";
      //output Real eng_check[n_omega];
      //output Real energy_sum;
      //output Real mean_energy;
      //output Real new_energy;
    protected
      Real domega = (omega_max - omega_min)/(n_omega_int - 1) "Omega int frequency step";
      Real Cum_energy[n_omega_int] "Vector of cumulative spectrum interval areas";
      Real tot_energy "Total energy in the spectrum";
      Real energy "Element to iterate current area off of";
      //Real mean_energy;
      Real tolerance "Tolerance for area";
      //Real current_energy_diff, next_energy_diff;
      //Integer k = 1;
      Real mean_energy;
      Real new_energy;
    algorithm
//energy_sum := 0;
      Cum_energy[1] := 0;
      omega[1] := omega_min;
      omega[n_omega] := omega_max;
      S[1] := S_int[1];
      S[n_omega] := S_int[n_omega_int];
      for i in 2:n_omega_int loop
        energy := Hydrodynamic.Forces1D.trapIntegration(S_int[i - 1], S_int[i], domega);
        Cum_energy[i] := Cum_energy[i - 1] + energy;
      end for;
      tot_energy := Cum_energy[end];
      mean_energy := tot_energy/(n_omega - 1);
      tolerance := mean_energy/5;
      for i in 2:(n_omega - 1) loop
// This is really sensitive to integration step size, need to make more robust
/* for j in k:(n_omega_int-1) loop
            current_energy_diff := abs(Cum_energy[j] - Cum_energy[k] - mean_energy);
            next_energy_diff := abs(Cum_energy[j+1] - Cum_energy[k] - mean_energy);
          
            if  Cum_energy[j] - Cum_energy[k] >= mean_energy or current_energy_diff <= tolerance then 
              omega[i] := omega_int[j];
              S[i] := S_int[j];
              eng_check[i] := Cum_energy[j] - Cum_energy[k];
              energy_sum := energy_sum + eng_check[i];
              k := j;
              break;
            end if;
            
          end for; 
          
          //for j in k:(n_omega_int-1) loop
            new_energy := new_energy + mean_energy;
            
            omega[i] := Modelica.Math.Vectors.interpolate(Cum_energy, omega_int, new_energy);
            S[i] := Modelica.Math.Vectors.interpolate(omega_int, S_int, omega[i]);
          
          //end for; */
      end for;
    end equalEnergyGen;

    function trapIntegration
      input Real y1;
      input Real y2;
      input Real domega;
      output Real Area;
    algorithm
      Area := 0.5*domega*(y1 + y2);
    end trapIntegration;

    function integrationFrequencyGen
      input Real omega_min "Minimum frequency [rad/s]";
      input Real omega_max "Maximum frequency [rad/s]";
      constant input Integer n_omega_int "Number of frequency compenents defining the spectrum";
      output Real omega_int[n_omega_int];
      // = omega_min:domega_int:omega_max "Frequencies for spectrum generation and integration";
    protected
      Real domega_int = (omega_max - omega_min)/(n_omega_int - 1) "Frequency step size";
    algorithm
      for i in 1:n_omega_int loop
        omega_int[i] := omega_min + (i - 1)*(omega_max - omega_min)/(n_omega_int - 1);
      end for;
    end integrationFrequencyGen;

    function dfrequencyGen
      input Real omega[n_omega];
      input Real S[n_omega];
      constant input Integer n_omega;
      output Real domega[n_omega];
    protected
      Real omega_mean;
    algorithm
      for i in 2:n_omega loop
        domega[i] := omega[i] - omega[i - 1];
      end for;
      omega_mean := sum(domega)/n_omega;
      domega[1] := omega_mean;
    end dfrequencyGen;
  end Forces1D;

  package Functions
  end Functions;

  package Connectors
  end Connectors;

  package Models
    model physicalConstants "Defining pi and the acceleration due to gravity"
      // Physical constants
      constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
      constant Modelica.Units.SI.Acceleration g = Modelica.Constants.g_n "Acceleration due to gravity [m/s^2]";
    end physicalConstants;

    partial model forceTorque "Declaring force and torque elements, inheriting forceTorque connector"
      extends Hydrodynamic.Connector.forceTorque_con;
      Real f[6] = cat(1, f_element, t_element);
      // should alter to make nDoF
    protected
      Modelica.Units.SI.Force f_element[3];
      Modelica.Units.SI.Torque t_element[3];
    end forceTorque;

    model positionSensorInput
      // Inheritance
      extends Hydrodynamic.Connector.absolutePosition_con;
    protected
      Real displacement[6] "Combined displacement vector [m, rad]";
    equation
// Combine linear and angular displacements into a single vector
      displacement = cat(1, u_abs, theta_abs);
    end positionSensorInput;

    model velocitySensorInput
      extends Hydrodynamic.Connector.absoluteVelocity_con;
    protected
      Real velocity[6] "Combined velocity vector [m/s, rad/s]";
    equation
// Combine linear and angular velocities into a single vector
      velocity = cat(1, v_abs, omega_abs);
    end velocitySensorInput;

    model accelerationSensorInput
      extends Hydrodynamic.Connector.absoluteAcceleration_con;
    protected
      Real acceleration[6] "Combined velocity vector [m/s, rad/s]";
    equation
// Combine linear and angular accelerations into a single vector
      velocity = cat(1, a_abs, alpha_abs);
    end accelerationSensorInput;
  end Models;

  package Units
    type SpectrumEnergyDensity = Real(final quantity = "SpectrumEnergyDensity", final unit = "m^2 s/rad");
  end Units;

  package HydroDataImport
    record filePath
      parameter String fileName annotation(
        Dialog(group = "Filepath"));
    end filePath;

    partial model excitationData
      extends Hydrodynamic.HydroDataImport.multibodyData;
      extends Hydrodynamic.HydroDataImport.frequencyData;
    protected
      parameter Real F_excRe[nDoF, :] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.excitation.FexcRe", nDoF, wDim[1]) "Real part of excitation force coefficients";
      parameter Real F_excIm[nDoF, :] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.excitation.FexcIm", nDoF, wDim[1]) "Imaginary part of excitation force coefficients";
    end excitationData;

    partial model physicalConstantData
      extends Hydrodynamic.HydroDataImport.filePath;
    protected
      parameter Modelica.Units.SI.Density rho = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.parameters.rho", 1, 1)) "Density of seawater [kg/m^3]" annotation(
        Dialog(group = "Environmental Parameters"));
    end physicalConstantData;

    partial model multibodyData
      extends Hydrodynamic.HydroDataImport.filePath;
    protected
      parameter Real nDoF_read = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.body.ndof", 1, 1)) "Degrees-of-Freedom";
      parameter Integer nDoF = integer(nDoF_read) "Degrees-of-Freedom";
    end multibodyData;

    partial model hydrostaticData
      extends Hydrodynamic.HydroDataImport.multibodyData;
    protected
      parameter Modelica.Units.SI.TranslationalSpringConstant Khs[nDoF, nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.hydroCoefficients.Khs", nDoF, nDoF) "Hydrostatic stiffness";
    end hydrostaticData;

    partial model radiationData
      extends Hydrodynamic.HydroDataImport.multibodyData;
    protected
      parameter Real n_stateSpace[nDoF, nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad.order", nDoF, nDoF) "State-space approximation for each mode";
      parameter Integer n_states[2] = Modelica.Utilities.Streams.readMatrixSize(fileName, "hydroCoeff.ss_rad.processed.A") "Number of states";
      parameter Real A[n_states[1], n_states[1]] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad.processed.A", n_states[1], n_states[1]) "State matrix";
      parameter Real B[n_states[1], nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad.processed.B", n_states[1], nDoF) "Input matrix";
      parameter Real C[nDoF, n_states[1]] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad.processed.C", nDoF, n_states[1]) "Output matrix";
      parameter Real D[nDoF, nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad.processed.D", nDoF, nDoF) "Feedforward matrix";
    end radiationData;

    partial model massData
      extends Hydrodynamic.HydroDataImport.multibodyData;
    protected
      parameter Modelica.Units.SI.Mass M = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.hydroCoefficients.m", 1, 1)) "Total mass of the body (including ballast)";
      parameter Modelica.Units.SI.Mass Ainf[nDoF, nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.hydroCoefficients.Ainf", nDoF, nDoF) "Added mass at maximum (cut-off) frequency";
    end massData;

    partial model ptoData
      // It is able to correctly read the 260x6x6 frequency dependent data, but it crashes Modelica
      // For now will only use simple 1D input
      extends Hydrodynamic.HydroDataImport.frequencyData;
      extends Hydrodynamic.HydroDataImport.massData;
      extends Hydrodynamic.HydroDataImport.multibodyData;
    protected
      /* Full 260x6x6 data, but it crashes Modelica
          
            // Declare a variable to hold the imported data
            Real Adep_flat[wDim[1], nDoF * nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.PTO.Adep", wDim[1], nDoF * nDoF); // Holds the flattened matrix (260x36)
            Real Rdamp_flat[wDim[1], nDoF * nDoF] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.PTO.Rdamp", wDim[1], nDoF * nDoF); // Holds the flattened matrix (260x36)
          
          
            // Declare the reshaped variable
            Real Adep[wDim[1], nDoF, nDoF]; // Reshape back to (260x6x6)
            Real Rdamp[wDim[1], nDoF, nDoF]; // Reshape back to (260x6x6)
          
          equation
            // Reshape the flattened matrix back into a 3D matrix
            for i in 1:wDim[1] loop
              for j in 1:nDoF loop
                for k in 1:nDoF loop
                  Adep[i, k, j] = Adep_flat[i, (j - 1) * nDoF + k]; // Reshape the data
                  Rdamp[i, k, j] = Rdamp_flat[i, (j - 1) * nDoF + k]; // Reshape the data
                end for;
              end for;
            end for;
            
          */
      // 1D PTO data
      parameter Real Adep[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.PTO1D.added_mass", wDim[1], 1)) "Frequency dependent added mass";
      parameter Real Rdamp[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.PTO1D.radiation_damping", wDim[1], 1)) "Radiation damping";
    end ptoData;

    partial model bodyProperties
      extends Hydrodynamic.HydroDataImport.filePath;
      Integer bodyNumber = integer(bodyNumber_read);
      //String bodyName = Modelica.Math.Matrices.toString(bodyName_read);
    protected
      Real bodyNumber_read = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.bodyProperties.body1.number", 1, 1)) "Body number";
      //Real bodyName_read[1,1] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.bodyProperties.body1.name", 1, 1) "Body name"; // cannot read string easily into Modelica
    end bodyProperties;

    partial model frequencyData
      extends Hydrodynamic.HydroDataImport.filePath;
    protected
      parameter Integer wDim[2] = Modelica.Utilities.Streams.readMatrixSize(fileName, "hydroCoeff.excitation.w") "Dimensions of the frequency vector";
      parameter Real w[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.excitation.w", wDim[1], 1)) "Angular frequency vector [rad/s]";
    end frequencyData;
  end HydroDataImport;

  package Mooring
    model LinearMooring
      // Inhertitance
      extends Hydrodynamic.Connector.forceandTorque_con;
      extends Hydrodynamic.Models.positionSensorInput;
      extends Hydrodynamic.Models.velocitySensorInput;
      parameter Real C[6, 6] = [0, 0, 0, 0, 0, 0; 0, 0, 0, 0, 0, 0; 0, 0, 0, 0, 0, 0; 0, 0, 0, 0, 0, 0; 0, 0, 0, 0, 0, 0; 0, 0, 0, 0, 0, 0] "Linear Mooring Damping" annotation(
        Dialog(group = "Linear Mooring Parameters"));
      parameter Real K[6, 6] = [0, 0, 0, 0, 0, 0; 0, 0, 0, 0, 0, 0; 0, 0, 0, 0, 0, 0; 0, 0, 0, 0, 0, 0; 0, 0, 0, 0, 0, 0; 0, 0, 0, 0, 0, 0] "Linear Mooring Stiffness" annotation(
        Dialog(group = "Linear Mooring Parameters"));
      Real f[6] = cat(1, f_element, t_element);
      // should adjust code so no inheritance issue with F when using Models.forceTorque
      // should alter to make nDoF
    protected
      Modelica.Units.SI.Force f_element[3];
      Modelica.Units.SI.Torque t_element[3];
    equation
      f = C*velocity + K*displacement;
      F = -f[1:3];
      T = -f[4:6];
    end LinearMooring;

    model LinearMooringForce
    // Use this so the linear mooring is embedded with the force torque element. Will first need to apply sensors to frame A
    // and force and torque output from frame B
    equation

    end LinearMooringForce;
  end Mooring;
  annotation(
    Icon(graphics = {Line(points = {{-90, 40}, {-60, 60}, {-30, 20}, {0, 60}, {30, 20}, {60, 60}, {90, 40}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Line(points = {{-90, -40}, {-60, -20}, {-30, -60}, {0, -20}, {30, -60}, {60, -20}, {90, -40}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Ellipse(extent = {{-20, 20}, {20, -20}}, lineColor = {0, 0, 0}, fillColor = // Black circle
    {0, 0, 0}, fillPattern = // Light gray fill
    FillPattern.Solid// Solid fill
    )}),
    Documentation(info = "<html>
    <p><strong>Hydrodynamic Package</strong></p>
    
    <p>This package contains models and components for simulating hydrodynamic systems, 
    particularly focused on Wave Energy Converters (WECs). The current implementation 
    includes a variety of models and force components across several sub-packages.</p>
    
    <p><strong>Key Sub-Packages:</strong></p>
    <ul>
        <li><strong>Example:</strong>
            <ul>
                <li><strong>SingleBodyWEC1D:</strong> A 1D single-body Wave Energy Converter model.</li>
            </ul>
        </li>
        <li><strong>Forces:</strong>
            <ul>
                <li><strong>HydrostaticForce6D:</strong> Calculates 6D hydrostatic forces and torques.</li>
                <li><strong>RadiationForce:</strong> Computes radiation forces (currently 1D, vertical direction only).</li>
                <li><strong>DragForce6D:</strong> Computes 6D drag forces and torques.</li>
                <li><strong>PTO6D:</strong> Models a 6D Power Take-Off system.</li>
                <li><strong>HydrodynamicBlock6D:</strong> Calculates and applies 6D hydrodynamic forces and moments.</li>
                <li><strong>RadiationF3D:</strong> An extended version of RadiationForce for 3D modeling.</li>
            </ul>
        </li>
        <li><strong>WaveProfile:</strong>
            <ul>
                <li><strong>RegularWave:</strong> A linear wave model.</li>
                <li><strong>IrregularWave:</strong> Includes Pierson-Moskowitz, Bretschneider, JONSWAP wave models, and various irregular parameters.</li>
            </ul>
        </li>
        <li><strong>Connector:</strong> Contains connector definitions for hydrodynamic components.</li>
        <li><strong>Internal:</strong> Contains internal utility components used across the package.</li>
        <li><strong>Archive:</strong> Contains deprecated or experimental models and components.</li>
    </ul>
    
    <p><strong>Current Capabilities:</strong></p>
    <p>The package allows for modeling of a single-body WEC with the following features:</p>
    <ul>
        <li>6D modeling of drag, PTO, and hydrostatic forces</li>
        <li>1D and 3D modeling of radiation forces</li>
        <li>External excitation force input</li>
        <li>Rigid body dynamics in 6D</li>
        <li>Wave profile modeling including regular and irregular waves</li>
    </ul>
    
    <p><strong>Limitations and Future Work:</strong></p>
    <ul>
        <li>Further extension of radiation forces to full 6D capabilities</li>
        <li>Expansion of the excitation force model to include full 6D capabilities</li>
        <li>Implementation of additional WEC configurations (e.g., multi-body systems)</li>
    </ul>
    
    <p>This package provides a foundation for hydrodynamic simulations in Modelica, 
    particularly suited for Wave Energy Converter applications. Users can leverage 
    these components to build and simulate various marine energy devices.</p>
</html>"),
    uses(Modelica(version = "4.0.0")));
end Hydrodynamic;
